{
    "docs": [
        {
            "location": "/index.html",
            "text": "Raspberry Pi Documentation\n\n\n\n\nInfo\n\n\nThis is the official documentation for the Raspberry Pi, written by the \nRaspberry Pi Foundation\n with community contributions.\n\n\n\n\nContents\n\n\n\n\nSetup / Quickstart\n\n\nGetting started with your Raspberry Pi, including what you need and how to get it booted\n\n\n\n\n\n\nInstallation\n\n\nInstalling an operating system on your Raspberry Pi\n\n\n\n\n\n\nUsage Guide\n\n\nExplore the desktop and try out all the main applications\n\n\n\n\n\n\nConfiguration\n\n\nConfiguring the Pi's settings to suit your needs\n\n\n\n\n\n\nRemote Access\n\n\nAccessing your Pi remotely via SSH, VNC or over the web\n\n\n\n\n\n\nLinux\n\n\nFundamental Linux usage for beginners and more advanced information for power users\n\n\n\n\n\n\nRaspbian\n\n\nInformation about the recommended operating system for Raspberry Pi\n\n\n\n\n\n\nHardware\n\n\nTechnical specifications about the Raspberry Pi hardware and the camera module\n\n\n\n\n\n\n\n\nContributions\n\n\nIf you have anything to fix or details to add, first \nfile an issue\n on GitHub to see if it is likely to be accepted, then file a pull request with your change (one PR per issue).\n\n\nThis is not intended to be an open wiki; we want to keep it concise and minimal but will accept fixes and suitable additions.\n\n\nSee our \ncontributing policy\n.\n\n\nLicence\n\n\nUnless otherwise specified, everything in this repository is covered by the following licence:\n\n\n\n\nRaspberry Pi Documentation\n by the \nRaspberry Pi Foundation\n is licensed under a \nCreative Commons Attribution 4.0 International Licence\n.\n\n\nBased on a work at https://github.com/raspberrypi/documentation",
            "title": "Raspberry Pi Documentation"
        },
        {
            "location": "/index.html#raspberry-pi-documentation",
            "text": "Info  This is the official documentation for the Raspberry Pi, written by the  Raspberry Pi Foundation  with community contributions.",
            "title": "Raspberry Pi Documentation"
        },
        {
            "location": "/index.html#contents",
            "text": "Setup / Quickstart  Getting started with your Raspberry Pi, including what you need and how to get it booted    Installation  Installing an operating system on your Raspberry Pi    Usage Guide  Explore the desktop and try out all the main applications    Configuration  Configuring the Pi's settings to suit your needs    Remote Access  Accessing your Pi remotely via SSH, VNC or over the web    Linux  Fundamental Linux usage for beginners and more advanced information for power users    Raspbian  Information about the recommended operating system for Raspberry Pi    Hardware  Technical specifications about the Raspberry Pi hardware and the camera module",
            "title": "Contents"
        },
        {
            "location": "/index.html#contributions",
            "text": "If you have anything to fix or details to add, first  file an issue  on GitHub to see if it is likely to be accepted, then file a pull request with your change (one PR per issue).  This is not intended to be an open wiki; we want to keep it concise and minimal but will accept fixes and suitable additions.  See our  contributing policy .",
            "title": "Contributions"
        },
        {
            "location": "/index.html#licence",
            "text": "Unless otherwise specified, everything in this repository is covered by the following licence:   Raspberry Pi Documentation  by the  Raspberry Pi Foundation  is licensed under a  Creative Commons Attribution 4.0 International Licence .  Based on a work at https://github.com/raspberrypi/documentation",
            "title": "Licence"
        },
        {
            "location": "/configuration/README/index.html",
            "text": "Configuration\n\n\nSome basic guides to configuring your Raspberry Pi.\n\n\nContents\n\n\n\n\nraspi-config\n\n\nThe Raspberry Pi configuration tool in Raspbian, allowing you to easily enable features such as the camera, and to change your specific settings such as keyboard layout.\n\n\n\n\n\n\nconfig.txt\n\n\nThe Raspberry Pi configuration file.\n\n\n\n\n\n\nWireless\n\n\nConfiguring your Pi to connect to a wireless network using the Raspberry Pi 3 and Pi Zero W's inbuilt wireless connectivity, or a USB wireless dongle.\n\n\n\n\n\n\nWireless Access Point\n\n\nConfiguring your Pi as a wireless access point using the Raspberry Pi 3 and Pi Zero W's inbuilt wireless connectivity, or a USB wireless dongle.\n\n\n\n\n\n\nAudio Config\n\n\nSwitch your audio output between HDMI and the 3.5mm jack.\n\n\n\n\n\n\nCamera Config\n\n\nInstalling and setting up the Raspberry Pi camera board.\n\n\n\n\n\n\nExternal Storage Config\n\n\nMounting and setting up external storage on a Raspberry Pi.\n\n\n\n\n\n\nLocalisation\n\n\nSetting up your Pi to work in your local language/timezone.\n\n\n\n\n\n\nDefault pin configuration\n\n\nChanging the default pin states.\n\n\n\n\n\n\nDevice Trees Config\n\n\nDevice Trees, overlays, and parameters.\n\n\n\n\n\n\nKernel Command line\n\n\nHow to set options in the kernel command line.\n\n\n\n\n\n\nUART configuration\n\n\nHow to set up the on-board UARTS.\n\n\n\n\n\n\nFirmware Warning Icons\n\n\nDescription of warning icons displayed if the firmware detects issues.\n\n\n\n\n\n\nSecuring your Raspberry Pi\n\n\nSome basic help with making your Raspberry Pi more secure.\n\n\n\n\n\n\nScreensaver\n\n\nHow to configure screen blanking/screen saver",
            "title": "Configuration"
        },
        {
            "location": "/configuration/README/index.html#configuration",
            "text": "Some basic guides to configuring your Raspberry Pi.",
            "title": "Configuration"
        },
        {
            "location": "/configuration/README/index.html#contents",
            "text": "raspi-config  The Raspberry Pi configuration tool in Raspbian, allowing you to easily enable features such as the camera, and to change your specific settings such as keyboard layout.    config.txt  The Raspberry Pi configuration file.    Wireless  Configuring your Pi to connect to a wireless network using the Raspberry Pi 3 and Pi Zero W's inbuilt wireless connectivity, or a USB wireless dongle.    Wireless Access Point  Configuring your Pi as a wireless access point using the Raspberry Pi 3 and Pi Zero W's inbuilt wireless connectivity, or a USB wireless dongle.    Audio Config  Switch your audio output between HDMI and the 3.5mm jack.    Camera Config  Installing and setting up the Raspberry Pi camera board.    External Storage Config  Mounting and setting up external storage on a Raspberry Pi.    Localisation  Setting up your Pi to work in your local language/timezone.    Default pin configuration  Changing the default pin states.    Device Trees Config  Device Trees, overlays, and parameters.    Kernel Command line  How to set options in the kernel command line.    UART configuration  How to set up the on-board UARTS.    Firmware Warning Icons  Description of warning icons displayed if the firmware detects issues.    Securing your Raspberry Pi  Some basic help with making your Raspberry Pi more secure.    Screensaver  How to configure screen blanking/screen saver",
            "title": "Contents"
        },
        {
            "location": "/configuration/audio-config/index.html",
            "text": "Audio configuration\n\n\nThe Raspberry Pi has two audio output modes: HDMI and headphone jack. You can switch between these modes at any time.\n\n\nIf your HDMI monitor or TV has built-in speakers, the audio can be played over the HDMI cable, but you can switch it to a set of headphones or other speakers plugged into the headphone jack. If your display claims to have speakers, sound is output via HDMI by default; if not, it is output via the headphone jack. This may not be the desired output setup, or the auto-detection is inaccurate, in which case you can manually switch the output.\n\n\nChanging the audio output\n\n\nThere are three ways of setting the audio output.\n\n\nDesktop volume control\n\n\nRight-clicking the volume icon on the desktop taskbar brings up the audio output selector; this allows you to select between the internal audio outputs. It also allows you to select any external audio devices, such as USB sound cards and Bluetooth audio devices. A green tick is shown against the currently selected audio output device \u2014 simply left-click the desired output in the pop-up menu to change this. The volume control and mute operate on the currently selected device.\n\n\nCommand line\n\n\nThe following command, entered in the command line, will switch the audio output to HDMI:\n\n\namixer cset numid=3 2\n\n\n\n\n\nHere the output is being set to \n2\n, which is HDMI. Setting the output to \n1\n switches to analogue (headphone jack). The default setting is \n0\n which is automatic.\n\n\nraspi-config\n\n\nOpen up \nraspi-config\n by entering the following into the command line:\n\n\nsudo raspi-config\n\n\n\n\n\nThis will open the configuration screen:\n\n\n\n\nSelect Option 8 \nAdvanced Options\n and press \nEnter\n, then select Option A6: \nAudio\n and press \nEnter\n:\n\n\n\n\nNow you are presented with the two modes explained above as an alternative to the default \nAuto\n option. Select a mode, press \nEnter\n and press the right arrow key to exit the options list, then select \nFinish\n to exit the configuration tool.\n\n\nIf you're still not getting sound via HDMI\n\n\nIn some rare cases, it is necessary to edit \nconfig.txt\n to force HDMI mode (as opposed to DVI mode, which does not send sound). You can do this by editing \n/boot/config.txt\n and setting \nhdmi_drive=2\n, then rebooting for the change to take effect.",
            "title": "Audio configuration"
        },
        {
            "location": "/configuration/audio-config/index.html#audio-configuration",
            "text": "The Raspberry Pi has two audio output modes: HDMI and headphone jack. You can switch between these modes at any time.  If your HDMI monitor or TV has built-in speakers, the audio can be played over the HDMI cable, but you can switch it to a set of headphones or other speakers plugged into the headphone jack. If your display claims to have speakers, sound is output via HDMI by default; if not, it is output via the headphone jack. This may not be the desired output setup, or the auto-detection is inaccurate, in which case you can manually switch the output.",
            "title": "Audio configuration"
        },
        {
            "location": "/configuration/audio-config/index.html#changing-the-audio-output",
            "text": "There are three ways of setting the audio output.",
            "title": "Changing the audio output"
        },
        {
            "location": "/configuration/audio-config/index.html#desktop-volume-control",
            "text": "Right-clicking the volume icon on the desktop taskbar brings up the audio output selector; this allows you to select between the internal audio outputs. It also allows you to select any external audio devices, such as USB sound cards and Bluetooth audio devices. A green tick is shown against the currently selected audio output device \u2014 simply left-click the desired output in the pop-up menu to change this. The volume control and mute operate on the currently selected device.",
            "title": "Desktop volume control"
        },
        {
            "location": "/configuration/audio-config/index.html#command-line",
            "text": "The following command, entered in the command line, will switch the audio output to HDMI:  amixer cset numid=3 2  Here the output is being set to  2 , which is HDMI. Setting the output to  1  switches to analogue (headphone jack). The default setting is  0  which is automatic.",
            "title": "Command line"
        },
        {
            "location": "/configuration/audio-config/index.html#raspi-config",
            "text": "Open up  raspi-config  by entering the following into the command line:  sudo raspi-config  This will open the configuration screen:   Select Option 8  Advanced Options  and press  Enter , then select Option A6:  Audio  and press  Enter :   Now you are presented with the two modes explained above as an alternative to the default  Auto  option. Select a mode, press  Enter  and press the right arrow key to exit the options list, then select  Finish  to exit the configuration tool.",
            "title": "raspi-config"
        },
        {
            "location": "/configuration/audio-config/index.html#if-youre-still-not-getting-sound-via-hdmi",
            "text": "In some rare cases, it is necessary to edit  config.txt  to force HDMI mode (as opposed to DVI mode, which does not send sound). You can do this by editing  /boot/config.txt  and setting  hdmi_drive=2 , then rebooting for the change to take effect.",
            "title": "If you're still not getting sound via HDMI"
        },
        {
            "location": "/configuration/camera/index.html",
            "text": "Camera configuration\n\n\nSetting up the camera hardware\n\n\nWarning\n: Cameras are sensitive to static. Earth yourself prior to handling the PCB. A sink tap or similar should suffice if you don\u2019t have an earthing strap.\n\n\nThe camera board attaches to the Raspberry Pi via a 15-way ribbon cable. There are only two connections to make: the ribbon cable needs to be attached to the camera PCB, and to the Raspberry Pi itself. You need to get the cable the right way round, or the camera will not work. On the camera PCB, the blue backing on the cable should face away from the PCB, and on the Raspberry Pi it should face towards the Ethernet connection (or where the Ethernet connector would be if you're using a model A).\n\n\nAlthough the connectors on the PCB and the Pi are different, they work in a similar way. On the Raspberry Pi itself, pull up the tabs on each end of the connector. It should slide up easily, and be able to pivot around slightly. Fully insert the ribbon cable into the slot, ensuring it is set straight, then gently press down the tabs to clip it into place. The camera PCB connector also requires you to pull the tabs away from the board, gently insert the cable, then push the tabs back. The PCB connector can be a little more awkward than the one on the Pi itself.\n\n\nSetting up the camera software\n\n\nExecute the following instructions on the command line to download and install the latest kernel, GPU firmware, and applications. You'll need an internet connection for this to work correctly.\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\n\nNow you need to enable camera support using the \nraspi-config\n program you will have used when you first set up your Raspberry Pi.\n\n\nsudo raspi-config\n\n\n\n\n\nUse the cursor keys to move to the camera option, and select 'enable'. On exiting \nraspi-config\n, it will ask to reboot. The enable option will ensure that on reboot the correct GPU firmware will be running with the camera driver and tuning, and the GPU memory split is sufficient to allow the camera to acquire enough memory to run correctly.\n\n\nTo test that the system is installed and working, try the following command:\n\n\nraspistill -v -o test.jpg\n\n\n\n\n\nThe display should show a five-second preview from the camera and then take a picture, saved to the file \ntest.jpg\n, whilst displaying various informational messages.\n\n\nMore Information\n\n\nSee \nCamera Software\n.",
            "title": "Camera configuration"
        },
        {
            "location": "/configuration/camera/index.html#camera-configuration",
            "text": "",
            "title": "Camera configuration"
        },
        {
            "location": "/configuration/camera/index.html#setting-up-the-camera-hardware",
            "text": "Warning : Cameras are sensitive to static. Earth yourself prior to handling the PCB. A sink tap or similar should suffice if you don\u2019t have an earthing strap.  The camera board attaches to the Raspberry Pi via a 15-way ribbon cable. There are only two connections to make: the ribbon cable needs to be attached to the camera PCB, and to the Raspberry Pi itself. You need to get the cable the right way round, or the camera will not work. On the camera PCB, the blue backing on the cable should face away from the PCB, and on the Raspberry Pi it should face towards the Ethernet connection (or where the Ethernet connector would be if you're using a model A).  Although the connectors on the PCB and the Pi are different, they work in a similar way. On the Raspberry Pi itself, pull up the tabs on each end of the connector. It should slide up easily, and be able to pivot around slightly. Fully insert the ribbon cable into the slot, ensuring it is set straight, then gently press down the tabs to clip it into place. The camera PCB connector also requires you to pull the tabs away from the board, gently insert the cable, then push the tabs back. The PCB connector can be a little more awkward than the one on the Pi itself.",
            "title": "Setting up the camera hardware"
        },
        {
            "location": "/configuration/camera/index.html#setting-up-the-camera-software",
            "text": "Execute the following instructions on the command line to download and install the latest kernel, GPU firmware, and applications. You'll need an internet connection for this to work correctly.  sudo apt-get update\nsudo apt-get upgrade  Now you need to enable camera support using the  raspi-config  program you will have used when you first set up your Raspberry Pi.  sudo raspi-config  Use the cursor keys to move to the camera option, and select 'enable'. On exiting  raspi-config , it will ask to reboot. The enable option will ensure that on reboot the correct GPU firmware will be running with the camera driver and tuning, and the GPU memory split is sufficient to allow the camera to acquire enough memory to run correctly.  To test that the system is installed and working, try the following command:  raspistill -v -o test.jpg  The display should show a five-second preview from the camera and then take a picture, saved to the file  test.jpg , whilst displaying various informational messages.",
            "title": "Setting up the camera software"
        },
        {
            "location": "/configuration/camera/index.html#more-information",
            "text": "See  Camera Software .",
            "title": "More Information"
        },
        {
            "location": "/configuration/cmdline-txt/index.html",
            "text": "The Kernel Command Line\n\n\nThe Linux kernel accepts a command line of parameters during boot. On the Raspberry Pi, this command line is defined in a file in the boot partition, called cmdline.txt. This is a simple text file that can be edited using any text editor, e.g. Nano.\n\n\nsudo nano /boot/cmdline.txt\n\n\n\n\n\nNote that we have to use \nsudo\n to edit anything in the boot partition.\n\n\nCommand Line Options\n\n\nThere are many kernel command line parameters, some of which are defined by the kernel. Others are defined by code that the kernel may be using, such as the Plymouth splash screen system.\n\n\nStandard Entries\n\n\n\n\nconsole: defines the serial console. There are usually two entries:\n\n\nconsole=serial0,115200\n\n\nconsole=tty1\n\n\n\n\n\n\nroot: defines the location of the root filesystem, e.g. \nroot=/dev/mmcblk0p2\n means multimedia card block 0 partition 2.\n\n\nrootfstype: defines what type of filesystem the rootfs uses, e.g. \nrootfstype=ext4\n\n\nelevator: specifies the I/O scheduler to use. \nelevator=deadline\n means the kernel imposes a deadline on all I/O operations to prevent request starvation.\n\n\nquiet: sets the default kernel log level to \nKERN_WARNING\n, which suppresses all but very serious log messages during boot.\n\n\n\n\nOther Entries (not exhaustive)\n\n\n\n\nsplash: tells the boot to use a splash screen via the Plymouth module.\n\n\nplymouth.ignore_serial_console\n\n\ndwc_otg.lpm_enable: turns off LPM in the dwc_otg (On The Go) driver.\n\n\ndwc_otg.speed: sets the speed of the USB property. \ndwc_otg.speed=1\n will set it to USBv1.0 speed.\n\n\nsmsc95xx.turbo_mode: enables/disables the wired networking driver turbo mode. \nsmsc95xx.turbo_mode=N\n turns turbo mode off.\n\n\nusbhid.mousepoll: specifies the mouse polling interval. If you have problems with a slow or erratic wireless mouse, setting this to 0 might help: \nusbhid.mousepoll=0\n.",
            "title": "The Kernel Command Line"
        },
        {
            "location": "/configuration/cmdline-txt/index.html#the-kernel-command-line",
            "text": "The Linux kernel accepts a command line of parameters during boot. On the Raspberry Pi, this command line is defined in a file in the boot partition, called cmdline.txt. This is a simple text file that can be edited using any text editor, e.g. Nano.  sudo nano /boot/cmdline.txt  Note that we have to use  sudo  to edit anything in the boot partition.",
            "title": "The Kernel Command Line"
        },
        {
            "location": "/configuration/cmdline-txt/index.html#command-line-options",
            "text": "There are many kernel command line parameters, some of which are defined by the kernel. Others are defined by code that the kernel may be using, such as the Plymouth splash screen system.",
            "title": "Command Line Options"
        },
        {
            "location": "/configuration/cmdline-txt/index.html#standard-entries",
            "text": "console: defines the serial console. There are usually two entries:  console=serial0,115200  console=tty1    root: defines the location of the root filesystem, e.g.  root=/dev/mmcblk0p2  means multimedia card block 0 partition 2.  rootfstype: defines what type of filesystem the rootfs uses, e.g.  rootfstype=ext4  elevator: specifies the I/O scheduler to use.  elevator=deadline  means the kernel imposes a deadline on all I/O operations to prevent request starvation.  quiet: sets the default kernel log level to  KERN_WARNING , which suppresses all but very serious log messages during boot.",
            "title": "Standard Entries"
        },
        {
            "location": "/configuration/cmdline-txt/index.html#other-entries-not-exhaustive",
            "text": "splash: tells the boot to use a splash screen via the Plymouth module.  plymouth.ignore_serial_console  dwc_otg.lpm_enable: turns off LPM in the dwc_otg (On The Go) driver.  dwc_otg.speed: sets the speed of the USB property.  dwc_otg.speed=1  will set it to USBv1.0 speed.  smsc95xx.turbo_mode: enables/disables the wired networking driver turbo mode.  smsc95xx.turbo_mode=N  turns turbo mode off.  usbhid.mousepoll: specifies the mouse polling interval. If you have problems with a slow or erratic wireless mouse, setting this to 0 might help:  usbhid.mousepoll=0 .",
            "title": "Other Entries (not exhaustive)"
        },
        {
            "location": "/configuration/config-txt/index.html",
            "text": "config.txt\n\n\nThis file has moved to \nconfig-txt/README.md",
            "title": "config.txt"
        },
        {
            "location": "/configuration/config-txt/index.html#configtxt",
            "text": "This file has moved to  config-txt/README.md",
            "title": "config.txt"
        },
        {
            "location": "/configuration/device-tree/index.html",
            "text": "Device Trees, overlays, and parameters\n\n\nRaspberry Pi's latest kernels and firmware, including Raspbian and NOOBS releases, now use a Device Tree (DT) to manage some resource allocation and module loading by default. This was implemented to alleviate the problem of multiple drivers contending for system resources, and to allow HAT modules to be auto-configured.\n\n\nThe current implementation is not a pure Device Tree system \u2013 there is still board support code that creates some platform devices \u2013 but the external interfaces (I2C, I2S, SPI), and the audio devices that use them, must now be instantiated using a Device Tree Blob (DTB) passed to the kernel by the loader (\nstart.elf\n).\n\n\nThe main impact of using Device Tree is to change from \neverything on\n, relying on module blacklisting to manage contention, to \neverything off unless requested by the DTB\n. In order to continue to use external interfaces and the peripherals that attach to them, you will need to add some new settings to your \nconfig.txt\n. Full details are given in \nPart 3\n, but these are a few examples:\n\n\n# Uncomment some or all of these lines to enable the optional hardware interfaces\n#dtparam=i2c_arm=on\n#dtparam=i2s=on\n#dtparam=spi=on\n\n# Uncomment one of these lines to enable an audio interface\n#dtoverlay=hifiberry-amp\n#dtoverlay=hifiberry-dac\n#dtoverlay=hifiberry-dacplus\n#dtoverlay=hifiberry-digi\n#dtoverlay=iqaudio-dac\n#dtoverlay=iqaudio-dacplus\n#dtoverlay=audioinjector-wm8731-audio\n\n# Uncomment this to enable the lirc-rpi module\n#dtoverlay=lirc-rpi\n\n# Uncomment this to override the defaults for the lirc-rpi module\n#dtparam=gpio_out_pin=16\n#dtparam=gpio_in_pin=17\n#dtparam=gpio_in_pull=down\n\n\n\n\n\n\n\nDevice Trees\n\n\nA Device Tree (DT) is a description of the hardware in a system. It should include the name of the base CPU, its memory configuration, and any peripherals (internal and external). A DT should not be used to describe the software, although by listing the hardware modules it does usually cause driver modules to be loaded. It helps to remember that DTs are supposed to be OS-neutral, so anything which is Linux-specific probably shouldn't be there.\n\n\nA Device Tree represents the hardware configuration as a hierarchy of nodes. Each node may contain properties and subnodes. Properties are named arrays of bytes, which may contain strings, numbers (big-endian), arbitrary sequences of bytes, and any combination thereof. By analogy to a filesystem, nodes are directories and properties are files. The locations of nodes and properties within the tree can be described using a path, with slashes as separators and a single slash (\n/\n) to indicate the root.\n\n\n\n\n1.1: Basic DTS syntax\n\n\nDevice Trees are usually written in a textual form known as Device Tree Source (DTS) and stored in files with a \n.dts\n suffix. DTS syntax is C-like, with braces for grouping and semicolons at the end of each line. Note that DTS requires semicolons after closing braces: think of C \nstruct\ns rather than functions. The compiled binary format is referred to as Flattened Device Tree (FDT) or Device Tree Blob (DTB), and is stored in \n.dtb\n files.\n\n\nThe following is a simple tree in the \n.dts\n format:\n\n\n/dts-v1/;\n/include/ \"common.dtsi\";\n\n/ {\n    node1 {\n        a-string-property = \"A string\";\n        a-string-list-property = \"first string\", \"second string\";\n        a-byte-data-property = [0x01 0x23 0x34 0x56];\n        cousin: child-node1 {\n            first-child-property;\n            second-child-property = <1>;\n            a-string-property = \"Hello, world\";\n        };\n        child-node2 {\n        };\n    };\n    node2 {\n        an-empty-property;\n        a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */\n        child-node1 {\n            my-cousin = <&cousin>;\n        };\n    };\n};\n\n/node2 {\n    another-property-for-node2;\n};\n\n\n\n\n\nThis tree contains:\n\n\n\n\na required header: \n/dts-v1/\n.\n\n\nThe inclusion of another DTS file, conventionally named \n*.dtsi\n and analogous to a \n.h\n header file in C - see \nAn aside about /include/\n below.\n\n\na single root node: \n/\n\n\na couple of child nodes: \nnode1\n and \nnode2\n\n\nsome children for node1: \nchild-node1\n and \nchild-node2\n\n\na label (\ncousin\n) and a reference to that label (\n&cousin\n): see \nLabels and References\n below.\n\n\nseveral properties scattered through the tree\n\n\na repeated node (\n/node2\n) - see \nAn aside about /include/\n below.\n\n\n\n\nProperties are simple key-value pairs where the value can either be empty or contain an arbitrary byte stream. While data types are not encoded in the data structure, there are a few fundamental data representations that can be expressed in a Device Tree source file.\n\n\nText strings (NUL-terminated) are indicated with double quotes:\n\n\nstring-property = \"a string\";\n\n\n\n\n\nCells are 32-bit unsigned integers delimited by angle brackets:\n\n\ncell-property = <0xbeef 123 0xabcd1234>;\n\n\n\n\n\nArbitrary byte data is delimited with square brackets, and entered in hex:\n\n\nbinary-property = [01 23 45 67 89 ab cd ef];\n\n\n\n\n\nData of differing representations can be concatenated using a comma:\n\n\nmixed-property = \"a string\", [01 23 45 67], <0x12345678>;\n\n\n\n\n\nCommas are also used to create lists of strings:\n\n\nstring-list = \"red fish\", \"blue fish\";\n\n\n\n\n\n\n\n1.2: An aside about /include/\n\n\nThe \n/include/\n directive results in simple textual inclusion, much like C's \n#include\n directive, but a feature of the Device Tree compiler leads to different usage patterns. Given that nodes are named, potentially with absolute paths, it is possible for the same node to appear twice in a DTS file (and its inclusions). When this happens, the nodes and properties are combined, interleaving and overwriting properties as required (later values override earlier ones).\n\n\nIn the example above, the second appearance of \n/node2\n causes a new property to be added to the original:\n\n\n/node2 {\n    an-empty-property;\n    a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */\n    another-property-for-node2;\n    child-node1 {\n        my-cousin = <&cousin>;\n    };\n};\n\n\n\n\n\nIt is thus possible for one \n.dtsi\n to overwrite, or provide defaults for, multiple places in a tree.\n\n\n\n\n1.3: Labels and references\n\n\nIt is often necessary for one part of the tree to refer to another, and there are four ways to do this:\n\n\n\n\n\n\nPath strings\n\n\nPaths should be self-explanatory, by analogy with a filesystem - \n/soc/i2s@7e203000\n is the full path to the I2S device in BCM2835 and BCM2836. Note that although it is easy to construct a path to a property (for example, \n/soc/i2s@7e203000/status\n), the standard APIs don't do that; you first find a node, then choose properties of that node.\n\n\n\n\n\n\nphandles\n\n\n\n\n\n\nA phandle is a unique 32-bit integer assigned to a node in its \nphandle\n property. For historical reasons, you may also see a redundant, matching \nlinux,phandle\n. phandles are numbered sequentially, starting from 1; 0 is not a valid phandle. They are usually allocated by the DT compiler when it encounters a reference to a node in an integer context, usually in the form of a label (see below). References to nodes using phandles are simply encoded as the corresponding integer (cell) values; there is no markup to indicate that they should be interpreted as phandles, as that is application-defined.\n\n\n\n\nLabels\n\n\n\n\nJust as a label in C gives a name to a place in the code, a DT label assigns a name to a node in the hierarchy. The compiler takes references to labels and converts them into paths when used in string context (\n&node\n) and phandles in integer context (\n<&node>\n); the original labels do not appear in the compiled output. Note that labels contain no structure; they are just tokens in a flat, global namespace.\n\n\n\n\nAliases\n\n\n\n\nAliases are similar to labels, except that they do appear in the FDT output as a form of index. They are stored as properties of the \n/aliases\n node, with each property mapping an alias name to a path string. Although the aliases node appears in the source, the path strings usually appear as references to labels (\n&node\n), rather then being written out in full. DT APIs that resolve a path string to a node typically look at the first character of the path, treating paths that do not start with a slash as aliases that must first be converted to a path using the \n/aliases\n table.\n\n\n\n\n1.4: Device Tree semantics\n\n\nHow to construct a Device Tree, and how best to use it to capture the configuration of some hardware, is a large and complex subject. There are many resources available, some of which are listed below, but several points deserve mentioning in this document:\n\n\ncompatible\n properties are the link between the hardware description and the driver software. When an OS encounters a node with a \ncompatible\n property, it looks it up in its database of device drivers to find the best match. In Linux, this usually results in the driver module being automatically loaded, provided it has been appropriately labelled and not blacklisted.\n\n\nThe \nstatus\n property indicates whether a device is enabled or disabled. If the \nstatus\n is \nok\n, \nokay\n or absent, then the device is enabled. Otherwise, \nstatus\n should be \ndisabled\n, so that the device is disabled. It can be useful to place devices in a \n.dtsi\n file with the status set to \ndisabled\n. A derived configuration can then include that \n.dtsi\n and set the status for the devices which are needed to \nokay\n.\n\n\n\n\nPart 2: Device Tree overlays\n\n\nA modern SoC (System on a Chip) is a very complicated device; a complete Device Tree could be hundreds of lines long. Taking that one step further and placing the SoC on a board with other components only makes matters worse. To keep that manageable, particularly if there are related devices that share components, it makes sense to put the common elements in \n.dtsi\n files, to be included from possibly multiple \n.dts\n files.\n\n\nBut when a system like Raspberry Pi supports optional plug-in accessories, such as HATs, the problem grows. Ultimately, each possible configuration requires a Device Tree to describe it, but once you factor in different base hardware (models A, B, A+, and B+) and gadgets only requiring the use of a few GPIO pins that can coexist, the number of combinations starts to multiply rapidly.\n\n\nWhat is needed is a way to describe these optional components using a partial Device Tree, and then to be able to build a complete tree by taking a base DT and adding a number of optional elements. You can do this, and these optional elements are called \"overlays\".\n\n\n\n\n2.1: Fragments\n\n\nA DT overlay comprises a number of fragments, each of which targets one node and its subnodes. Although the concept sounds simple enough, the syntax seems rather strange at first:\n\n\n// Enable the i2s interface\n\n\n/\ndts\n-\nv1\n/\n;\n\n\n/\nplugin\n/\n;\n\n\n\n/\n \n{\n\n    \ncompatible\n \n=\n \n\"brcm,bcm2708\"\n;\n\n\n    \nfragment\n@0\n \n{\n\n        \ntarget\n \n=\n \n<&\ni2s\n>\n;\n\n        \n__overlay__\n \n{\n\n            \nstatus\n \n=\n \n\"okay\"\n;\n\n        \n};\n\n    \n};\n\n\n};\n\n\n\n\n\n\nThe \ncompatible\n string identifies this as being for BCM2708, which is the base architecture of the BCM2835 part. For the BCM2836 part you could use a compatible string of \"brcm,bcm2709\", but unless you are targeting features of the ARM CPUs, the two architectures should be equivalent, so sticking to \"brcm,bcm2708\" is reasonable. Then comes the first (and in this case only) fragment. Fragments are numbered sequentially from zero. Failure to adhere to this may cause some or all of your fragments to be missed.\n\n\nEach fragment consists of two parts: a \ntarget\n property, identifying the node to apply the overlay to; and the \n__overlay__\n itself, the body of which is added to the target node. The example above can be interpreted as if it were written like this:\n\n\n/dts-v1/;\n\n/ {\n    compatible = \"brcm,bcm2708\";\n};\n\n&i2s {\n    status = \"okay\";\n};\n\n\n\n\n\nThe effect of merging that overlay with a standard Raspberry Pi base Device Tree (e.g. \nbcm2708-rpi-b-plus.dtb\n), provided the overlay is loaded afterwards, would be to enable the I2S interface by changing its status to \nokay\n. But if you try to compile this overlay using:\n\n\ndtc -I dts -O dtb -o 2nd.dtbo 2nd-overlay.dts\n\n\n\n\n\nyou will get an error:\n\n\nLabel or path i2s not found\n\n\n\n\n\nThis shouldn't be too unexpected, since there is no reference to the base \n.dtb\n or \n.dts\n file to allow the compiler to find the \ni2s\n label.\n\n\nTrying again, this time using the original example and adding the \n-@\n option to allow unresolved references:\n\n\ndtc -@ -I dts -O dtb -o 1st.dtbo 1st-overlay.dts\n\n\n\n\n\nIf \ndtc\n returns an error about the third line, it doesn't have the extensions required for overlay work. Run \nsudo apt-get install device-tree-compiler\n and try again - this time, compilation should complete successfully. Note that a suitable compiler is also available in the kernel tree as \nscripts/dtc/dtc\n, built when the \ndtbs\n make target is used:\n\n\nmake ARCH=arm dtbs\n\n\n\n\n\nIt is interesting to dump the contents of the DTB file to see what the compiler has generated:\n\n\n$\n \nfdtdump\n \n1\nst\n.\ndtbo\n\n\n\n/\ndts\n-\nv1\n/\n;\n\n\n// magic:           0xd00dfeed\n\n\n// totalsize:       0x106 (262)\n\n\n// off_dt_struct:   0x38\n\n\n// off_dt_strings:  0xe8\n\n\n// off_mem_rsvmap:  0x28\n\n\n// version:         17\n\n\n// last_comp_version:    16\n\n\n// boot_cpuid_phys: 0x0\n\n\n// size_dt_strings: 0x1e\n\n\n// size_dt_struct:  0xb0\n\n\n\n/\n \n{\n\n    \ncompatible\n \n=\n \n\"brcm,bcm2708\"\n;\n\n    \nfragment\n@0\n \n{\n\n        \ntarget\n \n=\n \n<\n0xdeadbeef\n>\n;\n\n        \n__overlay__\n \n{\n\n            \nstatus\n \n=\n \n\"okay\"\n;\n\n        \n};\n\n    \n};\n\n    \n__fixups__\n \n{\n\n        \ni2s\n \n=\n \n\"/fragment@0:target:0\"\n;\n\n    \n};\n\n\n};\n\n\n\n\n\n\nAfter the verbose description of the file structure there is our fragment. But look carefully - where we wrote \n&i2s\n it now says \n0xdeadbeef\n, a clue that something strange has happened. After the fragment there is a new node, \n__fixups__\n. This contains a list of properties mapping the names of unresolved symbols to lists of paths to cells within the fragments that need patching with the phandle of the target node, once that target has been located. In this case, the path is to the \n0xdeadbeef\n value of \ntarget\n, but fragments can contain other unresolved references which would require additional fixes.\n\n\nIf you write more complicated fragments, the compiler may generate two more nodes: \n__local_fixups__\n and \n__symbols__\n. The former is required if any node in the fragments has a phandle, because the program performing the merge will have to ensure that phandle numbers are sequential and unique. However, the latter is the key to how unresolved symbols are dealt with.\n\n\nBack in section 1.3 it says that \"the original labels do not appear in the compiled output\", but this isn't true when using the \n-@\n switch. Instead, every label results in a property in the \n__symbols__\n node, mapping a label to a path, exactly like the \naliases\n node. In fact, the mechanism is so similar that when resolving symbols, the Raspberry Pi loader will search the \"aliases\" node in the absence of a \n__symbols__\n node. This is useful because by providing sufficient aliases, we can allow an older \ndtc\n to be used to build the base DTB files.\n\n\nUPDATE: The \nDynamic Device Tree\n support in the kernel requires a different format of \"local fixups\" in the overlay. To avoid problems with old and new styles of overlay coexisting, and to match other users of overlays, the old \"name-overlay.dtb\" naming scheme has been replaced with \"name.dtbo\" from 4.4 onwards. Overlays should be referred to by name alone, and the firmware or utility that loads them will append the appropriate suffix. For example:\n\n\ndtoverlay=awesome-overlay      # This is wrong\ndtoverlay=awesome              # This is correct\n\n\n\n\n\n\n\n2.2: Device Tree parameters\n\n\nTo avoid the need for lots of Device Tree overlays, and to reduce the need for users of peripherals to modify DTS files, the Raspberry Pi loader supports a new feature - Device Tree parameters. This permits small changes to the DT using named parameters, similar to the way kernel modules receive parameters from \nmodprobe\n and the kernel command line. Parameters can be exposed by the base DTBs and by overlays, including HAT overlays.\n\n\nParameters are defined in the DTS by adding an \n__overrides__\n node to the root. It contains properties whose names are the chosen parameter names, and whose values are a sequence comprising a phandle (reference to a label) for the target node, and a string indicating the target property; string, integer (cell) and boolean properties are supported.\n\n\n\n\n2.2.1: String parameters\n\n\nString parameters are declared like this:\n\n\nname = <&label>,\"property\";\n\n\n\n\n\nwhere \nlabel\n and \nproperty\n are replaced by suitable values. String parameters can cause their target properties to grow, shrink, or be created.\n\n\nNote that properties called \nstatus\n are treated specially; non-zero/true/yes/on values are converted to the string \n\"okay\"\n, while zero/false/no/off becomes \n\"disabled\"\n.\n\n\n\n\n2.2.2: Integer parameters\n\n\nInteger parameters are declared like this:\n\n\nname\n \n=\n \n<&\nlabel\n>,\n\"property.offset\"\n;\n \n//\n \n8-bit\n\n\nname\n \n=\n \n<&\nlabel\n>,\n\"property;offset\"\n;\n \n//\n \n16-bit\n\n\nname\n \n=\n \n<&\nlabel\n>,\n\"property:offset\"\n;\n \n//\n \n32-bit\n\n\nname\n \n=\n \n<&\nlabel\n>,\n\"property#offset\"\n;\n \n//\n \n64-bit\n\n\n\n\n\n\nwhere \nlabel\n, \nproperty\n and \noffset\n are replaced by suitable values; the offset is specified in bytes relative to the start of the property (in decimal by default), and the preceding separator dictates the size of the parameter. In a change from earlier implementations, integer parameters may refer to non-existent properties or to offsets beyond the end of an existing property.\n\n\n\n\n2.2.3: Boolean parameters\n\n\nDevice Tree encodes boolean values as zero-length properties; if present then the property is true, otherwise it is false. They are defined like this:\n\n\nboolean_property; // Set 'boolean_property' to true\n\n\n\n\n\nNote that a property is assigned the value \nfalse\n by not defining it. Boolean parameters are declared like this:\n\n\nname = <&label>,\"property?\";\n\n\n\n\n\nwhere \nlabel\n and \nproperty\n are replaced by suitable values. Boolean parameters can cause properties to be created or deleted.\n\n\n\n\n2.2.4 Overlay/fragment parameters\n\n\nThe DT parameter mechanism as described has a number of limitations, including the inability to change the name of a node and to write arbitrary values to arbitrary properties when a parameter is used. One way to overcome some of these limitations is to conditionally include or exclude certain fragments.\n\n\nA fragment can be excluded from the final merge process (disabled) by renaming the \n__overlay__\n node to \n__dormant__\n. The parameter declaration syntax has been extended to allow the otherwise illegal zero target phandle to indicate that the following string contains operations at fragment or overlay scope. So far, four operations have been implemented:\n\n\n+<n>    // Enable fragment <n>\n-<n>    // Disable fragment <n>\n=<n>    // Enable fragment <n> if the assigned parameter value is true, otherwise disable it\n!<n>    // Enable fragment <n> if the assigned parameter value is false, otherwise disable it\n\n\n\n\n\nExamples:\n\n\njust_one    = <0>,\"+1-2\"; // Enable 1, disable 2\nconditional = <0>,\"=3!4\"; // Enable 3, disable 4 if value is true,\n                          // otherwise disable 3, enable 4.\n\n\n\n\n\nThe i2c-mux overlay uses this technique.\n\n\n\n\n2.2.5 Examples\n\n\nHere are some examples of different types of properties, with parameters to modify them:\n\n\n/\n \n{\n\n    \nfragment\n@0\n \n{\n\n        \ntarget\n-\npath\n \n=\n \n\"/\"\n;\n\n        \n__overlay__\n \n{\n\n\n            \ntest\n:\n \ntest_node\n \n{\n\n                \nstring\n \n=\n \n\"hello\"\n;\n\n                \nstatus\n \n=\n \n\"disabled\"\n;\n\n                \nbytes\n \n=\n \n/\nbits\n/\n \n8\n \n<\n0x67\n \n0x89\n>\n;\n\n                \nu16s\n \n=\n \n/\nbits\n/\n \n16\n \n<\n0xabcd\n \n0xef01\n>\n;\n\n                \nu32s\n \n=\n \n/\nbits\n/\n \n32\n \n<\n0xfedcba98\n \n0x76543210\n>\n;\n\n                \nu64s\n \n=\n \n/\nbits\n/\n \n64\n \n<\n \n0xaaaaa5a55a5a5555\n \n0x0000111122223333\n>\n;\n\n                \nbool1\n;\n \n// Defaults to true\n\n                       \n// bool2 defaults to false\n\n            \n};\n\n        \n};\n\n    \n};\n\n\n    \nfragment\n@1\n \n{\n\n        \ntarget\n-\npath\n \n=\n \n\"/\"\n;\n\n        \n__overlay__\n \n{\n\n            \nfrag1\n;\n\n        \n};\n\n    \n};\n\n\n    \nfragment\n@2\n \n{\n\n        \ntarget\n-\npath\n \n=\n \n\"/\"\n;\n\n        \n__dormant__\n \n{\n\n            \nfrag2\n;\n\n        \n};\n\n    \n};\n\n\n    \n__overrides__\n \n{\n\n        \nstring\n \n=\n      \n<&\ntest\n>\n,\n\"string\"\n;\n\n        \nenable\n \n=\n      \n<&\ntest\n>\n,\n\"status\"\n;\n\n        \nbyte_0\n \n=\n      \n<&\ntest\n>\n,\n\"bytes.0\"\n;\n\n        \nbyte_1\n \n=\n      \n<&\ntest\n>\n,\n\"bytes.1\"\n;\n\n        \nu16_0\n \n=\n       \n<&\ntest\n>\n,\n\"u16s;0\"\n;\n\n        \nu16_1\n \n=\n       \n<&\ntest\n>\n,\n\"u16s;2\"\n;\n\n        \nu32_0\n \n=\n       \n<&\ntest\n>\n,\n\"u32s:0\"\n;\n\n        \nu32_1\n \n=\n       \n<&\ntest\n>\n,\n\"u32s:4\"\n;\n\n        \nu64_0\n \n=\n       \n<&\ntest\n>\n,\n\"u64s#0\"\n;\n\n        \nu64_1\n \n=\n       \n<&\ntest\n>\n,\n\"u64s#8\"\n;\n\n        \nbool1\n \n=\n       \n<&\ntest\n>\n,\n\"bool1?\"\n;\n\n        \nbool2\n \n=\n       \n<&\ntest\n>\n,\n\"bool2?\"\n;\n\n        \nonly1\n \n=\n       \n<\n0\n>\n,\n\"+1-2\"\n;\n\n        \nonly2\n \n=\n       \n<\n0\n>\n,\n\"-1+2\"\n;\n\n        \ntoggle1\n \n=\n     \n<\n0\n>\n,\n\"=1\"\n;\n\n        \ntoggle2\n \n=\n     \n<\n0\n>\n,\n\"=2\"\n;\n\n        \nnot1\n \n=\n        \n<\n0\n>\n,\n\"!1\"\n;\n\n        \nnot2\n \n=\n        \n<\n0\n>\n,\n\"!2\"\n;\n\n    \n};\n\n\n};\n\n\n\n\n\n\n\n\n2.2.6: Parameters with multiple targets\n\n\nThere are some situations where it is convenient to be able to set the same value in multiple locations within the Device Tree. Rather than the ungainly approach of creating multiple parameters, it is possible to add multiple targets to a single parameter by concatenating them, like this:\n\n\n    \n__overrides__\n \n{\n\n        \ngpiopin\n \n=\n \n<&w1>,\"\ngpios\n:\n4\n\",\n\n\n                  <&w1_pins>,\"\nbrcm\n,\npins\n:\n0\n\"\n;\n\n        \n...\n\n    \n}\n;\n\n\n\n\n\n\n(example taken from the \nw1-gpio\n overlay)\n\n\nNote that it is even possible to target properties of different types with a single parameter. You could reasonably connect an \"enable\" parameter to a \nstatus\n string, cells containing zero or one, and a proper boolean property.\n\n\n\n\n2.2.7: Further overlay examples\n\n\nThere is a growing collection of overlay source files hosted in the Raspberry Pi/Linux GitHub repository \nhere\n.\n\n\n\n\nPart 3: Using Device Trees on Raspberry Pi\n\n\n\n\n3.1: Overlays and config.txt\n\n\nOn a Raspberry Pi it is the job of the loader (one of the \nstart.elf\n images) to combine overlays with an appropriate base device tree, and then to pass a fully resolved Device Tree to the kernel. The base Device Trees are located alongside \nstart.elf\n in the FAT partition (/boot from Linux), named \nbcm2708-rpi-b.dtb\n, \nbcm2708-rpi-b-plus.dtb\n, \nbcm2708-rpi-cm.dtb\n, and \nbcm2709-rpi-2-b.dtb\n. Note that Models A and A+ will use the \"b\" and \"b-plus\" variants, respectively. This selection is automatic, and allows the same SD card image to be used in a variety of devices.\n\n\nNote that DT and ATAGs are mutually exclusive. As a result, passing a DT blob to a kernel that doesn't understand it causes a boot failure. To guard against this, the loader checks kernel images for DT-compatibility, which is marked by a trailer added by the \nmkknlimg\n utility; this can be found in the \nscripts\n directory of a recent kernel source tree. Any kernel without a trailer is assumed to be non-DT-capable.\n\n\nA kernel built from the rpi-4.4.y tree (and later) will not function without a DTB, so from the 4.4 releases onwards, any kernel without a trailer is assumed to be DT-capable. You can override this by adding a trailer without the DTOK flag or by putting \ndevice_tree=\n in config.txt, but don't be surprised if it doesn't work.\nN.B. A corollary to this is that if the kernel has a trailer indicating DT capability then \ndevice_tree=\n will be ignored.\n\n\nThe loader now supports builds using bcm2835_defconfig, which selects the upstreamed BCM2835 support. This configuration will cause \nbcm2835-rpi-b.dtb\n and \nbcm2835-rpi-b-plus.dtb\n to be built. If these files are copied with the kernel, and if the kernel has been tagged by a recent \nmkknlimg\n, then the loader will attempt to load one of those DTBs by default.\n\n\nIn order to manage Device Tree and overlays, the loader supports a number of new \nconfig.txt\n directives:\n\n\ndtoverlay=acme-board\ndtparam=foo=bar,level=42\n\n\n\n\n\nThis will cause the loader to look for \noverlays/acme-board.dtbo\n in the firmware partition, which Raspbian mounts on \n/boot\n. It will then search for parameters \nfoo\n and \nlevel\n, and assign the indicated values to them.\n\n\nThe loader will also search for an attached HAT with a programmed EEPROM, and load the supporting overlay from there; this happens without any user intervention.\n\n\nThere are several ways to tell that the kernel is using Device Tree:\n\n\n\n\nThe \"Machine model:\" kernel message during bootup has a board-specific value such as \"Raspberry Pi 2 Model B\", rather than \"BCM2709\".\n\n\nSome time later, there may also be another kernel message saying \"No ATAGs?\" - this is expected.\n\n\n/proc/device-tree\n exists, and contains subdirectories and files that exactly mirror the nodes and properties of the DT.\n\n\n\n\nWith a Device Tree, the kernel will automatically search for and load modules that support the indicated enabled devices. As a result, by creating an appropriate DT overlay for a device you save users of the device from having to edit \n/etc/modules\n; all of the configuration goes in \nconfig.txt\n, and in the case of a HAT, even that step is unnecessary. Note, however, that layered modules such as \ni2c-dev\n still need to be loaded explicitly.\n\n\nThe flipside is that because platform devices don't get created unless requested by the DTB, it should no longer be necessary to blacklist modules that used to be loaded as a result of platform devices defined in the board support code. In fact, current Raspbian images ship without a blacklist file.\n\n\n\n\n3.2: DT parameters\n\n\nAs described above, DT parameters are a convenient way to make small changes to a device's configuration. The current base DTBs support parameters for enabling and controlling the onboard audio, I2C, I2S and SPI interfaces without using dedicated overlays. In use, parameters look like this:\n\n\ndtparam=audio=on,i2c_arm=on,i2c_arm_baudrate=400000,spi=on\n\n\n\n\n\nNote that multiple assignments can be placed on the same line, but ensure you don't exceed the 80-character limit.\n\n\nA future default \nconfig.txt\n may contain a section like this:\n\n\n# Uncomment some or all of these to enable the optional hardware interfaces\n#dtparam=i2c_arm=on\n#dtparam=i2s=on\n#dtparam=spi=on\n\n\n\n\n\nIf you have an overlay that defines some parameters, they can be specified either on subsequent lines like this:\n\n\ndtoverlay=lirc-rpi\ndtparam=gpio_out_pin=16\ndtparam=gpio_in_pin=17\ndtparam=gpio_in_pull=down\n\n\n\n\n\nor appended to the overlay line like this:\n\n\ndtoverlay=lirc-rpi:gpio_out_pin=16,gpio_in_pin=17,gpio_in_pull=down\n\n\n\n\n\nNote here the use of a colon (\n:\n) to separate the overlay name from its parameters, which is a supported syntax variant.\n\n\nOverlay parameters are only in scope until the next overlay is loaded. In the event of a parameter with the same name being exported by both the overlay and the base, the parameter in the overlay takes precedence; for clarity, it's recommended that you avoid doing this. To expose the parameter exported by the base DTB instead, end the current overlay scope using:\n\n\ndtoverlay=\n\n\n\n\n\n\n\n3.3: Board-specific labels and parameters\n\n\nRaspberry Pi boards have two I2C interfaces. These are nominally split: one for the ARM, and one for VideoCore (the \"GPU\"). On almost all models, \ni2c1\n belongs to the ARM and \ni2c0\n to VC, where it is used to control the camera and read the HAT EEPROM. However, there are two early revisions of the Model B that have those roles reversed.\n\n\nTo make it possible to use one set of overlays and parameters with all Pis, the firmware creates some board-specific DT parameters. These are:\n\n\ni2c/i2c_arm\ni2c_vc\ni2c_baudrate/i2c_arm_baudrate\ni2c_vc_baudrate\n\n\n\n\n\nThese are aliases for \ni2c0\n, \ni2c1\n, \ni2c0_baudrate\n, and \ni2c1_baudrate\n. It is recommended that you only use \ni2c_vc\n and \ni2c_vc_baudrate\n if you really need to - for example, if you are programming a HAT EEPROM. Enabling \ni2c_vc\n can stop the Pi Camera being detected.\n\n\nFor people writing overlays, the same aliasing has been applied to the labels on the I2C DT nodes. Thus, you should write:\n\n\nfragment\n@0\n \n{\n\n    \ntarget\n \n=\n \n<&\ni2c_arm\n>\n;\n\n    \n__overlay__\n \n{\n\n        \nstatus\n \n=\n \n\"okay\"\n;\n\n    \n};\n\n\n};\n\n\n\n\n\n\nAny overlays using the numeric variants will be modified to use the new aliases.\n\n\n\n\n3.4: HATs and Device Tree\n\n\nA Raspberry Pi HAT is an add-on board for a \"Plus\"-shaped (A+, B+ or Pi 2 B) Raspberry Pi with an embedded EEPROM. The EEPROM includes any DT overlay required to enable the board, and this overlay can also expose parameters.\n\n\nThe HAT overlay is automatically loaded by the firmware after the base DTB, so its parameters are accessible until any other overlays are loaded, or until the overlay scope is ended using \ndtoverlay=\n. If for some reason you want to suppress the loading of the HAT overlay, put \ndtoverlay=\n before any other \ndtoverlay\n or \ndtparam\n directive.\n\n\n\n\n3.5: Dynamic Device Tree\n\n\nAs of Linux 4.4, the RPi kernels support the dynamic loading of overlays and parameters. Compatible kernels manage a stack of overlays that are applied on top of the base DTB. Changes are immediately reflected in \n/proc/device-tree\n and can cause modules to be loaded and platform devices to be created and destroyed.\n\n\nThe use of the word \"stack\" above is important - overlays can only be added and removed at the top of the stack; changing something further down the stack requires that anything on top of it must first be removed.\n\n\nThere are some new commands for managing overlays:\n\n\n\n\n3.5.1 The dtoverlay command\n\n\ndtoverlay\n is a command line utility that loads and removes overlays while the system is running, as well as listing the available overlays and displaying their help information:\n\n\npi@raspberrypi ~ $ dtoverlay -h\nUsage:\n  dtoverlay <overlay> [<param>=<val>...]\n                           Add an overlay (with parameters)\n  dtoverlay -r [<overlay>] Remove an overlay (by name, index or the last)\n  dtoverlay -R [<overlay>] Remove from an overlay (by name, index or all)\n  dtoverlay -l             List active overlays/params\n  dtoverlay -a             List all overlays (marking the active)\n  dtoverlay -h             Show this usage message\n  dtoverlay -h <overlay>   Display help on an overlay\n  dtoverlay -h <overlay> <param>..  Or its parameters\n    where <overlay> is the name of an overlay or 'dtparam' for dtparams\nOptions applicable to most variants:\n    -d <dir>    Specify an alternate location for the overlays\n                (defaults to /boot/overlays or /flash/overlays)\n    -n          Dry run - show what would be executed\n    -v          Verbose operation\n\n\n\n\n\nUnlike the \nconfig.txt\n equivalent, all parameters to an overlay must be included in the same command line - the \ndtparam\n command is only for parameters of the base DTB.\n\n\nTwo points to note:\n1. Command variants that change kernel state (adding and removing things) require root privilege, so you may need to prefix the command with \nsudo\n.\n\n\n\n\nOnly overlays and parameters applied at run-time can be unloaded - an overlay or parameter applied by the firmware becomes \"baked in\" such that it won't be listed by \ndtoverlay\n and can't be removed.\n\n\n\n\n\n\n3.5.2 The dtparam command\n\n\ndtparam\n creates an overlay that has the same effect as using a dtparam directive in \nconfig.txt\n. In usage it is largely equivalent to \ndtoverlay\n with an overlay name of \n-\n, but there are a few small differences:\n\n\n\n\n\n\ndtparam\n will list the help information for all known parameters of the base DTB. Help on the dtparam command is still available using \ndtparam -h\n.\n\n\n\n\n\n\nWhen indicating a parameter for removal, only index numbers can be used (not names).\n\n\n\n\n\n\n\n\n3.5.3 Guidelines for writing runtime-capable overlays\n\n\nThis area is poorly documented, but here are some accumulated tips:\n\n\n\n\n\n\nThe creation or deletion of a device object is triggered by a node being added or removed, or by the status of a node changing from disabled to enabled or vice versa. Beware - the absence of a \"status\" property means the node is enabled.\n\n\n\n\n\n\nDon't create a node within a fragment that will overwrite an existing node in the base DTB - the kernel will rename the new node to make it unique. If you want to change the properties of an existing node, create a fragment that targets it.\n\n\n\n\n\n\nALSA doesn't prevent its codecs and other components from being unloaded while they are in use. Removing an overlay can cause a kernel exception if it deletes a codec that is still being used by a sound card. Experimentation found that devices are deleted in the reverse of fragment order in the overlay, so placing the node for the card after the nodes for the components allows an orderly shutdown.\n\n\n\n\n\n\n\n\n3.5.4 Caveats\n\n\nThe loading of overlays at runtime is a recent addition to the kernel, and so far there is no accepted way to do this from userspace. By hiding the details of this mechanism behind commands the aim is to insulate users from changes in the event that a different kernel interface becomes standardised.\n\n\n\n\n\n\nSome overlays work better at run-time than others. Parts of the Device Tree are only used at boot time - changing them using an overlay will not have any effect.\n\n\n\n\n\n\nApplying or removing some overlays may cause unexpected behaviour, so it should be done with caution. This is one of the reasons it requires \nsudo\n.\n\n\n\n\n\n\nUnloading the overlay for an ALSA card can stall if something is actively using ALSA - the LXPanel volume slider plugin demonstrates this effect. To enable overlays for sound cards to be removed, the \nlxpanelctl\n utility has been given two new options - \nalsastop\n and \nalsastart\n - and these are called from the auxiliary scripts \ndtoverlay-pre\n and \ndtoverlay-post\n before and after overlays are loaded or unloaded, respectively.\n\n\n\n\n\n\nRemoving an overlay will not cause a loaded module to be unloaded, but it may cause the reference count of some modules to drop to zero. Running \nrmmod -a\n twice will cause unused modules to be unloaded.\n\n\n\n\n\n\nOverlays have to be removed in reverse order. The commands will allow you to remove an earlier one, but all the intermediate ones will be removed and re-applied, which may have unintended consequences.\n\n\n\n\n\n\nAdding clocks under the \n/clocks\n node at run-time doesn't cause a new clock provider to be registered, so \ndevm_clk_get\n will fail for a clock created in an overlay.\n\n\n\n\n\n\n\n\n3.6: Supported overlays and parameters\n\n\nAs it is too time-consuming to document the individual overlays here, please refer to the \nREADME\n file found alongside the overlay \n.dtbo\n files in \n/boot/overlays\n. It is kept up-to-date with additions and changes.\n\n\n\n\nPart 4: Troubleshooting and pro tips\n\n\n\n\n4.1: Debugging\n\n\nThe loader will skip over missing overlays and bad parameters, but if there are serious errors, such as a missing or corrupt base DTB or a failed overlay merge, then the loader will fall back to a non-DT boot. If this happens, or if your settings don't behave as you expect, it is worth checking for warnings or errors from the loader:\n\n\nsudo vcdbg log msg\n\n\n\n\n\nExtra debugging can be enabled by adding \ndtdebug=1\n to \nconfig.txt\n.\n\n\nIf the kernel fails to come up in DT mode, \nthis is probably because the kernel image does not have a valid trailer\n. Use \nknlinfo\n to check for one, and the \nmkknlimg\n utility to add one. Both utilities are included in the \nscripts\n directory of current Raspberry Pi kernel source trees.\n\n\nYou can create a human-readable representation of the current state of DT like this:\n\n\ndtc -I fs /proc/device-tree\n\n\n\n\n\nThis can be useful to see the effect of merging overlays onto the underlying tree.\n\n\nIf kernel modules don't load as expected, check that they aren't blacklisted in \n/etc/modprobe.d/raspi-blacklist.conf\n; blacklisting shouldn't be necessary when using Device Tree. If that shows nothing untoward, you can also check that the module is exporting the correct aliases by searching \n/lib/modules/<version>/modules.alias\n for the \ncompatible\n value. Otherwise, your driver is probably missing either:\n\n\n.of_match_table\n \n=\n \nxxx_of_match\n,\n\n\n\n\n\n\nor:\n\n\nMODULE_DEVICE_TABLE(of, xxx_of_match);\n\n\n\n\n\nFailing that, \ndepmod\n has failed or the updated modules haven't been installed on the target filesystem.\n\n\n\n\n4.2: Testing overlays using dtmerge and dtdiff\n\n\nAlongside the \ndtoverlay\n and \ndtparam\n commands is a utility for applying an overlay to a DTB - \ndtmerge\n. To use it you first need to obtain your base DTB, which can be obtained in one of two ways:\n\n\na) generate it from the live DT state in \n/proc/device-tree\n:\n\n\ndtc -I fs -O dtb -o base.dtb /proc/device-tree\n\n\n\n\n\nThis will include any overlays and parameters you have applied so far, either in \nconfig.txt\n or by loading them at runtime, which may or may not be what you want. Alternatively...\n\n\nb) copy it from the source DTBs in /boot. This won't include overlays and parameters, but it also won't include any other modifications by the firmware. To allow testing of all overlays, the \ndtmerge\n utility will create some of the board-specific aliases (\"i2c_arm\", etc.), but this means that the result of a merge will include more differences from the original DTB than you might expect. The solution to this is to use dtmerge to make the copy:\n\n\ndtmerge /boot/bcm2710-rpi-3-b.dtb base.dtb -\n\n\n\n\n\n(the \n-\n indicates an absent overlay name).\n\n\nYou can now try applying an overlay or parameter:\n\n\ndtmerge base.dtb merged.dtb - sd_overclock=62\ndtdiff base.dtb merged.dtb\n\n\n\n\n\nwhich will return:\n\n\n--- /dev/fd/63  2016-05-16 14:48:26.396024813 +0100\n\n\n+++ /dev/fd/62  2016-05-16 14:48:26.396024813 +0100\n\n\n@@ -594,7 +594,7 @@\n\n                };\n\n                sdhost@7e202000 {\n\n-                       brcm,overclock-50 = <0x0>;\n\n\n+                       brcm,overclock-50 = <0x3e>;\n\n                        brcm,pio-limit = <0x1>;\n                        bus-width = <0x4>;\n                        clocks = <0x8>;\n\n\n\n\n\nYou can also compare different overlays or parameters.\n\n\ndtmerge base.dtb merged1.dtb /boot/overlays/spi1-1cs.dtbo\ndtmerge base.dtb merged2.dtb /boot/overlays/spi1-2cs.dtbo\ndtdiff merged1.dtb merged2.dtb\n\n\n\n\n\nto get:\n\n\n--- /dev/fd/63  2016-05-16 14:18:56.189634286 +0100\n\n\n+++ /dev/fd/62  2016-05-16 14:18:56.189634286 +0100\n\n\n@@ -453,7 +453,7 @@\n\n\n                        spi1_cs_pins {\n                                brcm,function = <0x1>;\n\n-                               brcm,pins = <0x12>;\n\n\n+                               brcm,pins = <0x12 0x11>;\n\n                                phandle = <0x3e>;\n                        };\n\n\n@@ -725,7 +725,7 @@\n\n                        #size-cells = <0x0>;\n                        clocks = <0x13 0x1>;\n                        compatible = \"brcm,bcm2835-aux-spi\";\n\n-                       cs-gpios = <0xc 0x12 0x1>;\n\n\n+                       cs-gpios = <0xc 0x12 0x1 0xc 0x11 0x1>;\n\n                        interrupts = <0x1 0x1d>;\n                        linux,phandle = <0x30>;\n                        phandle = <0x30>;\n\n@@ -743,6 +743,16 @@\n\n                                spi-max-frequency = <0x7a120>;\n                                status = \"okay\";\n                        };\n\n+\n\n\n+                       spidev@1 {\n\n\n+                               #address-cells = <0x1>;\n\n\n+                               #size-cells = <0x0>;\n\n\n+                               compatible = \"spidev\";\n\n\n+                               phandle = <0x41>;\n\n\n+                               reg = <0x1>;\n\n\n+                               spi-max-frequency = <0x7a120>;\n\n\n+                               status = \"okay\";\n\n\n+                       };\n\n                };\n\n                spi@7e2150C0 {\n\n\n\n\n\n\n\n4.3: Forcing a specific Device Tree\n\n\nIf you have very specific needs that aren't supported by the default DTBs (in particular, people experimenting with the pure-DT approach used by the ARCH_BCM2835 project), or if you just want to experiment with writing your own DTs, you can tell the loader to load an alternate DTB file like this:\n\n\ndevice_tree=my-pi.dtb\n\n\n\n\n\n\n\n4.4: Disabling Device Tree usage\n\n\nSince the switch to the 4.4 kernel and the use of more upstream drivers, Device Tree usage is required in Pi kernels. The method of disabling DT usage is to add:\n\n\ndevice_tree=\n\n\n\n\n\nto \nconfig.txt\n. However, if the kernel has a \nmkknlimg\n trailer indicating DT capability then this directive will be ignored.\n\n\n\n\n4.5: Shortcuts and syntax variants\n\n\nThe loader understands a few shortcuts:\n\n\ndtparam=i2c_arm=on\ndtparam=i2s=on\n\n\n\n\n\ncan be shortened to:\n\n\ndtparam=i2c,i2s\n\n\n\n\n\n(\ni2c\n is an alias of \ni2c_arm\n, and the \n=on\n is assumed). It also still accepts the long-form versions: \ndevice_tree_overlay\n and \ndevice_tree_param\n.\n\n\nThe loader used to accept the use of whitespace and colons as separators, but support for these has been discontinued for simplicity and so they can be used within parameter values without quotes.\n\n\n\n\n4.6: Other DT commands available in config.txt\n\n\ndevice_tree_address\n\nThis is used to override the address where the firmware loads the device tree (not dt-blob). By default the firmware will choose a suitable place.\n\n\ndevice_tree_end\n\nThis sets an (exclusive) limit to the loaded device tree. By default the device tree can grow to the end of usable memory, which is almost certainly what is required.\n\n\ndtdebug\n\nIf non-zero, turn on some extra logging for the firmware's device tree processing.\n\n\nenable_uart\n\nEnable the primary/console UART (ttyS0 on a Pi 3, ttyAMA0 otherwise - unless swapped with an overlay such as pi3-miniuart-bt). If the primary UART is ttyAMA0 then enable_uart defaults to 1 (enabled), otherwise it defaults to 0 (disabled). This is because it is necessary to stop the core frequency from changing which would make ttyS0 unusable, so \nenable_uart=1\n implies core_freq=250 (unless force_turbo=1). In some cases this is a performance hit, so it is off by default. More details on UARTs can be found \nhere\n\n\noverlay_prefix\n\nSpecifies a subdirectory/prefix from which to load overlays - defaults to \"overlays/\". Note the trailing \"/\". If desired you can add something after the final \"/\" to add a prefix to each file, although this is not likely to be needed.\n\n\nFurther ports can be controlled by the DT, for more details see \nsection 3\n.",
            "title": "Device Trees, overlays, and parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#device-trees-overlays-and-parameters",
            "text": "Raspberry Pi's latest kernels and firmware, including Raspbian and NOOBS releases, now use a Device Tree (DT) to manage some resource allocation and module loading by default. This was implemented to alleviate the problem of multiple drivers contending for system resources, and to allow HAT modules to be auto-configured.  The current implementation is not a pure Device Tree system \u2013 there is still board support code that creates some platform devices \u2013 but the external interfaces (I2C, I2S, SPI), and the audio devices that use them, must now be instantiated using a Device Tree Blob (DTB) passed to the kernel by the loader ( start.elf ).  The main impact of using Device Tree is to change from  everything on , relying on module blacklisting to manage contention, to  everything off unless requested by the DTB . In order to continue to use external interfaces and the peripherals that attach to them, you will need to add some new settings to your  config.txt . Full details are given in  Part 3 , but these are a few examples:  # Uncomment some or all of these lines to enable the optional hardware interfaces\n#dtparam=i2c_arm=on\n#dtparam=i2s=on\n#dtparam=spi=on\n\n# Uncomment one of these lines to enable an audio interface\n#dtoverlay=hifiberry-amp\n#dtoverlay=hifiberry-dac\n#dtoverlay=hifiberry-dacplus\n#dtoverlay=hifiberry-digi\n#dtoverlay=iqaudio-dac\n#dtoverlay=iqaudio-dacplus\n#dtoverlay=audioinjector-wm8731-audio\n\n# Uncomment this to enable the lirc-rpi module\n#dtoverlay=lirc-rpi\n\n# Uncomment this to override the defaults for the lirc-rpi module\n#dtparam=gpio_out_pin=16\n#dtparam=gpio_in_pin=17\n#dtparam=gpio_in_pull=down",
            "title": "Device Trees, overlays, and parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#device-trees",
            "text": "A Device Tree (DT) is a description of the hardware in a system. It should include the name of the base CPU, its memory configuration, and any peripherals (internal and external). A DT should not be used to describe the software, although by listing the hardware modules it does usually cause driver modules to be loaded. It helps to remember that DTs are supposed to be OS-neutral, so anything which is Linux-specific probably shouldn't be there.  A Device Tree represents the hardware configuration as a hierarchy of nodes. Each node may contain properties and subnodes. Properties are named arrays of bytes, which may contain strings, numbers (big-endian), arbitrary sequences of bytes, and any combination thereof. By analogy to a filesystem, nodes are directories and properties are files. The locations of nodes and properties within the tree can be described using a path, with slashes as separators and a single slash ( / ) to indicate the root.",
            "title": "Device Trees"
        },
        {
            "location": "/configuration/device-tree/index.html#11-basic-dts-syntax",
            "text": "Device Trees are usually written in a textual form known as Device Tree Source (DTS) and stored in files with a  .dts  suffix. DTS syntax is C-like, with braces for grouping and semicolons at the end of each line. Note that DTS requires semicolons after closing braces: think of C  struct s rather than functions. The compiled binary format is referred to as Flattened Device Tree (FDT) or Device Tree Blob (DTB), and is stored in  .dtb  files.  The following is a simple tree in the  .dts  format:  /dts-v1/;\n/include/ \"common.dtsi\";\n\n/ {\n    node1 {\n        a-string-property = \"A string\";\n        a-string-list-property = \"first string\", \"second string\";\n        a-byte-data-property = [0x01 0x23 0x34 0x56];\n        cousin: child-node1 {\n            first-child-property;\n            second-child-property = <1>;\n            a-string-property = \"Hello, world\";\n        };\n        child-node2 {\n        };\n    };\n    node2 {\n        an-empty-property;\n        a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */\n        child-node1 {\n            my-cousin = <&cousin>;\n        };\n    };\n};\n\n/node2 {\n    another-property-for-node2;\n};  This tree contains:   a required header:  /dts-v1/ .  The inclusion of another DTS file, conventionally named  *.dtsi  and analogous to a  .h  header file in C - see  An aside about /include/  below.  a single root node:  /  a couple of child nodes:  node1  and  node2  some children for node1:  child-node1  and  child-node2  a label ( cousin ) and a reference to that label ( &cousin ): see  Labels and References  below.  several properties scattered through the tree  a repeated node ( /node2 ) - see  An aside about /include/  below.   Properties are simple key-value pairs where the value can either be empty or contain an arbitrary byte stream. While data types are not encoded in the data structure, there are a few fundamental data representations that can be expressed in a Device Tree source file.  Text strings (NUL-terminated) are indicated with double quotes:  string-property = \"a string\";  Cells are 32-bit unsigned integers delimited by angle brackets:  cell-property = <0xbeef 123 0xabcd1234>;  Arbitrary byte data is delimited with square brackets, and entered in hex:  binary-property = [01 23 45 67 89 ab cd ef];  Data of differing representations can be concatenated using a comma:  mixed-property = \"a string\", [01 23 45 67], <0x12345678>;  Commas are also used to create lists of strings:  string-list = \"red fish\", \"blue fish\";",
            "title": "1.1: Basic DTS syntax"
        },
        {
            "location": "/configuration/device-tree/index.html#12-an-aside-about-include",
            "text": "The  /include/  directive results in simple textual inclusion, much like C's  #include  directive, but a feature of the Device Tree compiler leads to different usage patterns. Given that nodes are named, potentially with absolute paths, it is possible for the same node to appear twice in a DTS file (and its inclusions). When this happens, the nodes and properties are combined, interleaving and overwriting properties as required (later values override earlier ones).  In the example above, the second appearance of  /node2  causes a new property to be added to the original:  /node2 {\n    an-empty-property;\n    a-cell-property = <1 2 3 4>; /* each number (cell) is a uint32 */\n    another-property-for-node2;\n    child-node1 {\n        my-cousin = <&cousin>;\n    };\n};  It is thus possible for one  .dtsi  to overwrite, or provide defaults for, multiple places in a tree.",
            "title": "1.2: An aside about /include/"
        },
        {
            "location": "/configuration/device-tree/index.html#13-labels-and-references",
            "text": "It is often necessary for one part of the tree to refer to another, and there are four ways to do this:    Path strings  Paths should be self-explanatory, by analogy with a filesystem -  /soc/i2s@7e203000  is the full path to the I2S device in BCM2835 and BCM2836. Note that although it is easy to construct a path to a property (for example,  /soc/i2s@7e203000/status ), the standard APIs don't do that; you first find a node, then choose properties of that node.    phandles    A phandle is a unique 32-bit integer assigned to a node in its  phandle  property. For historical reasons, you may also see a redundant, matching  linux,phandle . phandles are numbered sequentially, starting from 1; 0 is not a valid phandle. They are usually allocated by the DT compiler when it encounters a reference to a node in an integer context, usually in the form of a label (see below). References to nodes using phandles are simply encoded as the corresponding integer (cell) values; there is no markup to indicate that they should be interpreted as phandles, as that is application-defined.   Labels   Just as a label in C gives a name to a place in the code, a DT label assigns a name to a node in the hierarchy. The compiler takes references to labels and converts them into paths when used in string context ( &node ) and phandles in integer context ( <&node> ); the original labels do not appear in the compiled output. Note that labels contain no structure; they are just tokens in a flat, global namespace.   Aliases   Aliases are similar to labels, except that they do appear in the FDT output as a form of index. They are stored as properties of the  /aliases  node, with each property mapping an alias name to a path string. Although the aliases node appears in the source, the path strings usually appear as references to labels ( &node ), rather then being written out in full. DT APIs that resolve a path string to a node typically look at the first character of the path, treating paths that do not start with a slash as aliases that must first be converted to a path using the  /aliases  table.",
            "title": "1.3: Labels and references"
        },
        {
            "location": "/configuration/device-tree/index.html#14-device-tree-semantics",
            "text": "How to construct a Device Tree, and how best to use it to capture the configuration of some hardware, is a large and complex subject. There are many resources available, some of which are listed below, but several points deserve mentioning in this document:  compatible  properties are the link between the hardware description and the driver software. When an OS encounters a node with a  compatible  property, it looks it up in its database of device drivers to find the best match. In Linux, this usually results in the driver module being automatically loaded, provided it has been appropriately labelled and not blacklisted.  The  status  property indicates whether a device is enabled or disabled. If the  status  is  ok ,  okay  or absent, then the device is enabled. Otherwise,  status  should be  disabled , so that the device is disabled. It can be useful to place devices in a  .dtsi  file with the status set to  disabled . A derived configuration can then include that  .dtsi  and set the status for the devices which are needed to  okay .",
            "title": "1.4: Device Tree semantics"
        },
        {
            "location": "/configuration/device-tree/index.html#part-2-device-tree-overlays",
            "text": "A modern SoC (System on a Chip) is a very complicated device; a complete Device Tree could be hundreds of lines long. Taking that one step further and placing the SoC on a board with other components only makes matters worse. To keep that manageable, particularly if there are related devices that share components, it makes sense to put the common elements in  .dtsi  files, to be included from possibly multiple  .dts  files.  But when a system like Raspberry Pi supports optional plug-in accessories, such as HATs, the problem grows. Ultimately, each possible configuration requires a Device Tree to describe it, but once you factor in different base hardware (models A, B, A+, and B+) and gadgets only requiring the use of a few GPIO pins that can coexist, the number of combinations starts to multiply rapidly.  What is needed is a way to describe these optional components using a partial Device Tree, and then to be able to build a complete tree by taking a base DT and adding a number of optional elements. You can do this, and these optional elements are called \"overlays\".",
            "title": "Part 2: Device Tree overlays"
        },
        {
            "location": "/configuration/device-tree/index.html#21-fragments",
            "text": "A DT overlay comprises a number of fragments, each of which targets one node and its subnodes. Although the concept sounds simple enough, the syntax seems rather strange at first:  // Enable the i2s interface  / dts - v1 / ;  / plugin / ;  /   { \n     compatible   =   \"brcm,bcm2708\" ; \n\n     fragment @0   { \n         target   =   <& i2s > ; \n         __overlay__   { \n             status   =   \"okay\" ; \n         }; \n     };  };   The  compatible  string identifies this as being for BCM2708, which is the base architecture of the BCM2835 part. For the BCM2836 part you could use a compatible string of \"brcm,bcm2709\", but unless you are targeting features of the ARM CPUs, the two architectures should be equivalent, so sticking to \"brcm,bcm2708\" is reasonable. Then comes the first (and in this case only) fragment. Fragments are numbered sequentially from zero. Failure to adhere to this may cause some or all of your fragments to be missed.  Each fragment consists of two parts: a  target  property, identifying the node to apply the overlay to; and the  __overlay__  itself, the body of which is added to the target node. The example above can be interpreted as if it were written like this:  /dts-v1/;\n\n/ {\n    compatible = \"brcm,bcm2708\";\n};\n\n&i2s {\n    status = \"okay\";\n};  The effect of merging that overlay with a standard Raspberry Pi base Device Tree (e.g.  bcm2708-rpi-b-plus.dtb ), provided the overlay is loaded afterwards, would be to enable the I2S interface by changing its status to  okay . But if you try to compile this overlay using:  dtc -I dts -O dtb -o 2nd.dtbo 2nd-overlay.dts  you will get an error:  Label or path i2s not found  This shouldn't be too unexpected, since there is no reference to the base  .dtb  or  .dts  file to allow the compiler to find the  i2s  label.  Trying again, this time using the original example and adding the  -@  option to allow unresolved references:  dtc -@ -I dts -O dtb -o 1st.dtbo 1st-overlay.dts  If  dtc  returns an error about the third line, it doesn't have the extensions required for overlay work. Run  sudo apt-get install device-tree-compiler  and try again - this time, compilation should complete successfully. Note that a suitable compiler is also available in the kernel tree as  scripts/dtc/dtc , built when the  dtbs  make target is used:  make ARCH=arm dtbs  It is interesting to dump the contents of the DTB file to see what the compiler has generated:  $   fdtdump   1 st . dtbo  / dts - v1 / ;  // magic:           0xd00dfeed  // totalsize:       0x106 (262)  // off_dt_struct:   0x38  // off_dt_strings:  0xe8  // off_mem_rsvmap:  0x28  // version:         17  // last_comp_version:    16  // boot_cpuid_phys: 0x0  // size_dt_strings: 0x1e  // size_dt_struct:  0xb0  /   { \n     compatible   =   \"brcm,bcm2708\" ; \n     fragment @0   { \n         target   =   < 0xdeadbeef > ; \n         __overlay__   { \n             status   =   \"okay\" ; \n         }; \n     }; \n     __fixups__   { \n         i2s   =   \"/fragment@0:target:0\" ; \n     };  };   After the verbose description of the file structure there is our fragment. But look carefully - where we wrote  &i2s  it now says  0xdeadbeef , a clue that something strange has happened. After the fragment there is a new node,  __fixups__ . This contains a list of properties mapping the names of unresolved symbols to lists of paths to cells within the fragments that need patching with the phandle of the target node, once that target has been located. In this case, the path is to the  0xdeadbeef  value of  target , but fragments can contain other unresolved references which would require additional fixes.  If you write more complicated fragments, the compiler may generate two more nodes:  __local_fixups__  and  __symbols__ . The former is required if any node in the fragments has a phandle, because the program performing the merge will have to ensure that phandle numbers are sequential and unique. However, the latter is the key to how unresolved symbols are dealt with.  Back in section 1.3 it says that \"the original labels do not appear in the compiled output\", but this isn't true when using the  -@  switch. Instead, every label results in a property in the  __symbols__  node, mapping a label to a path, exactly like the  aliases  node. In fact, the mechanism is so similar that when resolving symbols, the Raspberry Pi loader will search the \"aliases\" node in the absence of a  __symbols__  node. This is useful because by providing sufficient aliases, we can allow an older  dtc  to be used to build the base DTB files.  UPDATE: The  Dynamic Device Tree  support in the kernel requires a different format of \"local fixups\" in the overlay. To avoid problems with old and new styles of overlay coexisting, and to match other users of overlays, the old \"name-overlay.dtb\" naming scheme has been replaced with \"name.dtbo\" from 4.4 onwards. Overlays should be referred to by name alone, and the firmware or utility that loads them will append the appropriate suffix. For example:  dtoverlay=awesome-overlay      # This is wrong\ndtoverlay=awesome              # This is correct",
            "title": "2.1: Fragments"
        },
        {
            "location": "/configuration/device-tree/index.html#22-device-tree-parameters",
            "text": "To avoid the need for lots of Device Tree overlays, and to reduce the need for users of peripherals to modify DTS files, the Raspberry Pi loader supports a new feature - Device Tree parameters. This permits small changes to the DT using named parameters, similar to the way kernel modules receive parameters from  modprobe  and the kernel command line. Parameters can be exposed by the base DTBs and by overlays, including HAT overlays.  Parameters are defined in the DTS by adding an  __overrides__  node to the root. It contains properties whose names are the chosen parameter names, and whose values are a sequence comprising a phandle (reference to a label) for the target node, and a string indicating the target property; string, integer (cell) and boolean properties are supported.",
            "title": "2.2: Device Tree parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#221-string-parameters",
            "text": "String parameters are declared like this:  name = <&label>,\"property\";  where  label  and  property  are replaced by suitable values. String parameters can cause their target properties to grow, shrink, or be created.  Note that properties called  status  are treated specially; non-zero/true/yes/on values are converted to the string  \"okay\" , while zero/false/no/off becomes  \"disabled\" .",
            "title": "2.2.1: String parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#222-integer-parameters",
            "text": "Integer parameters are declared like this:  name   =   <& label >, \"property.offset\" ;   //   8-bit  name   =   <& label >, \"property;offset\" ;   //   16-bit  name   =   <& label >, \"property:offset\" ;   //   32-bit  name   =   <& label >, \"property#offset\" ;   //   64-bit   where  label ,  property  and  offset  are replaced by suitable values; the offset is specified in bytes relative to the start of the property (in decimal by default), and the preceding separator dictates the size of the parameter. In a change from earlier implementations, integer parameters may refer to non-existent properties or to offsets beyond the end of an existing property.",
            "title": "2.2.2: Integer parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#223-boolean-parameters",
            "text": "Device Tree encodes boolean values as zero-length properties; if present then the property is true, otherwise it is false. They are defined like this:  boolean_property; // Set 'boolean_property' to true  Note that a property is assigned the value  false  by not defining it. Boolean parameters are declared like this:  name = <&label>,\"property?\";  where  label  and  property  are replaced by suitable values. Boolean parameters can cause properties to be created or deleted.",
            "title": "2.2.3: Boolean parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#224-overlayfragment-parameters",
            "text": "The DT parameter mechanism as described has a number of limitations, including the inability to change the name of a node and to write arbitrary values to arbitrary properties when a parameter is used. One way to overcome some of these limitations is to conditionally include or exclude certain fragments.  A fragment can be excluded from the final merge process (disabled) by renaming the  __overlay__  node to  __dormant__ . The parameter declaration syntax has been extended to allow the otherwise illegal zero target phandle to indicate that the following string contains operations at fragment or overlay scope. So far, four operations have been implemented:  +<n>    // Enable fragment <n>\n-<n>    // Disable fragment <n>\n=<n>    // Enable fragment <n> if the assigned parameter value is true, otherwise disable it\n!<n>    // Enable fragment <n> if the assigned parameter value is false, otherwise disable it  Examples:  just_one    = <0>,\"+1-2\"; // Enable 1, disable 2\nconditional = <0>,\"=3!4\"; // Enable 3, disable 4 if value is true,\n                          // otherwise disable 3, enable 4.  The i2c-mux overlay uses this technique.",
            "title": "2.2.4 Overlay/fragment parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#225-examples",
            "text": "Here are some examples of different types of properties, with parameters to modify them:  /   { \n     fragment @0   { \n         target - path   =   \"/\" ; \n         __overlay__   { \n\n             test :   test_node   { \n                 string   =   \"hello\" ; \n                 status   =   \"disabled\" ; \n                 bytes   =   / bits /   8   < 0x67   0x89 > ; \n                 u16s   =   / bits /   16   < 0xabcd   0xef01 > ; \n                 u32s   =   / bits /   32   < 0xfedcba98   0x76543210 > ; \n                 u64s   =   / bits /   64   <   0xaaaaa5a55a5a5555   0x0000111122223333 > ; \n                 bool1 ;   // Defaults to true \n                        // bool2 defaults to false \n             }; \n         }; \n     }; \n\n     fragment @1   { \n         target - path   =   \"/\" ; \n         __overlay__   { \n             frag1 ; \n         }; \n     }; \n\n     fragment @2   { \n         target - path   =   \"/\" ; \n         __dormant__   { \n             frag2 ; \n         }; \n     }; \n\n     __overrides__   { \n         string   =        <& test > , \"string\" ; \n         enable   =        <& test > , \"status\" ; \n         byte_0   =        <& test > , \"bytes.0\" ; \n         byte_1   =        <& test > , \"bytes.1\" ; \n         u16_0   =         <& test > , \"u16s;0\" ; \n         u16_1   =         <& test > , \"u16s;2\" ; \n         u32_0   =         <& test > , \"u32s:0\" ; \n         u32_1   =         <& test > , \"u32s:4\" ; \n         u64_0   =         <& test > , \"u64s#0\" ; \n         u64_1   =         <& test > , \"u64s#8\" ; \n         bool1   =         <& test > , \"bool1?\" ; \n         bool2   =         <& test > , \"bool2?\" ; \n         only1   =         < 0 > , \"+1-2\" ; \n         only2   =         < 0 > , \"-1+2\" ; \n         toggle1   =       < 0 > , \"=1\" ; \n         toggle2   =       < 0 > , \"=2\" ; \n         not1   =          < 0 > , \"!1\" ; \n         not2   =          < 0 > , \"!2\" ; \n     };  };",
            "title": "2.2.5 Examples"
        },
        {
            "location": "/configuration/device-tree/index.html#226-parameters-with-multiple-targets",
            "text": "There are some situations where it is convenient to be able to set the same value in multiple locations within the Device Tree. Rather than the ungainly approach of creating multiple parameters, it is possible to add multiple targets to a single parameter by concatenating them, like this:       __overrides__   { \n         gpiopin   =   <&w1>,\" gpios : 4 \",                    <&w1_pins>,\" brcm , pins : 0 \" ; \n         ... \n     } ;   (example taken from the  w1-gpio  overlay)  Note that it is even possible to target properties of different types with a single parameter. You could reasonably connect an \"enable\" parameter to a  status  string, cells containing zero or one, and a proper boolean property.",
            "title": "2.2.6: Parameters with multiple targets"
        },
        {
            "location": "/configuration/device-tree/index.html#227-further-overlay-examples",
            "text": "There is a growing collection of overlay source files hosted in the Raspberry Pi/Linux GitHub repository  here .",
            "title": "2.2.7: Further overlay examples"
        },
        {
            "location": "/configuration/device-tree/index.html#part-3-using-device-trees-on-raspberry-pi",
            "text": "",
            "title": "Part 3: Using Device Trees on Raspberry Pi"
        },
        {
            "location": "/configuration/device-tree/index.html#31-overlays-and-configtxt",
            "text": "On a Raspberry Pi it is the job of the loader (one of the  start.elf  images) to combine overlays with an appropriate base device tree, and then to pass a fully resolved Device Tree to the kernel. The base Device Trees are located alongside  start.elf  in the FAT partition (/boot from Linux), named  bcm2708-rpi-b.dtb ,  bcm2708-rpi-b-plus.dtb ,  bcm2708-rpi-cm.dtb , and  bcm2709-rpi-2-b.dtb . Note that Models A and A+ will use the \"b\" and \"b-plus\" variants, respectively. This selection is automatic, and allows the same SD card image to be used in a variety of devices.  Note that DT and ATAGs are mutually exclusive. As a result, passing a DT blob to a kernel that doesn't understand it causes a boot failure. To guard against this, the loader checks kernel images for DT-compatibility, which is marked by a trailer added by the  mkknlimg  utility; this can be found in the  scripts  directory of a recent kernel source tree. Any kernel without a trailer is assumed to be non-DT-capable.  A kernel built from the rpi-4.4.y tree (and later) will not function without a DTB, so from the 4.4 releases onwards, any kernel without a trailer is assumed to be DT-capable. You can override this by adding a trailer without the DTOK flag or by putting  device_tree=  in config.txt, but don't be surprised if it doesn't work.\nN.B. A corollary to this is that if the kernel has a trailer indicating DT capability then  device_tree=  will be ignored.  The loader now supports builds using bcm2835_defconfig, which selects the upstreamed BCM2835 support. This configuration will cause  bcm2835-rpi-b.dtb  and  bcm2835-rpi-b-plus.dtb  to be built. If these files are copied with the kernel, and if the kernel has been tagged by a recent  mkknlimg , then the loader will attempt to load one of those DTBs by default.  In order to manage Device Tree and overlays, the loader supports a number of new  config.txt  directives:  dtoverlay=acme-board\ndtparam=foo=bar,level=42  This will cause the loader to look for  overlays/acme-board.dtbo  in the firmware partition, which Raspbian mounts on  /boot . It will then search for parameters  foo  and  level , and assign the indicated values to them.  The loader will also search for an attached HAT with a programmed EEPROM, and load the supporting overlay from there; this happens without any user intervention.  There are several ways to tell that the kernel is using Device Tree:   The \"Machine model:\" kernel message during bootup has a board-specific value such as \"Raspberry Pi 2 Model B\", rather than \"BCM2709\".  Some time later, there may also be another kernel message saying \"No ATAGs?\" - this is expected.  /proc/device-tree  exists, and contains subdirectories and files that exactly mirror the nodes and properties of the DT.   With a Device Tree, the kernel will automatically search for and load modules that support the indicated enabled devices. As a result, by creating an appropriate DT overlay for a device you save users of the device from having to edit  /etc/modules ; all of the configuration goes in  config.txt , and in the case of a HAT, even that step is unnecessary. Note, however, that layered modules such as  i2c-dev  still need to be loaded explicitly.  The flipside is that because platform devices don't get created unless requested by the DTB, it should no longer be necessary to blacklist modules that used to be loaded as a result of platform devices defined in the board support code. In fact, current Raspbian images ship without a blacklist file.",
            "title": "3.1: Overlays and config.txt"
        },
        {
            "location": "/configuration/device-tree/index.html#32-dt-parameters",
            "text": "As described above, DT parameters are a convenient way to make small changes to a device's configuration. The current base DTBs support parameters for enabling and controlling the onboard audio, I2C, I2S and SPI interfaces without using dedicated overlays. In use, parameters look like this:  dtparam=audio=on,i2c_arm=on,i2c_arm_baudrate=400000,spi=on  Note that multiple assignments can be placed on the same line, but ensure you don't exceed the 80-character limit.  A future default  config.txt  may contain a section like this:  # Uncomment some or all of these to enable the optional hardware interfaces\n#dtparam=i2c_arm=on\n#dtparam=i2s=on\n#dtparam=spi=on  If you have an overlay that defines some parameters, they can be specified either on subsequent lines like this:  dtoverlay=lirc-rpi\ndtparam=gpio_out_pin=16\ndtparam=gpio_in_pin=17\ndtparam=gpio_in_pull=down  or appended to the overlay line like this:  dtoverlay=lirc-rpi:gpio_out_pin=16,gpio_in_pin=17,gpio_in_pull=down  Note here the use of a colon ( : ) to separate the overlay name from its parameters, which is a supported syntax variant.  Overlay parameters are only in scope until the next overlay is loaded. In the event of a parameter with the same name being exported by both the overlay and the base, the parameter in the overlay takes precedence; for clarity, it's recommended that you avoid doing this. To expose the parameter exported by the base DTB instead, end the current overlay scope using:  dtoverlay=",
            "title": "3.2: DT parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#33-board-specific-labels-and-parameters",
            "text": "Raspberry Pi boards have two I2C interfaces. These are nominally split: one for the ARM, and one for VideoCore (the \"GPU\"). On almost all models,  i2c1  belongs to the ARM and  i2c0  to VC, where it is used to control the camera and read the HAT EEPROM. However, there are two early revisions of the Model B that have those roles reversed.  To make it possible to use one set of overlays and parameters with all Pis, the firmware creates some board-specific DT parameters. These are:  i2c/i2c_arm\ni2c_vc\ni2c_baudrate/i2c_arm_baudrate\ni2c_vc_baudrate  These are aliases for  i2c0 ,  i2c1 ,  i2c0_baudrate , and  i2c1_baudrate . It is recommended that you only use  i2c_vc  and  i2c_vc_baudrate  if you really need to - for example, if you are programming a HAT EEPROM. Enabling  i2c_vc  can stop the Pi Camera being detected.  For people writing overlays, the same aliasing has been applied to the labels on the I2C DT nodes. Thus, you should write:  fragment @0   { \n     target   =   <& i2c_arm > ; \n     __overlay__   { \n         status   =   \"okay\" ; \n     };  };   Any overlays using the numeric variants will be modified to use the new aliases.",
            "title": "3.3: Board-specific labels and parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#34-hats-and-device-tree",
            "text": "A Raspberry Pi HAT is an add-on board for a \"Plus\"-shaped (A+, B+ or Pi 2 B) Raspberry Pi with an embedded EEPROM. The EEPROM includes any DT overlay required to enable the board, and this overlay can also expose parameters.  The HAT overlay is automatically loaded by the firmware after the base DTB, so its parameters are accessible until any other overlays are loaded, or until the overlay scope is ended using  dtoverlay= . If for some reason you want to suppress the loading of the HAT overlay, put  dtoverlay=  before any other  dtoverlay  or  dtparam  directive.",
            "title": "3.4: HATs and Device Tree"
        },
        {
            "location": "/configuration/device-tree/index.html#35-dynamic-device-tree",
            "text": "As of Linux 4.4, the RPi kernels support the dynamic loading of overlays and parameters. Compatible kernels manage a stack of overlays that are applied on top of the base DTB. Changes are immediately reflected in  /proc/device-tree  and can cause modules to be loaded and platform devices to be created and destroyed.  The use of the word \"stack\" above is important - overlays can only be added and removed at the top of the stack; changing something further down the stack requires that anything on top of it must first be removed.  There are some new commands for managing overlays:",
            "title": "3.5: Dynamic Device Tree"
        },
        {
            "location": "/configuration/device-tree/index.html#351-the-dtoverlay-command",
            "text": "dtoverlay  is a command line utility that loads and removes overlays while the system is running, as well as listing the available overlays and displaying their help information:  pi@raspberrypi ~ $ dtoverlay -h\nUsage:\n  dtoverlay <overlay> [<param>=<val>...]\n                           Add an overlay (with parameters)\n  dtoverlay -r [<overlay>] Remove an overlay (by name, index or the last)\n  dtoverlay -R [<overlay>] Remove from an overlay (by name, index or all)\n  dtoverlay -l             List active overlays/params\n  dtoverlay -a             List all overlays (marking the active)\n  dtoverlay -h             Show this usage message\n  dtoverlay -h <overlay>   Display help on an overlay\n  dtoverlay -h <overlay> <param>..  Or its parameters\n    where <overlay> is the name of an overlay or 'dtparam' for dtparams\nOptions applicable to most variants:\n    -d <dir>    Specify an alternate location for the overlays\n                (defaults to /boot/overlays or /flash/overlays)\n    -n          Dry run - show what would be executed\n    -v          Verbose operation  Unlike the  config.txt  equivalent, all parameters to an overlay must be included in the same command line - the  dtparam  command is only for parameters of the base DTB.  Two points to note:\n1. Command variants that change kernel state (adding and removing things) require root privilege, so you may need to prefix the command with  sudo .   Only overlays and parameters applied at run-time can be unloaded - an overlay or parameter applied by the firmware becomes \"baked in\" such that it won't be listed by  dtoverlay  and can't be removed.",
            "title": "3.5.1 The dtoverlay command"
        },
        {
            "location": "/configuration/device-tree/index.html#352-the-dtparam-command",
            "text": "dtparam  creates an overlay that has the same effect as using a dtparam directive in  config.txt . In usage it is largely equivalent to  dtoverlay  with an overlay name of  - , but there are a few small differences:    dtparam  will list the help information for all known parameters of the base DTB. Help on the dtparam command is still available using  dtparam -h .    When indicating a parameter for removal, only index numbers can be used (not names).",
            "title": "3.5.2 The dtparam command"
        },
        {
            "location": "/configuration/device-tree/index.html#353-guidelines-for-writing-runtime-capable-overlays",
            "text": "This area is poorly documented, but here are some accumulated tips:    The creation or deletion of a device object is triggered by a node being added or removed, or by the status of a node changing from disabled to enabled or vice versa. Beware - the absence of a \"status\" property means the node is enabled.    Don't create a node within a fragment that will overwrite an existing node in the base DTB - the kernel will rename the new node to make it unique. If you want to change the properties of an existing node, create a fragment that targets it.    ALSA doesn't prevent its codecs and other components from being unloaded while they are in use. Removing an overlay can cause a kernel exception if it deletes a codec that is still being used by a sound card. Experimentation found that devices are deleted in the reverse of fragment order in the overlay, so placing the node for the card after the nodes for the components allows an orderly shutdown.",
            "title": "3.5.3 Guidelines for writing runtime-capable overlays"
        },
        {
            "location": "/configuration/device-tree/index.html#354-caveats",
            "text": "The loading of overlays at runtime is a recent addition to the kernel, and so far there is no accepted way to do this from userspace. By hiding the details of this mechanism behind commands the aim is to insulate users from changes in the event that a different kernel interface becomes standardised.    Some overlays work better at run-time than others. Parts of the Device Tree are only used at boot time - changing them using an overlay will not have any effect.    Applying or removing some overlays may cause unexpected behaviour, so it should be done with caution. This is one of the reasons it requires  sudo .    Unloading the overlay for an ALSA card can stall if something is actively using ALSA - the LXPanel volume slider plugin demonstrates this effect. To enable overlays for sound cards to be removed, the  lxpanelctl  utility has been given two new options -  alsastop  and  alsastart  - and these are called from the auxiliary scripts  dtoverlay-pre  and  dtoverlay-post  before and after overlays are loaded or unloaded, respectively.    Removing an overlay will not cause a loaded module to be unloaded, but it may cause the reference count of some modules to drop to zero. Running  rmmod -a  twice will cause unused modules to be unloaded.    Overlays have to be removed in reverse order. The commands will allow you to remove an earlier one, but all the intermediate ones will be removed and re-applied, which may have unintended consequences.    Adding clocks under the  /clocks  node at run-time doesn't cause a new clock provider to be registered, so  devm_clk_get  will fail for a clock created in an overlay.",
            "title": "3.5.4 Caveats"
        },
        {
            "location": "/configuration/device-tree/index.html#36-supported-overlays-and-parameters",
            "text": "As it is too time-consuming to document the individual overlays here, please refer to the  README  file found alongside the overlay  .dtbo  files in  /boot/overlays . It is kept up-to-date with additions and changes.",
            "title": "3.6: Supported overlays and parameters"
        },
        {
            "location": "/configuration/device-tree/index.html#part-4-troubleshooting-and-pro-tips",
            "text": "",
            "title": "Part 4: Troubleshooting and pro tips"
        },
        {
            "location": "/configuration/device-tree/index.html#41-debugging",
            "text": "The loader will skip over missing overlays and bad parameters, but if there are serious errors, such as a missing or corrupt base DTB or a failed overlay merge, then the loader will fall back to a non-DT boot. If this happens, or if your settings don't behave as you expect, it is worth checking for warnings or errors from the loader:  sudo vcdbg log msg  Extra debugging can be enabled by adding  dtdebug=1  to  config.txt .  If the kernel fails to come up in DT mode,  this is probably because the kernel image does not have a valid trailer . Use  knlinfo  to check for one, and the  mkknlimg  utility to add one. Both utilities are included in the  scripts  directory of current Raspberry Pi kernel source trees.  You can create a human-readable representation of the current state of DT like this:  dtc -I fs /proc/device-tree  This can be useful to see the effect of merging overlays onto the underlying tree.  If kernel modules don't load as expected, check that they aren't blacklisted in  /etc/modprobe.d/raspi-blacklist.conf ; blacklisting shouldn't be necessary when using Device Tree. If that shows nothing untoward, you can also check that the module is exporting the correct aliases by searching  /lib/modules/<version>/modules.alias  for the  compatible  value. Otherwise, your driver is probably missing either:  .of_match_table   =   xxx_of_match ,   or:  MODULE_DEVICE_TABLE(of, xxx_of_match);  Failing that,  depmod  has failed or the updated modules haven't been installed on the target filesystem.",
            "title": "4.1: Debugging"
        },
        {
            "location": "/configuration/device-tree/index.html#42-testing-overlays-using-dtmerge-and-dtdiff",
            "text": "Alongside the  dtoverlay  and  dtparam  commands is a utility for applying an overlay to a DTB -  dtmerge . To use it you first need to obtain your base DTB, which can be obtained in one of two ways:  a) generate it from the live DT state in  /proc/device-tree :  dtc -I fs -O dtb -o base.dtb /proc/device-tree  This will include any overlays and parameters you have applied so far, either in  config.txt  or by loading them at runtime, which may or may not be what you want. Alternatively...  b) copy it from the source DTBs in /boot. This won't include overlays and parameters, but it also won't include any other modifications by the firmware. To allow testing of all overlays, the  dtmerge  utility will create some of the board-specific aliases (\"i2c_arm\", etc.), but this means that the result of a merge will include more differences from the original DTB than you might expect. The solution to this is to use dtmerge to make the copy:  dtmerge /boot/bcm2710-rpi-3-b.dtb base.dtb -  (the  -  indicates an absent overlay name).  You can now try applying an overlay or parameter:  dtmerge base.dtb merged.dtb - sd_overclock=62\ndtdiff base.dtb merged.dtb  which will return:  --- /dev/fd/63  2016-05-16 14:48:26.396024813 +0100  +++ /dev/fd/62  2016-05-16 14:48:26.396024813 +0100  @@ -594,7 +594,7 @@ \n                };\n\n                sdhost@7e202000 { -                       brcm,overclock-50 = <0x0>;  +                       brcm,overclock-50 = <0x3e>; \n                        brcm,pio-limit = <0x1>;\n                        bus-width = <0x4>;\n                        clocks = <0x8>;  You can also compare different overlays or parameters.  dtmerge base.dtb merged1.dtb /boot/overlays/spi1-1cs.dtbo\ndtmerge base.dtb merged2.dtb /boot/overlays/spi1-2cs.dtbo\ndtdiff merged1.dtb merged2.dtb  to get:  --- /dev/fd/63  2016-05-16 14:18:56.189634286 +0100  +++ /dev/fd/62  2016-05-16 14:18:56.189634286 +0100  @@ -453,7 +453,7 @@ \n\n                        spi1_cs_pins {\n                                brcm,function = <0x1>; -                               brcm,pins = <0x12>;  +                               brcm,pins = <0x12 0x11>; \n                                phandle = <0x3e>;\n                        }; @@ -725,7 +725,7 @@ \n                        #size-cells = <0x0>;\n                        clocks = <0x13 0x1>;\n                        compatible = \"brcm,bcm2835-aux-spi\"; -                       cs-gpios = <0xc 0x12 0x1>;  +                       cs-gpios = <0xc 0x12 0x1 0xc 0x11 0x1>; \n                        interrupts = <0x1 0x1d>;\n                        linux,phandle = <0x30>;\n                        phandle = <0x30>; @@ -743,6 +743,16 @@ \n                                spi-max-frequency = <0x7a120>;\n                                status = \"okay\";\n                        }; +  +                       spidev@1 {  +                               #address-cells = <0x1>;  +                               #size-cells = <0x0>;  +                               compatible = \"spidev\";  +                               phandle = <0x41>;  +                               reg = <0x1>;  +                               spi-max-frequency = <0x7a120>;  +                               status = \"okay\";  +                       }; \n                };\n\n                spi@7e2150C0 {",
            "title": "4.2: Testing overlays using dtmerge and dtdiff"
        },
        {
            "location": "/configuration/device-tree/index.html#43-forcing-a-specific-device-tree",
            "text": "If you have very specific needs that aren't supported by the default DTBs (in particular, people experimenting with the pure-DT approach used by the ARCH_BCM2835 project), or if you just want to experiment with writing your own DTs, you can tell the loader to load an alternate DTB file like this:  device_tree=my-pi.dtb",
            "title": "4.3: Forcing a specific Device Tree"
        },
        {
            "location": "/configuration/device-tree/index.html#44-disabling-device-tree-usage",
            "text": "Since the switch to the 4.4 kernel and the use of more upstream drivers, Device Tree usage is required in Pi kernels. The method of disabling DT usage is to add:  device_tree=  to  config.txt . However, if the kernel has a  mkknlimg  trailer indicating DT capability then this directive will be ignored.",
            "title": "4.4: Disabling Device Tree usage"
        },
        {
            "location": "/configuration/device-tree/index.html#45-shortcuts-and-syntax-variants",
            "text": "The loader understands a few shortcuts:  dtparam=i2c_arm=on\ndtparam=i2s=on  can be shortened to:  dtparam=i2c,i2s  ( i2c  is an alias of  i2c_arm , and the  =on  is assumed). It also still accepts the long-form versions:  device_tree_overlay  and  device_tree_param .  The loader used to accept the use of whitespace and colons as separators, but support for these has been discontinued for simplicity and so they can be used within parameter values without quotes.",
            "title": "4.5: Shortcuts and syntax variants"
        },
        {
            "location": "/configuration/device-tree/index.html#46-other-dt-commands-available-in-configtxt",
            "text": "device_tree_address \nThis is used to override the address where the firmware loads the device tree (not dt-blob). By default the firmware will choose a suitable place.  device_tree_end \nThis sets an (exclusive) limit to the loaded device tree. By default the device tree can grow to the end of usable memory, which is almost certainly what is required.  dtdebug \nIf non-zero, turn on some extra logging for the firmware's device tree processing.  enable_uart \nEnable the primary/console UART (ttyS0 on a Pi 3, ttyAMA0 otherwise - unless swapped with an overlay such as pi3-miniuart-bt). If the primary UART is ttyAMA0 then enable_uart defaults to 1 (enabled), otherwise it defaults to 0 (disabled). This is because it is necessary to stop the core frequency from changing which would make ttyS0 unusable, so  enable_uart=1  implies core_freq=250 (unless force_turbo=1). In some cases this is a performance hit, so it is off by default. More details on UARTs can be found  here  overlay_prefix \nSpecifies a subdirectory/prefix from which to load overlays - defaults to \"overlays/\". Note the trailing \"/\". If desired you can add something after the final \"/\" to add a prefix to each file, although this is not likely to be needed.  Further ports can be controlled by the DT, for more details see  section 3 .",
            "title": "4.6: Other DT commands available in config.txt"
        },
        {
            "location": "/configuration/external-storage/index.html",
            "text": "External Storage configuration\n\n\nYou can connect your external hard disk drive (HDD) to any of the USB ports on the Raspberry Pi, and mount the file system to access the data stored on your HDD. \n\n\nBy default, Raspberry Pi automatically mounts some of the popular file systems such as FAT, NTFS, and HFS+ at \n/media/pi/<HARD-DRIVE-LABEL>\n location. \n\n\nTo set up your HDD so that it always mounts to a specific location of your choice, you must manually mount your HDD.\n\n\nIf your HDD has an exFAT partition, install the exFAT driver.\n\n\nInstalling the exFAT driver\n\n\nRun the following commands in the command line to update the Aptitude repository, then install the exFAT driver using the Aptitude Package Manager. \n\n\nsudo apt-get update\nsudo apt-get install exfat-fuse\n\n\n\n\n\nMounting an HDD\n\n\nYou can mount your HDD at specific empty folder locations.\n\n\n\n\nPlug in the external HDD to a USB port on the Raspberry Pi. \n\n\n\n\nList the disk partitions on the device. Run the following command:\u2028\n\n\nsudo lsblk -o UUID,NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,MODEL\n\n   The Raspberry Pi uses mount points \n/\n and \n/boot\n.\n3. Use the SIZE, LABEL, and MODEL columns to identify the name of the disk partition that points to your HDD. For example, \nsda1\n. \n4. Run the following command to get the location of the disk partition.\n\n\nsudo blkid\n\nFor example, \n/dev/sda1\n.\n5. Create a target folder to be the mount point of the HDD. \n   The mount point name used in this case is \nPIHDD\n. You can specify a name of your choice. \n   Run the following command:\u2028\n\n\nsudo mkdir /mnt/PIHDD\n\n6. Mount the HDD from the location of the partition to the mount point you created. Run the following command:\u2028 \n\n\nsudo mount /dev/sda1 /mnt/PIHDD\n\n7. Verify that the HDD is mounted successfully by listing the content. Run the following command:\u2028\n\n\nls /mnt/PIHDD\n\n\n\n\n\n\nSetting up automatic mounting\n\n\nYou can modify the \nfstab\n file to define the location where the HDD will be automatically mounted when the Raspberry Pi starts up. In the \nfstab\n file, the disk partition is identified by the universally unique identifier (UUID). \n\n\n\n\n\n\nGet the UUID of the disk partition. Run the following command: \u2028\n\n\nsudo blkid\n\n2. Find the disk partition from the list and note the UUID. For example, \n5C24-1453\n.\n3. Edit the fstab file using a command line editor such as nano. Run the following command:\u2028\n\n\nsudo nano /etc/fstab\n\n4. Add the following line in the \nfstab\n file.\u2028\n\n\nUUID=5C24-1453 /mnt/PIHDD exfat defaults,auto,umask=000,users,rw 0 0\n\n\n\n\n\n\nFor more information on the Linux commands, refer to the specific manual pages using the \nman\n command. For example, \nman fstab\n.\n\n\nUnmounting an HDD\n\n\nBefore you unmount your HDD, ensure that there are no programs accessing the HDD. You can do this using the \nlsof\n command. \n\n\n\n\n\n\nRun the following commands to install \nlsof\n.\n\n\nsudo apt-get update\nsudo apt-get install -y lsof\n\n2. Get the list of programs using the mount point:\u2028\n\n\nlsof /mnt/PIHDD\n\n   where \nPIHDD\n is the mount point name.\n3. Manually close all the programs that are using the mount point.\n\n4. Unmount the HDD. Run the following command:\u2028 \n\n\nsudo umount /mnt/PIHDD\n\n5. Unplug the HDD and delete the mount point folder\u2028. Run the following command: \n\n\nsudo rmdir /mnt/PIHDD",
            "title": "External Storage configuration"
        },
        {
            "location": "/configuration/external-storage/index.html#external-storage-configuration",
            "text": "You can connect your external hard disk drive (HDD) to any of the USB ports on the Raspberry Pi, and mount the file system to access the data stored on your HDD.   By default, Raspberry Pi automatically mounts some of the popular file systems such as FAT, NTFS, and HFS+ at  /media/pi/<HARD-DRIVE-LABEL>  location.   To set up your HDD so that it always mounts to a specific location of your choice, you must manually mount your HDD.  If your HDD has an exFAT partition, install the exFAT driver.",
            "title": "External Storage configuration"
        },
        {
            "location": "/configuration/external-storage/index.html#installing-the-exfat-driver",
            "text": "Run the following commands in the command line to update the Aptitude repository, then install the exFAT driver using the Aptitude Package Manager.   sudo apt-get update\nsudo apt-get install exfat-fuse",
            "title": "Installing the exFAT driver"
        },
        {
            "location": "/configuration/external-storage/index.html#mounting-an-hdd",
            "text": "You can mount your HDD at specific empty folder locations.   Plug in the external HDD to a USB port on the Raspberry Pi.    List the disk partitions on the device. Run the following command:\u2028  sudo lsblk -o UUID,NAME,FSTYPE,SIZE,MOUNTPOINT,LABEL,MODEL \n   The Raspberry Pi uses mount points  /  and  /boot .\n3. Use the SIZE, LABEL, and MODEL columns to identify the name of the disk partition that points to your HDD. For example,  sda1 . \n4. Run the following command to get the location of the disk partition.  sudo blkid \nFor example,  /dev/sda1 .\n5. Create a target folder to be the mount point of the HDD. \n   The mount point name used in this case is  PIHDD . You can specify a name of your choice. \n   Run the following command:\u2028  sudo mkdir /mnt/PIHDD \n6. Mount the HDD from the location of the partition to the mount point you created. Run the following command:\u2028   sudo mount /dev/sda1 /mnt/PIHDD \n7. Verify that the HDD is mounted successfully by listing the content. Run the following command:\u2028  ls /mnt/PIHDD",
            "title": "Mounting an HDD"
        },
        {
            "location": "/configuration/external-storage/index.html#setting-up-automatic-mounting",
            "text": "You can modify the  fstab  file to define the location where the HDD will be automatically mounted when the Raspberry Pi starts up. In the  fstab  file, the disk partition is identified by the universally unique identifier (UUID).     Get the UUID of the disk partition. Run the following command: \u2028  sudo blkid \n2. Find the disk partition from the list and note the UUID. For example,  5C24-1453 .\n3. Edit the fstab file using a command line editor such as nano. Run the following command:\u2028  sudo nano /etc/fstab \n4. Add the following line in the  fstab  file.\u2028  UUID=5C24-1453 /mnt/PIHDD exfat defaults,auto,umask=000,users,rw 0 0    For more information on the Linux commands, refer to the specific manual pages using the  man  command. For example,  man fstab .",
            "title": "Setting up automatic mounting"
        },
        {
            "location": "/configuration/external-storage/index.html#unmounting-an-hdd",
            "text": "Before you unmount your HDD, ensure that there are no programs accessing the HDD. You can do this using the  lsof  command.     Run the following commands to install  lsof .  sudo apt-get update\nsudo apt-get install -y lsof \n2. Get the list of programs using the mount point:\u2028  lsof /mnt/PIHDD \n   where  PIHDD  is the mount point name.\n3. Manually close all the programs that are using the mount point. \n4. Unmount the HDD. Run the following command:\u2028   sudo umount /mnt/PIHDD \n5. Unplug the HDD and delete the mount point folder\u2028. Run the following command:   sudo rmdir /mnt/PIHDD",
            "title": "Unmounting an HDD"
        },
        {
            "location": "/configuration/localisation/index.html",
            "text": "Localisation\n\n\nSet your Raspberry Pi up to match your regional settings.\n\n\nLanguage\n\n\nNOOBS\n\n\nTo change the language used by NOOBS, you can either press the \nL\n key on your keyboard, press the up/down arrows to choose the language you want, and then press \nEnter\n; or you can do the same thing using the mouse. NOOBS will remember your selection, and will use the same language again next time.\n\n\nAlternatively, you can pre-select the language before booting NOOBS for the first time. See \nhere\n.\n\n\nRaspbian\n\n\nIf you've installed Raspbian using NOOBS, it should automatically pick up the same language you were using within NOOBS. But if you want to select a different language, or if you've installed Raspbian from a standalone image, use \nraspi-config\n.\n\n\nKeyboard\n\n\nNOOBS\n\n\nTo change the keyboard layout used by NOOBS, you can either press the \n9\n key on your keyboard, press the up/down arrows to choose the keyboard you want, and then press \nEnter\n; or you can do the same thing using the mouse. Note that changing the language (as described above) may automatically change the keyboard layout as appropriate too. NOOBS will remember your selection and use the same keyboard layout again next time.\n\n\nAlternatively, you can pre-select the keyboard before booting NOOBS for the first time. See \nhere\n.\n\n\nRaspbian\n\n\nIf you've installed Raspbian using NOOBS, it should automatically pick up the same keyboard you were using in NOOBS. But if you want to select a different keyboard, or if you've installed Raspbian from a standalone image, use \nraspi-config\n.\n\n\nTimezone\n\n\nNOOBS\n\n\nNo part of NOOBS uses the time; consequently there is no option for changing the timezone.\n\n\nRaspbian\n\n\nOnce again, this is something you can change using the \nraspi-config\n tool.",
            "title": "Localisation"
        },
        {
            "location": "/configuration/localisation/index.html#localisation",
            "text": "Set your Raspberry Pi up to match your regional settings.",
            "title": "Localisation"
        },
        {
            "location": "/configuration/localisation/index.html#language",
            "text": "",
            "title": "Language"
        },
        {
            "location": "/configuration/localisation/index.html#noobs",
            "text": "To change the language used by NOOBS, you can either press the  L  key on your keyboard, press the up/down arrows to choose the language you want, and then press  Enter ; or you can do the same thing using the mouse. NOOBS will remember your selection, and will use the same language again next time.  Alternatively, you can pre-select the language before booting NOOBS for the first time. See  here .",
            "title": "NOOBS"
        },
        {
            "location": "/configuration/localisation/index.html#raspbian",
            "text": "If you've installed Raspbian using NOOBS, it should automatically pick up the same language you were using within NOOBS. But if you want to select a different language, or if you've installed Raspbian from a standalone image, use  raspi-config .",
            "title": "Raspbian"
        },
        {
            "location": "/configuration/localisation/index.html#keyboard",
            "text": "",
            "title": "Keyboard"
        },
        {
            "location": "/configuration/localisation/index.html#noobs_1",
            "text": "To change the keyboard layout used by NOOBS, you can either press the  9  key on your keyboard, press the up/down arrows to choose the keyboard you want, and then press  Enter ; or you can do the same thing using the mouse. Note that changing the language (as described above) may automatically change the keyboard layout as appropriate too. NOOBS will remember your selection and use the same keyboard layout again next time.  Alternatively, you can pre-select the keyboard before booting NOOBS for the first time. See  here .",
            "title": "NOOBS"
        },
        {
            "location": "/configuration/localisation/index.html#raspbian_1",
            "text": "If you've installed Raspbian using NOOBS, it should automatically pick up the same keyboard you were using in NOOBS. But if you want to select a different keyboard, or if you've installed Raspbian from a standalone image, use  raspi-config .",
            "title": "Raspbian"
        },
        {
            "location": "/configuration/localisation/index.html#timezone",
            "text": "",
            "title": "Timezone"
        },
        {
            "location": "/configuration/localisation/index.html#noobs_2",
            "text": "No part of NOOBS uses the time; consequently there is no option for changing the timezone.",
            "title": "NOOBS"
        },
        {
            "location": "/configuration/localisation/index.html#raspbian_2",
            "text": "Once again, this is something you can change using the  raspi-config  tool.",
            "title": "Raspbian"
        },
        {
            "location": "/configuration/pin-configuration/index.html",
            "text": "Changing the default pin configuration\n\n\nThis feature is intended for advanced users.\n\n\nAs of 15 July 2014, the Raspberry Pi firmware supports custom default pin configurations through a user-provided Device Tree blob file. To find out whether your firmware is recent enough, please run \nvcgencmd version\n.\n\n\nProviding a custom Device Tree blob\n\n\nIn order to compile a Device Tree source (\n.dts\n) file into a Device Tree blob (\n.dtb\n) file, the Device Tree compiler must be installed by running \nsudo apt-get install device-tree-compiler\n. The \ndtc\n command can then be used as follows:\n\n\nsudo dtc -I dts -O dtb -o /boot/dt-blob.bin dt-blob.dts\n\n\n\n\n\nNOTE:\n In the case of NOOBS installs, the DTB file should be placed on the recovery partition instead.\n\n\nSimilarly, a \n.dtb\n file can be converted back to a \n.dts\n file, if required.\n\n\ndtc -I dtb -O dts -o dt-blob.dts /boot/dt-blob.bin\n\n\n\n\n\nSections of the dt-blob\n\n\nThe \ndt-blob.bin\n is used to configure the binary blob (VideoCore) at boot time. It is not currently used by the Linux kernel, but a kernel section will be added at a later stage, when we reconfigure the Raspberry Pi kernel to use a dt-blob for configuration.  The dt-blob can configure all versions of the Raspberry Pi, including the Compute Module, to use the alternative settings. The following sections are valid in the dt-blob:\n\n\n\n\nvideocore\n\n\n\n\nThis section contains all of the VideoCore blob information. All subsequent sections must be enclosed within this section.\n\n\n\n\npins_*\n\n\n\n\nThere are a number of separate \npins_*\n sections, based on particular Raspberry Pi models, namely:\n\n\n\n\npins_rev1\n Rev1 pin setup. There are some differences because of the moved I2C pins.\n\n\npins_rev2\n Rev2 pin setup. This includes the additional codec pins on P5.\n\n\npins_bplus1\n Model B+ rev 1.1, including the full 40pin connector.\n\n\npins_bplus2\n Model B+ rev 1.2, swapping the low-power and lan-run pins.\n\n\npins_aplus\n Model A+, lacking Ethernet.\n\n\npins_2b1\n Pi 2 Model B rev 1.0; controls the SMPS via I2C0.\n\n\npins_2b2\n Pi 2 Model B rev 1.1; controls the SMPS via software I2C on 42 and 43.\n\n\npins_3b1\n Pi 3 Model B rev 1.0\n\n\npins_3b2\n Pi 3 Model B rev 1.2\n\n\npins_pi0\n The Pi Zero\n\n\npins_pi0w\n The Pi Zero W\n\n\npins_cm\n The Compute Module. The default for this is the default for the chip, so it is a useful source of information about default pull ups/downs on the chip.\n\n\npins_cm3\n The Compute Module version 3\n\n\n\n\nEach \npins_*\n section can contain \npin_config\n and \npin_defines\n sections.\n\n\n\n\npin_config\n\n\n\n\nThe \npin_config\n section is used to configure the individual pins. Each item in this section must be a named pin section, such as \npin@p32\n, meaning GPIO32. There is a special section \npin@default\n, which contains the default settings for anything not specifically named in the pin_config section.\n\n\n\n\npin@pinname\n\n\n\n\nThis section can contain any combination of the following items:\n\n\n\n\npolarity\n\n\nactive_high\n\n\nactive_low\n\n\n\n\n\n\ntermination\n\n\npull_up\n\n\npull_down\n\n\nno_pulling\n\n\n\n\n\n\nstartup_state\n\n\nactive\n\n\ninactive\n\n\n\n\n\n\nfunction\n\n\ninput\n\n\noutput\n\n\nsdcard\n\n\ni2c0\n\n\ni2c1\n\n\nspi\n\n\nspi1\n\n\nspi2\n\n\nsmi\n\n\ndpi\n\n\npcm\n\n\npwm\n\n\nuart0\n\n\nuart1\n\n\ngp_clk\n\n\nemmc\n\n\narm_jtag\n\n\n\n\n\n\n\n\ndrive_strength_ma\n\n      The drive strength is used to set a strength for the pins. Please note that you can only specify a single drive strength for the bank. <8> and <16> are valid values.\n\n\n\n\n\n\npin_defines\n\n\n\n\n\n\nThis section is used to set specific VideoCore functionality to particular pins. This enables the user to move the camera power enable pin to somewhere different, or move the HDMI hotplug position: things that Linux does not control. Please refer to the example DTS file below.\n\n\nClock configuration\n\n\nIt is possible to change the configuration of the clocks through this interface, although it can be difficult to predict the results! The configuration of the clocking system is very complex. There are five separate PLLs, and each one has its own fixed (or variable, in the case of PLLC) VCO frequency. Each VCO then has a number of different channels which can be set up with a different division of the VCO frequency. Each of the clock destinations can be configured to come from one of the clock channels, although there is a restricted mapping of source to destination, so not all channels can be routed to all clock destinations.\n\n\nHere are a couple of example configurations that you can use to alter specific clocks. We will add to this resource when requests for clock configurations are made.\n\n\nclock_routing {\n   vco@PLLA  {    freq = <1966080000>; };\n   chan@APER {    div  = <4>; };\n   clock@GPCLK0 { pll = \"PLLA\"; chan = \"APER\"; };\n};\n\nclock_setup {\n   clock@PWM { freq = <2400000>; };\n   clock@GPCLK0 { freq = <12288000>; };\n   clock@GPCLK1 { freq = <25000000>; };\n};\n\n\n\n\n\nThe above will set the PLLA to a source VCO running at 1.96608GHz (the limits for this VCO are 600MHz - 2.4GHz), change the APER channel to /4, and configure GPCLK0 to be sourced from PLLA through APER. This is used to give an audio codec the 12288000Hz it needs to produce the 48000 range of frequencies.\n\n\nSample Device Tree source file\n\n\nThis example file comes from the firmware repository. It is the master Raspberry Pi blob, from which others are usually derived.\n\n\nhttps://github.com/raspberrypi/firmware/blob/master/extra/dt-blob.dts",
            "title": "Changing the default pin configuration"
        },
        {
            "location": "/configuration/pin-configuration/index.html#changing-the-default-pin-configuration",
            "text": "This feature is intended for advanced users.  As of 15 July 2014, the Raspberry Pi firmware supports custom default pin configurations through a user-provided Device Tree blob file. To find out whether your firmware is recent enough, please run  vcgencmd version .",
            "title": "Changing the default pin configuration"
        },
        {
            "location": "/configuration/pin-configuration/index.html#providing-a-custom-device-tree-blob",
            "text": "In order to compile a Device Tree source ( .dts ) file into a Device Tree blob ( .dtb ) file, the Device Tree compiler must be installed by running  sudo apt-get install device-tree-compiler . The  dtc  command can then be used as follows:  sudo dtc -I dts -O dtb -o /boot/dt-blob.bin dt-blob.dts  NOTE:  In the case of NOOBS installs, the DTB file should be placed on the recovery partition instead.  Similarly, a  .dtb  file can be converted back to a  .dts  file, if required.  dtc -I dtb -O dts -o dt-blob.dts /boot/dt-blob.bin",
            "title": "Providing a custom Device Tree blob"
        },
        {
            "location": "/configuration/pin-configuration/index.html#sections-of-the-dt-blob",
            "text": "The  dt-blob.bin  is used to configure the binary blob (VideoCore) at boot time. It is not currently used by the Linux kernel, but a kernel section will be added at a later stage, when we reconfigure the Raspberry Pi kernel to use a dt-blob for configuration.  The dt-blob can configure all versions of the Raspberry Pi, including the Compute Module, to use the alternative settings. The following sections are valid in the dt-blob:   videocore   This section contains all of the VideoCore blob information. All subsequent sections must be enclosed within this section.   pins_*   There are a number of separate  pins_*  sections, based on particular Raspberry Pi models, namely:   pins_rev1  Rev1 pin setup. There are some differences because of the moved I2C pins.  pins_rev2  Rev2 pin setup. This includes the additional codec pins on P5.  pins_bplus1  Model B+ rev 1.1, including the full 40pin connector.  pins_bplus2  Model B+ rev 1.2, swapping the low-power and lan-run pins.  pins_aplus  Model A+, lacking Ethernet.  pins_2b1  Pi 2 Model B rev 1.0; controls the SMPS via I2C0.  pins_2b2  Pi 2 Model B rev 1.1; controls the SMPS via software I2C on 42 and 43.  pins_3b1  Pi 3 Model B rev 1.0  pins_3b2  Pi 3 Model B rev 1.2  pins_pi0  The Pi Zero  pins_pi0w  The Pi Zero W  pins_cm  The Compute Module. The default for this is the default for the chip, so it is a useful source of information about default pull ups/downs on the chip.  pins_cm3  The Compute Module version 3   Each  pins_*  section can contain  pin_config  and  pin_defines  sections.   pin_config   The  pin_config  section is used to configure the individual pins. Each item in this section must be a named pin section, such as  pin@p32 , meaning GPIO32. There is a special section  pin@default , which contains the default settings for anything not specifically named in the pin_config section.   pin@pinname   This section can contain any combination of the following items:   polarity  active_high  active_low    termination  pull_up  pull_down  no_pulling    startup_state  active  inactive    function  input  output  sdcard  i2c0  i2c1  spi  spi1  spi2  smi  dpi  pcm  pwm  uart0  uart1  gp_clk  emmc  arm_jtag     drive_strength_ma \n      The drive strength is used to set a strength for the pins. Please note that you can only specify a single drive strength for the bank. <8> and <16> are valid values.    pin_defines    This section is used to set specific VideoCore functionality to particular pins. This enables the user to move the camera power enable pin to somewhere different, or move the HDMI hotplug position: things that Linux does not control. Please refer to the example DTS file below.",
            "title": "Sections of the dt-blob"
        },
        {
            "location": "/configuration/pin-configuration/index.html#clock-configuration",
            "text": "It is possible to change the configuration of the clocks through this interface, although it can be difficult to predict the results! The configuration of the clocking system is very complex. There are five separate PLLs, and each one has its own fixed (or variable, in the case of PLLC) VCO frequency. Each VCO then has a number of different channels which can be set up with a different division of the VCO frequency. Each of the clock destinations can be configured to come from one of the clock channels, although there is a restricted mapping of source to destination, so not all channels can be routed to all clock destinations.  Here are a couple of example configurations that you can use to alter specific clocks. We will add to this resource when requests for clock configurations are made.  clock_routing {\n   vco@PLLA  {    freq = <1966080000>; };\n   chan@APER {    div  = <4>; };\n   clock@GPCLK0 { pll = \"PLLA\"; chan = \"APER\"; };\n};\n\nclock_setup {\n   clock@PWM { freq = <2400000>; };\n   clock@GPCLK0 { freq = <12288000>; };\n   clock@GPCLK1 { freq = <25000000>; };\n};  The above will set the PLLA to a source VCO running at 1.96608GHz (the limits for this VCO are 600MHz - 2.4GHz), change the APER channel to /4, and configure GPCLK0 to be sourced from PLLA through APER. This is used to give an audio codec the 12288000Hz it needs to produce the 48000 range of frequencies.",
            "title": "Clock configuration"
        },
        {
            "location": "/configuration/pin-configuration/index.html#sample-device-tree-source-file",
            "text": "This example file comes from the firmware repository. It is the master Raspberry Pi blob, from which others are usually derived.  https://github.com/raspberrypi/firmware/blob/master/extra/dt-blob.dts",
            "title": "Sample Device Tree source file"
        },
        {
            "location": "/configuration/raspi-config/index.html",
            "text": "raspi-config\n\n\nraspi-config\n is the Raspberry Pi configuration tool written and maintained by \nAlex Bradbury\n. It targets Raspbian.\n\n\n\n\nUsage\n\n\nYou will be shown \nraspi-config\n on first booting into Raspbian. To open the configuration tool after this, simply run the following from the command line:\n\n\nsudo raspi-config\n\n\n\n\n\nThe \nsudo\n is required because you will be changing files that you do not own as the \npi\n user.\n\n\nYou should see a blue screen with options in a grey box in the centre, like so:\n\n\n\n\nIt has the following options available:\n\n\n                        Raspberry Pi Software Configuration Tool (raspi-config)\n\nSetup Options\n\n    1 Expand Filesystem              Ensures that all of the SD card storage is available to the OS\n    2 Change User Password           Change password for the default user (pi)\n    3 Enable Boot to Desktop/Scratch Choose whether to boot into a desktop environment, Scratch, or the command line\n    4 Internationalisation Options   Set up language and regional settings to match your location\n    5 Enable Camera                  Enable this Pi to work with the Raspberry Pi camera\n    6 Overclock                      Configure overclocking for your Pi\n    7 Advanced Options               Configure advanced settings\n    8 About `raspi-config`           Information about this configuration tool\n\n                                   <Select>                                  <Finish>\n\n\n\n\n\n\n\nMoving around the menu\n\n\nUse the \nup\n and \ndown\n arrow keys to move the highlighted selection between the options available. Pressing the \nright\n arrow key will jump out of the Options menu and take you to the \n<Select>\n and \n<Finish>\n buttons. Pressing \nleft\n will take you back to the options. Alternatively, you can use the \nTab\n key to switch between these.\n\n\nNote that in long lists of option values (like the list of timezone cities), you can also type a letter to skip to that section of the list. For example, entering \nL\n will skip you to Lisbon, just two options away from London, to save you scrolling all the way through the alphabet.\n\n\n\n\nWhat raspi-config does\n\n\nGenerally speaking, \nraspi-config\n aims to provide the functionality to make the most common configuration changes. This may result in automated edits to \n/boot/config.txt\n and various standard Linux configuration files. Some options require a reboot to take effect. If you changed any of those, \nraspi-config\n will ask if you wish to reboot now when you select the \n<Finish>\n button.\n\n\n\n\nMenu options\n\n\n\n\nExpand filesystem\n\n\nIf you have installed Raspbian using NOOBS, the filesystem will have been expanded automatically. There may be a rare occasion where this is not the case, e.g. if you have copied a smaller SD card onto a larger one. In this case, you should use this option to expand your installation to fill the whole SD card, giving you more space to use for files. You will need to reboot the Raspberry Pi to make this available. Note that there is no confirmation: selecting the option begins the partition expansion immediately.\n\n\n\n\nChange user password\n\n\nThe default user on Raspbian is \npi\n with the password \nraspberry\n. You can change that here. Read about other \nusers\n.\n\n\n\n\nEnable boot to desktop or Scratch\n\n\nYou can change what happens when your Pi boots. Use this option to change your boot preference to command line, desktop, or straight to Scratch.\n\n\n\n\nInternationalisation options\n\n\nSelect \nInternationalisation Options\n and press \nEnter\n to be taken to a sub-menu containing the following options:\n\n\n\n\nChange locale\n\n\nSelect a locale, for example \nen_GB.UTF-8 UTF-8\n.\n\n\n\n\nChange timezone\n\n\nSelect your local timezone, starting with the region such as \nEurope\n, then selecting a city, for example \nLondon\n. Type a letter to skip down the list to that point in the alphabet.\n\n\n\n\nChange keyboard layout\n\n\nThis option opens another menu which allows you to select your keyboard layout. It will take a long time to display while it reads all the keyboard types. Changes usually take effect immediately, but may require a reboot.\n\n\n\n\nEnable camera\n\n\nIn order to use the Raspberry Pi Camera Module, you must enable it here. Select the option and proceed to \nEnable\n. This will make sure at least 128MB of RAM is dedicated to the GPU.\n\n\n\n\nOverclock\n\n\nIt is possible to overclock your Raspberry Pi's CPU. The default is 700MHz but it can be set up to 1000MHz. The overclocking you can achieve will vary; overclocking too high may result in instability. Selecting this option shows the following warning:\n\n\nBe aware that overclocking may reduce the lifetime of your Raspberry Pi. If overclocking at a certain level causes system instability, try a more modest overclock. Hold down `shift` during boot to temporarily disable overclock.\n\n\n\n\n\n\n\nAdvanced options\n\n\n\n\nOverscan\n\n\nOld TV sets had a significant variation in the size of the picture they produced; some had cabinets that overlapped the screen. TV pictures were therefore given a black border so that none of the picture was lost; this is called overscan. Modern TVs and monitors don't need the border, and the signal doesn't allow for it. If the initial text shown on the screen disappears off the edge, you need to enable overscan to bring the border back.\n\n\nAny changes will take effect after a reboot. You can have greater control over the settings by editing \nconfig.txt\n.\n\n\nOn some displays, particularly monitors, disabling overscan will make the picture fill the whole screen and correct the resolution. For other displays, it may be necessary to leave overscan enabled and adjust its values.\n\n\n\n\nHostname\n\n\nSet the visible name for this Pi on a network.\n\n\n\n\nMemory split\n\n\nChange the amount of memory made available to the GPU.\n\n\n\n\nSSH\n\n\nEnable/disable remote command line access to your Pi using SSH.\n\n\nSSH allows you to remotely access the command line of the Raspberry Pi from another computer. SSH is disabled by default. Read more about using SSH on the \nSSH documentation page\n. If connecting your Pi directly to a public network, you should not enable SSH unless you have set up secure passwords for all users.\n\n\n\n\nDevice Tree\n\n\nEnable/Disable the use of Device Tree. Read more about Device Trees config on the \nDevice Trees documentation page\n.\n\n\n\n\nSPI\n\n\nEnable/Disable SPI interfaces and automatic loading of the SPI kernel module, needed for products such as PiFace.\n\n\n\n\nI2C\n\n\nEnable/Disable I2C interfaces and automatic loading of the I2C kernel module.\n\n\n\n\nSerial\n\n\nEnable/Disable shell and kernel messages on the serial connection.\n\n\n\n\nAudio\n\n\nForce audio out through HDMI or a 3.5mm jack. Read more on the \naudio configuration documentation page\n.\n\n\n\n\nUpdate\n\n\nUpdate this tool to the latest version.\n\n\n\n\nAbout raspi-config\n\n\nSelecting this option shows the following text:\n\n\nThis tool provides a straightforward way of doing initial configuration of the Raspberry Pi. Although it can be run at any time, some of the options may have difficulties if you have heavily customised your installation.\n\n\n\n\n\n\n\nFinish\n\n\nUse this button when you have completed your changes. You will be asked whether you want to reboot or not. When used for the first time, it's best to reboot. There will be a delay in rebooting if you have chosen to resize your SD card.\n\n\n\n\nDevelopment of this tool\n\n\nSee this tool's source at \ngithub.com/RPi-Distro/raspi-config\n, where you can open issues and create pull requests.\n\n\n\n\nThis article uses content from the eLinux wiki page \nRPi raspi-config\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "raspi-config"
        },
        {
            "location": "/configuration/raspi-config/index.html#raspi-config",
            "text": "raspi-config  is the Raspberry Pi configuration tool written and maintained by  Alex Bradbury . It targets Raspbian.",
            "title": "raspi-config"
        },
        {
            "location": "/configuration/raspi-config/index.html#usage",
            "text": "You will be shown  raspi-config  on first booting into Raspbian. To open the configuration tool after this, simply run the following from the command line:  sudo raspi-config  The  sudo  is required because you will be changing files that you do not own as the  pi  user.  You should see a blue screen with options in a grey box in the centre, like so:   It has the following options available:                          Raspberry Pi Software Configuration Tool (raspi-config)\n\nSetup Options\n\n    1 Expand Filesystem              Ensures that all of the SD card storage is available to the OS\n    2 Change User Password           Change password for the default user (pi)\n    3 Enable Boot to Desktop/Scratch Choose whether to boot into a desktop environment, Scratch, or the command line\n    4 Internationalisation Options   Set up language and regional settings to match your location\n    5 Enable Camera                  Enable this Pi to work with the Raspberry Pi camera\n    6 Overclock                      Configure overclocking for your Pi\n    7 Advanced Options               Configure advanced settings\n    8 About `raspi-config`           Information about this configuration tool\n\n                                   <Select>                                  <Finish>",
            "title": "Usage"
        },
        {
            "location": "/configuration/raspi-config/index.html#moving-around-the-menu",
            "text": "Use the  up  and  down  arrow keys to move the highlighted selection between the options available. Pressing the  right  arrow key will jump out of the Options menu and take you to the  <Select>  and  <Finish>  buttons. Pressing  left  will take you back to the options. Alternatively, you can use the  Tab  key to switch between these.  Note that in long lists of option values (like the list of timezone cities), you can also type a letter to skip to that section of the list. For example, entering  L  will skip you to Lisbon, just two options away from London, to save you scrolling all the way through the alphabet.",
            "title": "Moving around the menu"
        },
        {
            "location": "/configuration/raspi-config/index.html#what-raspi-config-does",
            "text": "Generally speaking,  raspi-config  aims to provide the functionality to make the most common configuration changes. This may result in automated edits to  /boot/config.txt  and various standard Linux configuration files. Some options require a reboot to take effect. If you changed any of those,  raspi-config  will ask if you wish to reboot now when you select the  <Finish>  button.",
            "title": "What raspi-config does"
        },
        {
            "location": "/configuration/raspi-config/index.html#menu-options",
            "text": "",
            "title": "Menu options"
        },
        {
            "location": "/configuration/raspi-config/index.html#expand-filesystem",
            "text": "If you have installed Raspbian using NOOBS, the filesystem will have been expanded automatically. There may be a rare occasion where this is not the case, e.g. if you have copied a smaller SD card onto a larger one. In this case, you should use this option to expand your installation to fill the whole SD card, giving you more space to use for files. You will need to reboot the Raspberry Pi to make this available. Note that there is no confirmation: selecting the option begins the partition expansion immediately.",
            "title": "Expand filesystem"
        },
        {
            "location": "/configuration/raspi-config/index.html#change-user-password",
            "text": "The default user on Raspbian is  pi  with the password  raspberry . You can change that here. Read about other  users .",
            "title": "Change user password"
        },
        {
            "location": "/configuration/raspi-config/index.html#enable-boot-to-desktop-or-scratch",
            "text": "You can change what happens when your Pi boots. Use this option to change your boot preference to command line, desktop, or straight to Scratch.",
            "title": "Enable boot to desktop or Scratch"
        },
        {
            "location": "/configuration/raspi-config/index.html#internationalisation-options",
            "text": "Select  Internationalisation Options  and press  Enter  to be taken to a sub-menu containing the following options:",
            "title": "Internationalisation options"
        },
        {
            "location": "/configuration/raspi-config/index.html#change-locale",
            "text": "Select a locale, for example  en_GB.UTF-8 UTF-8 .",
            "title": "Change locale"
        },
        {
            "location": "/configuration/raspi-config/index.html#change-timezone",
            "text": "Select your local timezone, starting with the region such as  Europe , then selecting a city, for example  London . Type a letter to skip down the list to that point in the alphabet.",
            "title": "Change timezone"
        },
        {
            "location": "/configuration/raspi-config/index.html#change-keyboard-layout",
            "text": "This option opens another menu which allows you to select your keyboard layout. It will take a long time to display while it reads all the keyboard types. Changes usually take effect immediately, but may require a reboot.",
            "title": "Change keyboard layout"
        },
        {
            "location": "/configuration/raspi-config/index.html#enable-camera",
            "text": "In order to use the Raspberry Pi Camera Module, you must enable it here. Select the option and proceed to  Enable . This will make sure at least 128MB of RAM is dedicated to the GPU.",
            "title": "Enable camera"
        },
        {
            "location": "/configuration/raspi-config/index.html#overclock",
            "text": "It is possible to overclock your Raspberry Pi's CPU. The default is 700MHz but it can be set up to 1000MHz. The overclocking you can achieve will vary; overclocking too high may result in instability. Selecting this option shows the following warning:  Be aware that overclocking may reduce the lifetime of your Raspberry Pi. If overclocking at a certain level causes system instability, try a more modest overclock. Hold down `shift` during boot to temporarily disable overclock.",
            "title": "Overclock"
        },
        {
            "location": "/configuration/raspi-config/index.html#advanced-options",
            "text": "",
            "title": "Advanced options"
        },
        {
            "location": "/configuration/raspi-config/index.html#overscan",
            "text": "Old TV sets had a significant variation in the size of the picture they produced; some had cabinets that overlapped the screen. TV pictures were therefore given a black border so that none of the picture was lost; this is called overscan. Modern TVs and monitors don't need the border, and the signal doesn't allow for it. If the initial text shown on the screen disappears off the edge, you need to enable overscan to bring the border back.  Any changes will take effect after a reboot. You can have greater control over the settings by editing  config.txt .  On some displays, particularly monitors, disabling overscan will make the picture fill the whole screen and correct the resolution. For other displays, it may be necessary to leave overscan enabled and adjust its values.",
            "title": "Overscan"
        },
        {
            "location": "/configuration/raspi-config/index.html#hostname",
            "text": "Set the visible name for this Pi on a network.",
            "title": "Hostname"
        },
        {
            "location": "/configuration/raspi-config/index.html#memory-split",
            "text": "Change the amount of memory made available to the GPU.",
            "title": "Memory split"
        },
        {
            "location": "/configuration/raspi-config/index.html#ssh",
            "text": "Enable/disable remote command line access to your Pi using SSH.  SSH allows you to remotely access the command line of the Raspberry Pi from another computer. SSH is disabled by default. Read more about using SSH on the  SSH documentation page . If connecting your Pi directly to a public network, you should not enable SSH unless you have set up secure passwords for all users.",
            "title": "SSH"
        },
        {
            "location": "/configuration/raspi-config/index.html#device-tree",
            "text": "Enable/Disable the use of Device Tree. Read more about Device Trees config on the  Device Trees documentation page .",
            "title": "Device Tree"
        },
        {
            "location": "/configuration/raspi-config/index.html#spi",
            "text": "Enable/Disable SPI interfaces and automatic loading of the SPI kernel module, needed for products such as PiFace.",
            "title": "SPI"
        },
        {
            "location": "/configuration/raspi-config/index.html#i2c",
            "text": "Enable/Disable I2C interfaces and automatic loading of the I2C kernel module.",
            "title": "I2C"
        },
        {
            "location": "/configuration/raspi-config/index.html#serial",
            "text": "Enable/Disable shell and kernel messages on the serial connection.",
            "title": "Serial"
        },
        {
            "location": "/configuration/raspi-config/index.html#audio",
            "text": "Force audio out through HDMI or a 3.5mm jack. Read more on the  audio configuration documentation page .",
            "title": "Audio"
        },
        {
            "location": "/configuration/raspi-config/index.html#update",
            "text": "Update this tool to the latest version.",
            "title": "Update"
        },
        {
            "location": "/configuration/raspi-config/index.html#about-raspi-config",
            "text": "Selecting this option shows the following text:  This tool provides a straightforward way of doing initial configuration of the Raspberry Pi. Although it can be run at any time, some of the options may have difficulties if you have heavily customised your installation.",
            "title": "About raspi-config"
        },
        {
            "location": "/configuration/raspi-config/index.html#finish",
            "text": "Use this button when you have completed your changes. You will be asked whether you want to reboot or not. When used for the first time, it's best to reboot. There will be a delay in rebooting if you have chosen to resize your SD card.",
            "title": "Finish"
        },
        {
            "location": "/configuration/raspi-config/index.html#development-of-this-tool",
            "text": "See this tool's source at  github.com/RPi-Distro/raspi-config , where you can open issues and create pull requests.   This article uses content from the eLinux wiki page  RPi raspi-config , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Development of this tool"
        },
        {
            "location": "/configuration/screensaver/index.html",
            "text": "Setting the screen saver/screen blanking\n\n\nOn the Console\n\n\nIf you are using the Raspberry Pi solely on the console (no desktop GUI), you need to set the console blanking. The current setting, in seconds, can be displayed using\n\n\ncat /sys/module/kernel/parameters/consoleblank\n\n\n\n\n\nHere, \nconsoleblank\n is a kernel parameter. In order to be permanently set, it needs to be defined on the kernel command line.\n\n\nsudo nano /boot/cmdline.txt\n\n\n\n\n\nAdd \nconsoleblank=0\n to turn screen blanking off completely, or edit it to set the number of seconds of inactivity before the console will blank. Note the kernel command line must be a single line of text.\n\n\nOn the Desktop (PIXEL)\n\n\nBy default, PIXEL does not have any easy-to-use screensaver software installed, although the screensaver is enabled. Firstly, you should install the X Windows screensaver application.\n\n\nsudo apt-get install xscreensaver\n\n\n\n\n\nThis may take a few minutes.\n\n\nOnce this has been installed, you can find the screensaver application under the Preferences option on the main desktop menu. This provides many options for setting up the screensaver, or disabling it completely.",
            "title": "Setting the screen saver/screen blanking"
        },
        {
            "location": "/configuration/screensaver/index.html#setting-the-screen-saverscreen-blanking",
            "text": "",
            "title": "Setting the screen saver/screen blanking"
        },
        {
            "location": "/configuration/screensaver/index.html#on-the-console",
            "text": "If you are using the Raspberry Pi solely on the console (no desktop GUI), you need to set the console blanking. The current setting, in seconds, can be displayed using  cat /sys/module/kernel/parameters/consoleblank  Here,  consoleblank  is a kernel parameter. In order to be permanently set, it needs to be defined on the kernel command line.  sudo nano /boot/cmdline.txt  Add  consoleblank=0  to turn screen blanking off completely, or edit it to set the number of seconds of inactivity before the console will blank. Note the kernel command line must be a single line of text.",
            "title": "On the Console"
        },
        {
            "location": "/configuration/screensaver/index.html#on-the-desktop-pixel",
            "text": "By default, PIXEL does not have any easy-to-use screensaver software installed, although the screensaver is enabled. Firstly, you should install the X Windows screensaver application.  sudo apt-get install xscreensaver  This may take a few minutes.  Once this has been installed, you can find the screensaver application under the Preferences option on the main desktop menu. This provides many options for setting up the screensaver, or disabling it completely.",
            "title": "On the Desktop (PIXEL)"
        },
        {
            "location": "/configuration/security/index.html",
            "text": "Securing your Raspberry Pi\n\n\nThe security of your Raspberry Pi is important. Gaps in security leave your Raspberry Pi open to hackers who can then use it without your permission.\n\n\nWhat level of security you need depends on how you wish to use your Raspberry Pi. For example, if you are simply using your Raspberry Pi on your home network, behind a router with a firewall, then it is already quite secure by default.\n\n\nHowever, if you wish to expose your Raspberry Pi directly to the internet, either with a direct connection (unlikely) or by letting certain protocols through your router firewall (e.g. SSH), then you need to make some basic security changes.\n\n\nEven if you are hidden behind a firewall, it is sensible to take security seriously. This documentation will describe some ways of improving the security of your Raspberry Pi. Please note, though, that it is not exhaustive.\n\n\nChange your default password\n\n\nThe default username and password is used for every single Raspberry Pi running Raspbian. So, if you can get access to a Raspberry Pi, and these settings have not been changed, you have \nroot\n access to that Raspberry Pi.\n\n\nSo the first thing to do is change the password. This can be done via the raspi-config application, or from the command line.\n\n\nsudo raspi-config\n\n\n\n\n\nSelect option 2, and follow the instructions to change the password.\n\n\nIn fact, all raspi-config does is start up the command line \npasswd\n application, which you can do from the command line. Simply type in your new password and confirm it.\n\n\npasswd\n\n\n\n\n\nChanging your username\n\n\nYou can, of course, make your Raspberry Pi even more secure by also changing your username. All Raspberry Pis come with the default username \npi\n, so changing this will immediately make your Raspberry Pi more secure.\n\n\nTo add a new user with the same permissions as the \npi\n user:\n\n\nsudo useradd -m fred -G sudo\n\n\n\n\n\nThis adds a new user called \nfred\n, creates a home folder, and adds the user to the \nsudo\n group. You now need to set a password for the new user:\n\n\nsudo passwd fred\n\n\n\n\n\nLog out and log back with the new account details. Check your permissions are in place (i.e. you can sudo) by trying the following.\n\n\nsudo visudo\n\n\n\n\n\nThe \nvisudo\n command can only be run by an account with sudo privileges. If it runs successfully, then you can be sure that the new account is in the \nsudo\n group.\n\n\nOnce you have confirmed that the new account is working, you can delete the \npi\n user. Please note, though, that with the current Raspbian distribution, there are some aspects that require the \npi\n user to be present. If you are unsure whether you will be affected by this, then leave the \npi\n user in place. Work is being done to reduce the dependency on the \npi\n user.\n\n\nTo delete the \npi\n user, type the following: \n\n\nsudo deluser pi\n\n\n\n\n\nThis command will delete the \npi\n user but will leave the \nhome/pi\n folder. If necessary, you can use the command below to remove the home folder for the \npi\n user at the same time. Note the data in this folder will be permanently deleted, so make sure any required data is stored elsewhere.\n\n\nsudo deluser -remove-home pi\n\n\n\n\n\nMake \nsudo\n require a password\n\n\nPlacing \nsudo\n in front of a command runs it as a superuser, and by default, that does not need a password. In general, this is not a problem. However, if your Pi is exposed to the internet and somehow becomes exploited (perhaps via a webpage exploit for example), the attacker will be able to change things that require superuser credential, unless you have set \nsudo\n to require a password. \n\n\nTo force \nsudo\n to require a password, enter\n\n\nsudo nano /etc/sudoers.d/010_pi-nopasswd\n\n\n\n\n\nand change the \npi\n entry (or whichever usernames have superuser rights) to\n\n\npi ALL=(ALL) PASSWD: ALL\n\n\n\n\n\nNow save the file. \n\n\nEnsure you have the latest security fixes\n\n\nThis can be as simple as ensuring your version of Raspbian is up-to-date, as an up-to-date distribution contains all the latest security fixes. Full instructions can be found \nhere\n.\n\n\nIf you are using SSH to connect to your Raspberry Pi, it can be worthwhile to add a cron job that specifically updates the ssh-server. The following command, perhaps as a daily cron job, will ensure you have the latest SSH security fixes promptly, independent of your normal update process. More information on setting up cron can be found \nhere\n\n\napt-get install openssh-server\n\n\n\n\n\nImproving SSH security\n\n\nSSH is a common way of accessing a Raspberry Pi remotely. By default, logging in with SSH requires a username/password pair, and there are ways to make this more secure. An even more secure method is to use key based authentication.\n\n\nImproving username/password security\n\n\nThe most important thing to do is ensure you have a very robust password. If your Raspberry Pi is exposed to the internet, the password needs to be very secure. This will help to avoid dictionary attacks or the like.\n\n\nYou can also \nallow\n or \ndeny\n specific users by altering the \nsshd\n configuration.\n\n\nsudo nano /etc/ssh/sshd_config\n\n\n\n\n\nAdd, edit, or append to the end of the file the following line, which contains the usernames you wish to allow to log in:\n\n\nAllowUsers edward andrew charles anne\n\n\n\n\n\nYou can also use DenyUsers to specifically stop some usernames from logging in:\n\n\nDenyUsers harry william\n\n\n\n\n\nAfter the change you will need to restart the \nsshd\n service using \nsudo systemctl restart ssh\n or reboot so the changes take effect.\n\n\nUsing key-based authentication.\n\n\nKey pairs are two cryptographically secure keys. One is private, and one is public. They can be used to authenticate a client to an SSH server (in this case the Raspberry Pi). \n\n\nThe client generates two keys, which are cryptographically linked to each other. The private key should never be released, but the public key can be freely shared. The SSH server takes a copy of the public key, and, when a link is requested, uses this key to send the client a challenge message, which the client will encrypt using the private key. If the server can use the public key to decrypt this message back to the original challenge message, then the identity of the client can be confirmed. \n\n\nGenerating a key pair in Linux is done using the \nssh-keygen\n command on the \nclient\n; the keys are stored by default in the \n.ssh\n folder in the user's home directly. The private key will be called \nid_rsa\n and the associated public key will be called \nid_rsa.pub\n. The key will be 2048 bits long: breaking the encryption on a key of that length would take an extremely long time, so is very secure. You can make longer keys if the situation demands it. Note that you should only do the generation process once: if repeated, it will overwrite any previous generated keys. Anything relying on those old keys will need to be updated to the new keys. \n\n\nYou will be prompted for a passphrase during key generation: this is an extra level of security. For the moment, leave this blank.\n\n\nThe public key now needs to be moved on to the server. This can be done by email, or cut and paste, or file copying. Once on the server it needs to be added to the SSH systems authorised keys. It should be emphasised that the \nid_rsa\n file is the private key and SHOULD NOT LEAVE THE CLIENT, whilst the public key file is \nid_rsa.pub\n.\n\n\nAdd the new public key to the authorisation file as follows:\n\n\ncat id_rsa.pub >> ~/.ssh/authorized_keys\n\n\n\n\n\nAlternatively, you can edit the file \nsudo nano ~/.ssh/authorized_keys\n and copy/paste the key in. It is perfectly acceptable to have multiple entries in the authorized_keys file, so SSH can support multiple clients.\n\n\nNote that the authorized_keys file needs the correct permissions to be read correctly by the \nssh\n system.\n\n\nsudo chmod 644 ~/.ssh/authorized_keys\n\n\n\n\n\nFinally, we need to disable password logins, so that all authentication is done by the key pairs.\n\n\nsudo nano /etc/ssh/sshd_config\n\n\n\n\n\nThere are three lines that need to be changed to \nno\n, if they are not set that way already:\n\n\nChallengeResponseAuthentication no\nPasswordAuthentication no\nUsePAM no\n\n\n\n\n\nSave the file and either restart the ssh system with \nsudo service ssh reload\n or reboot.\n\n\nInstall a firewall\n\n\nThere are many firewall solutions available for Linux. Most use the underlying \niptables\n project to provide packet filtering. This project sits over the Linux netfiltering system. \niptables\n is installed by default on Raspbian, but is not set up. Setting it up can be a complicated task, and one project that provides a simpler interface than \niptables\n is \nufw\n, which stands for 'Uncomplicated Fire Wall'. This is the default firewall tool in Ubuntu, and can be easily installed on your Raspberry Pi: \n\n\nsudo apt-get install ufw\n\n\n\n\n\nufw\n is a fairly straightforward command line tool, although there are some GUIs available for it. This document will describe a few of the basic command line options. Note that \nufw\n needs to be run with superuser privileges, so all commands are preceded with \nsudo\n. It is also possible to use the option \n--dry-run\n any \nufw\n commands, which indicates the results of the command without actually making any changes.\n\n\nTo enable the firewall, which will also ensure it starts up on boot, use:\n\n\nsudo ufw enable\n\n\n\n\n\nTo disable the firewall, and disable start up on boot, use: \n\n\nsudo ufw disable\n\n\n\n\n\nAllow a particular port to have access (we have used port 22 in our example):\n\n\nsudo ufw allow 22\n\n\n\n\n\nDenying access on a port is also very simple (again, we have used port 22 as an example):\n\n\nsudo ufw deny 22\n\n\n\n\n\nYou can also specify which service you are allowing or denying on a port. In this example, we are denying tcp on port 22:\n\n\nsudo ufw deny 22/tcp\n\n\n\n\n\nYou can specify the service even if you do not know which port it uses. This example allows the ssh service access through the firewall:\n\n\nsudo ufw allow ssh\n\n\n\n\n\nThe status command lists all current settings for the firewall:\n\n\nsudo ufw status\n\n\n\n\n\nThe rules can be quite complicated, allowing specific IP addresses to be blocked, specifying in which direction traffic is allowed, or limiting the number of attempts to connect, for example to help defeat a Denial of Service (DoS) attack. You can also specify the device rules are to be applied to (e.g. eth0, wlan0). Please refer to the \nufw\n man page (\nman ufw\n) for full details, but here are some examples of more sophisticated commands.\n\n\nLimit login attempts on ssh port using tcp: this denies connection if an IP address has attempted to connect six or more times in the last 30 seconds: \n\n\nsudo ufw limit ssh/tcp\n\n\n\n\n\nDeny access to port 30 from IP address 192.168.2.1\n\n\nsudo ufw deny from 192.168.2.1 port 30\n\n\n\n\n\nInstalling fail2ban\n\n\nIf you are using your Raspberry Pi as some sort of server, for example an \nssh\n or webserver, your firewall will have deliberate 'holes' in it to let the server traffic through. In these cases, \nFail2ban\n can be useful. Fail2ban, written in Python, is a scanner that examines the log files produced by the Raspberry Pi, and checks them for suspicious activity. It catches things like multiple brute-force attempts to log in, and can inform any installed firewall to stop further login attempts from suspicious IP addresses. It saves you having to manually check log files for intrusion attempts and then update the firewall (via \niptables\n) to prevent them.\n\n\nInstall Fail2ban using the following command:\n\n\nsudo apt-get install fail2ban\n\n\n\n\n\nNote that the version of Fail2ban in the repository (v0.8.13) does not support IPv6 networks. If you use IPv6, you will need to install version v0.10 or higher from source. Please see the \nFail2ban\n website for more information on how to do this.\n\n\nOn installation, Fail2ban creates a folder \n/etc/fail2ban\n in which there is a configuration file called \njail.conf\n. This needs to be copied to \njail.local\n to enable it. Inside this configuration file are a set of default options, together with options for checking specific services for abnormalities. Do the following to examine/change the rules that are used for \nssh\n:\n\n\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\nsudo nano /etc/fail2ban/jail.local\n\n\n\n\n\nLook for the section on \n[ssh]\n. It will look something like this.\n\n\n[ssh]\n\n\nenabled\n  \n=\n \ntrue\n\n\nport\n     \n=\n \nssh\n\n\nfilter\n   \n=\n \nsshd\n\n\nlogpath\n  \n=\n \n/var/log/auth.log\n\n\nmaxretry\n \n=\n \n6\n\n\n\n\n\n\nAs you can see, this section is named ssh, is enabled, examines the ssh port, filters using the \n\\etc\\fail2ban\\filters.d\\sshd.conf\n parameters, parses the /var/log/auth.log for malicious activity, and allows six retries before the detection threshold is reached. Checking the default section, we can see that the default banning action is:\n\n\n# Default banning action (e.g. iptables, iptables-new,\n# iptables-multiport, shorewall, etc) It is used to define\n# action_* variables. Can be overridden globally or per\n# section within jail.local file\nbanaction = iptables-multiport\n\n\n\n\n\niptables-multiport\n means that the Fail2ban system will run the \n/etc/fail2ban/action.d/iptables-multiport.conf\n file when the detection threshold is reached. There are a number of different action configuration files that can be used. Multiport bans all access on all ports.\n\n\nIf you want to permanently ban an IP address after three failed attempts, you can change the maxretry value in the \n[ssh]\n section, and set the bantime to a negative number:\n\n\n[ssh]\n\n\nenabled\n  \n=\n \ntrue\n\n\nport\n     \n=\n \nssh\n\n\nfilter\n   \n=\n \nsshd\n\n\nlogpath\n  \n=\n \n/var/log/auth.log\n\n\nmaxretry\n \n=\n \n3 \n\n\nbantime\n \n=\n \n-1\n\n\n\n\n\n\nThere is a good tutorial on some of the internals of Fail2ban \nhere\n.",
            "title": "Securing your Raspberry Pi"
        },
        {
            "location": "/configuration/security/index.html#securing-your-raspberry-pi",
            "text": "The security of your Raspberry Pi is important. Gaps in security leave your Raspberry Pi open to hackers who can then use it without your permission.  What level of security you need depends on how you wish to use your Raspberry Pi. For example, if you are simply using your Raspberry Pi on your home network, behind a router with a firewall, then it is already quite secure by default.  However, if you wish to expose your Raspberry Pi directly to the internet, either with a direct connection (unlikely) or by letting certain protocols through your router firewall (e.g. SSH), then you need to make some basic security changes.  Even if you are hidden behind a firewall, it is sensible to take security seriously. This documentation will describe some ways of improving the security of your Raspberry Pi. Please note, though, that it is not exhaustive.",
            "title": "Securing your Raspberry Pi"
        },
        {
            "location": "/configuration/security/index.html#change-your-default-password",
            "text": "The default username and password is used for every single Raspberry Pi running Raspbian. So, if you can get access to a Raspberry Pi, and these settings have not been changed, you have  root  access to that Raspberry Pi.  So the first thing to do is change the password. This can be done via the raspi-config application, or from the command line.  sudo raspi-config  Select option 2, and follow the instructions to change the password.  In fact, all raspi-config does is start up the command line  passwd  application, which you can do from the command line. Simply type in your new password and confirm it.  passwd",
            "title": "Change your default password"
        },
        {
            "location": "/configuration/security/index.html#changing-your-username",
            "text": "You can, of course, make your Raspberry Pi even more secure by also changing your username. All Raspberry Pis come with the default username  pi , so changing this will immediately make your Raspberry Pi more secure.  To add a new user with the same permissions as the  pi  user:  sudo useradd -m fred -G sudo  This adds a new user called  fred , creates a home folder, and adds the user to the  sudo  group. You now need to set a password for the new user:  sudo passwd fred  Log out and log back with the new account details. Check your permissions are in place (i.e. you can sudo) by trying the following.  sudo visudo  The  visudo  command can only be run by an account with sudo privileges. If it runs successfully, then you can be sure that the new account is in the  sudo  group.  Once you have confirmed that the new account is working, you can delete the  pi  user. Please note, though, that with the current Raspbian distribution, there are some aspects that require the  pi  user to be present. If you are unsure whether you will be affected by this, then leave the  pi  user in place. Work is being done to reduce the dependency on the  pi  user.  To delete the  pi  user, type the following:   sudo deluser pi  This command will delete the  pi  user but will leave the  home/pi  folder. If necessary, you can use the command below to remove the home folder for the  pi  user at the same time. Note the data in this folder will be permanently deleted, so make sure any required data is stored elsewhere.  sudo deluser -remove-home pi",
            "title": "Changing your username"
        },
        {
            "location": "/configuration/security/index.html#make-sudo-require-a-password",
            "text": "Placing  sudo  in front of a command runs it as a superuser, and by default, that does not need a password. In general, this is not a problem. However, if your Pi is exposed to the internet and somehow becomes exploited (perhaps via a webpage exploit for example), the attacker will be able to change things that require superuser credential, unless you have set  sudo  to require a password.   To force  sudo  to require a password, enter  sudo nano /etc/sudoers.d/010_pi-nopasswd  and change the  pi  entry (or whichever usernames have superuser rights) to  pi ALL=(ALL) PASSWD: ALL  Now save the file.",
            "title": "Make sudo require a password"
        },
        {
            "location": "/configuration/security/index.html#ensure-you-have-the-latest-security-fixes",
            "text": "This can be as simple as ensuring your version of Raspbian is up-to-date, as an up-to-date distribution contains all the latest security fixes. Full instructions can be found  here .  If you are using SSH to connect to your Raspberry Pi, it can be worthwhile to add a cron job that specifically updates the ssh-server. The following command, perhaps as a daily cron job, will ensure you have the latest SSH security fixes promptly, independent of your normal update process. More information on setting up cron can be found  here  apt-get install openssh-server",
            "title": "Ensure you have the latest security fixes"
        },
        {
            "location": "/configuration/security/index.html#improving-ssh-security",
            "text": "SSH is a common way of accessing a Raspberry Pi remotely. By default, logging in with SSH requires a username/password pair, and there are ways to make this more secure. An even more secure method is to use key based authentication.",
            "title": "Improving SSH security"
        },
        {
            "location": "/configuration/security/index.html#improving-usernamepassword-security",
            "text": "The most important thing to do is ensure you have a very robust password. If your Raspberry Pi is exposed to the internet, the password needs to be very secure. This will help to avoid dictionary attacks or the like.  You can also  allow  or  deny  specific users by altering the  sshd  configuration.  sudo nano /etc/ssh/sshd_config  Add, edit, or append to the end of the file the following line, which contains the usernames you wish to allow to log in:  AllowUsers edward andrew charles anne  You can also use DenyUsers to specifically stop some usernames from logging in:  DenyUsers harry william  After the change you will need to restart the  sshd  service using  sudo systemctl restart ssh  or reboot so the changes take effect.",
            "title": "Improving username/password security"
        },
        {
            "location": "/configuration/security/index.html#using-key-based-authentication",
            "text": "Key pairs are two cryptographically secure keys. One is private, and one is public. They can be used to authenticate a client to an SSH server (in this case the Raspberry Pi).   The client generates two keys, which are cryptographically linked to each other. The private key should never be released, but the public key can be freely shared. The SSH server takes a copy of the public key, and, when a link is requested, uses this key to send the client a challenge message, which the client will encrypt using the private key. If the server can use the public key to decrypt this message back to the original challenge message, then the identity of the client can be confirmed.   Generating a key pair in Linux is done using the  ssh-keygen  command on the  client ; the keys are stored by default in the  .ssh  folder in the user's home directly. The private key will be called  id_rsa  and the associated public key will be called  id_rsa.pub . The key will be 2048 bits long: breaking the encryption on a key of that length would take an extremely long time, so is very secure. You can make longer keys if the situation demands it. Note that you should only do the generation process once: if repeated, it will overwrite any previous generated keys. Anything relying on those old keys will need to be updated to the new keys.   You will be prompted for a passphrase during key generation: this is an extra level of security. For the moment, leave this blank.  The public key now needs to be moved on to the server. This can be done by email, or cut and paste, or file copying. Once on the server it needs to be added to the SSH systems authorised keys. It should be emphasised that the  id_rsa  file is the private key and SHOULD NOT LEAVE THE CLIENT, whilst the public key file is  id_rsa.pub .  Add the new public key to the authorisation file as follows:  cat id_rsa.pub >> ~/.ssh/authorized_keys  Alternatively, you can edit the file  sudo nano ~/.ssh/authorized_keys  and copy/paste the key in. It is perfectly acceptable to have multiple entries in the authorized_keys file, so SSH can support multiple clients.  Note that the authorized_keys file needs the correct permissions to be read correctly by the  ssh  system.  sudo chmod 644 ~/.ssh/authorized_keys  Finally, we need to disable password logins, so that all authentication is done by the key pairs.  sudo nano /etc/ssh/sshd_config  There are three lines that need to be changed to  no , if they are not set that way already:  ChallengeResponseAuthentication no\nPasswordAuthentication no\nUsePAM no  Save the file and either restart the ssh system with  sudo service ssh reload  or reboot.",
            "title": "Using key-based authentication."
        },
        {
            "location": "/configuration/security/index.html#install-a-firewall",
            "text": "There are many firewall solutions available for Linux. Most use the underlying  iptables  project to provide packet filtering. This project sits over the Linux netfiltering system.  iptables  is installed by default on Raspbian, but is not set up. Setting it up can be a complicated task, and one project that provides a simpler interface than  iptables  is  ufw , which stands for 'Uncomplicated Fire Wall'. This is the default firewall tool in Ubuntu, and can be easily installed on your Raspberry Pi:   sudo apt-get install ufw  ufw  is a fairly straightforward command line tool, although there are some GUIs available for it. This document will describe a few of the basic command line options. Note that  ufw  needs to be run with superuser privileges, so all commands are preceded with  sudo . It is also possible to use the option  --dry-run  any  ufw  commands, which indicates the results of the command without actually making any changes.  To enable the firewall, which will also ensure it starts up on boot, use:  sudo ufw enable  To disable the firewall, and disable start up on boot, use:   sudo ufw disable  Allow a particular port to have access (we have used port 22 in our example):  sudo ufw allow 22  Denying access on a port is also very simple (again, we have used port 22 as an example):  sudo ufw deny 22  You can also specify which service you are allowing or denying on a port. In this example, we are denying tcp on port 22:  sudo ufw deny 22/tcp  You can specify the service even if you do not know which port it uses. This example allows the ssh service access through the firewall:  sudo ufw allow ssh  The status command lists all current settings for the firewall:  sudo ufw status  The rules can be quite complicated, allowing specific IP addresses to be blocked, specifying in which direction traffic is allowed, or limiting the number of attempts to connect, for example to help defeat a Denial of Service (DoS) attack. You can also specify the device rules are to be applied to (e.g. eth0, wlan0). Please refer to the  ufw  man page ( man ufw ) for full details, but here are some examples of more sophisticated commands.  Limit login attempts on ssh port using tcp: this denies connection if an IP address has attempted to connect six or more times in the last 30 seconds:   sudo ufw limit ssh/tcp  Deny access to port 30 from IP address 192.168.2.1  sudo ufw deny from 192.168.2.1 port 30",
            "title": "Install a firewall"
        },
        {
            "location": "/configuration/security/index.html#installing-fail2ban",
            "text": "If you are using your Raspberry Pi as some sort of server, for example an  ssh  or webserver, your firewall will have deliberate 'holes' in it to let the server traffic through. In these cases,  Fail2ban  can be useful. Fail2ban, written in Python, is a scanner that examines the log files produced by the Raspberry Pi, and checks them for suspicious activity. It catches things like multiple brute-force attempts to log in, and can inform any installed firewall to stop further login attempts from suspicious IP addresses. It saves you having to manually check log files for intrusion attempts and then update the firewall (via  iptables ) to prevent them.  Install Fail2ban using the following command:  sudo apt-get install fail2ban  Note that the version of Fail2ban in the repository (v0.8.13) does not support IPv6 networks. If you use IPv6, you will need to install version v0.10 or higher from source. Please see the  Fail2ban  website for more information on how to do this.  On installation, Fail2ban creates a folder  /etc/fail2ban  in which there is a configuration file called  jail.conf . This needs to be copied to  jail.local  to enable it. Inside this configuration file are a set of default options, together with options for checking specific services for abnormalities. Do the following to examine/change the rules that are used for  ssh :  sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\nsudo nano /etc/fail2ban/jail.local  Look for the section on  [ssh] . It will look something like this.  [ssh]  enabled    =   true  port       =   ssh  filter     =   sshd  logpath    =   /var/log/auth.log  maxretry   =   6   As you can see, this section is named ssh, is enabled, examines the ssh port, filters using the  \\etc\\fail2ban\\filters.d\\sshd.conf  parameters, parses the /var/log/auth.log for malicious activity, and allows six retries before the detection threshold is reached. Checking the default section, we can see that the default banning action is:  # Default banning action (e.g. iptables, iptables-new,\n# iptables-multiport, shorewall, etc) It is used to define\n# action_* variables. Can be overridden globally or per\n# section within jail.local file\nbanaction = iptables-multiport  iptables-multiport  means that the Fail2ban system will run the  /etc/fail2ban/action.d/iptables-multiport.conf  file when the detection threshold is reached. There are a number of different action configuration files that can be used. Multiport bans all access on all ports.  If you want to permanently ban an IP address after three failed attempts, you can change the maxretry value in the  [ssh]  section, and set the bantime to a negative number:  [ssh]  enabled    =   true  port       =   ssh  filter     =   sshd  logpath    =   /var/log/auth.log  maxretry   =   3   bantime   =   -1   There is a good tutorial on some of the internals of Fail2ban  here .",
            "title": "Installing fail2ban"
        },
        {
            "location": "/configuration/uart/index.html",
            "text": "The Raspberry Pi UARTs\n\n\nThe SoCs used on the Raspberry Pis have two built-in UARTs, a \nPL011\n and a mini UART. They are implemented using different hardware blocks, so they have slightly different characteristics. However, both are 3.3V devices, which means extra care must be taken when connecting up to an RS232 or other system that utilises different voltage levels. An adapter must be used to convert the voltage levels between the two protocols. Alternatively, 3.3V USB UART adapters can be purchased for very low prices. \n\n\nBy default, on Raspberry Pis equipped with the wireless/Bluetooth module (Raspberry Pi 3 and Raspberry Pi Zero W), the PL011 UART is connected to the BT module, while the mini UART is used for Linux console output. On all other models the PL011 is used for the Linux console output. \n\n\nIn Linux device terms, by default, /dev/ttyS0 refers to the mini UART, and /dev/ttyAMA0 refers to the PL011. The primary UART is that assigned to the Linux console, which depends on the Raspberry Pi model as described above, and can be accessed via /dev/serial0.\n\n\nMini UART and CPU core frequency\n\n\nThe baud rate of the mini UART is linked to the core frequency of the VPU on the VC4 GPU. This means that as the VPU frequency governor varies the core frequency, the baud rate of the UART also changes. This makes the UART of limited use in the default state. Also, when the Linux console uses the mini UART (Raspberry Pi 3, Raspberry Pi Zero W), as a consequence of the UART being disabled, the console is also disabled.\n\n\nThe Linux console can be re-enabled by adding \nenable_uart=1\n to config.txt. This also fixes the core_freq to 250Mhz (unless force_turbo is set, when it will fixed to 400Mhz), which means that the UART baud rate stays consistent. \n\n\nThe default value of the \nenable_uart\n flag depends on the actual roles of the UARTs, so that if ttyAMA0 is assigned to the BT module, \nenable_uart\n defaults to 0. If the mini UART is assigned to the BT module, then \nenable_uart\n defaults to 1. Note that if the UARTs are reassigned using a Device Tree Overlay (see below), \nenable_uart\n defaults will still obey this rule.\n\n\nDisabling Linux's use of console UART\n\n\nIn a default install of Raspbian, the primary UART (serial0) is assigned to the Linux console. Using the serial port for other purposes requires this default behaviour to be changed. On startup, \nsystemd\n checks the Linux kernel command line for any console entries, and will use the console defined therein. To stop this behaviour, the serial console setting needs to be removed from command line.\n\n\nThis can be done by using the \nraspi-config\n utility, or manually.\n\n\nsudo raspi-config\n\n\n\n\n\nSelect option 5, \nInterfacing options\n, then option P6, \nSerial\n, and select \nNo\n. Exit raspi-config.\n\n\nTo manually change the settings, edit the kernel command line with \nsudo nano /boot/cmdline.txt\n. Find the console entry that refers to the serial0 device, and remove it, including the baud rate setting. It will look something like \nconsole=serial0,115200\n. Make sure the rest of the line remains the same, as errors in this configuration can stop the Raspberry Pi from booting.\n\n\nReboot the Raspberry Pi for the change to take effect.\n\n\nUART output on GPIO pins\n\n\nBy default, the UART transmit and receive pins are on GPIO 14 and GPIO 15 respectively, which are pins 8 and 10 on the GPIO header.\n\n\nUARTs and Device Tree\n\n\nVarious UART Device Tree Overlay definitions can be found in the kernel github tree. The two most useful overlays are \npi3-disable-bt\n and \npi3-miniuart-bt\n.\n\n\npi3-disable-bt\n disables the Bluetooth device and restores UART0/ttyAMA0 to GPIOs 14 and 15. It is also necessary to disable the system service that initialises the modem so it doesn't use the UART: \nsudo systemctl disable hciuart\n.\n\n\npi3-miniuart-bt\n switches the Raspberry Pi 3 and Raspberry Pi Zero W Bluetooth function to use the mini UART (ttyS0), and restores UART0/ttyAMA0 to GPIOs 14 and 15. Note that this may reduce the maximum usable baudrate (see mini UART limitations below). It is also necessary to edit /lib/systemd/system/hciuart.service and replace ttyAMA0 with ttyS0, unless you have a system with udev rules that create /dev/serial0 and /dev/serial1. In this case, use /dev/serial1 instead because it will always be correct. If cmdline.txt uses the alias serial0 to refer to the user-accessible port, the firmware will replace it with the appropriate port whether or not this overlay is used.\n\n\nThere are other UART-specific overlays in the folder. Refer to \n/boot/overlays/README\n for details on Device Tree Overlays, or run \ndtoverlay -h overlay-name\n for descriptions and usage information.\n\n\nFor full instructions on how to use Device Tree Overlays see \nthis page\n. In brief, add a line to the \nconfig.txt\n file to enable Device Tree Overlays. Note that the \n-overlay.dts\n part of the filename is removed.\n\n\n...\ndtoverlay=pi3-disable-bt\n...\n\n\n\n\n\nRelevant differences between PL011 and mini UART\n\n\nThe mini UART has smaller FIFOs. Combined with the lack of flow control, this makes it more prone to losing characters at higher baudrates. It is also generally less capable than the PL011, mainly due to its baud rate link to the VPU clock speed.\n\n\nThe particular deficiencies of the mini UART compared to the PL011 are :\n- No break detection\n- No framing errors detection\n- No parity bit\n- No receive timeout interrupt\n- No DCD, DSR, DTR or RI signals \n\n\nFurther documentation on the mini UART can be found in the SoC peripherals document \nhere\n.",
            "title": "The Raspberry Pi UARTs"
        },
        {
            "location": "/configuration/uart/index.html#the-raspberry-pi-uarts",
            "text": "The SoCs used on the Raspberry Pis have two built-in UARTs, a  PL011  and a mini UART. They are implemented using different hardware blocks, so they have slightly different characteristics. However, both are 3.3V devices, which means extra care must be taken when connecting up to an RS232 or other system that utilises different voltage levels. An adapter must be used to convert the voltage levels between the two protocols. Alternatively, 3.3V USB UART adapters can be purchased for very low prices.   By default, on Raspberry Pis equipped with the wireless/Bluetooth module (Raspberry Pi 3 and Raspberry Pi Zero W), the PL011 UART is connected to the BT module, while the mini UART is used for Linux console output. On all other models the PL011 is used for the Linux console output.   In Linux device terms, by default, /dev/ttyS0 refers to the mini UART, and /dev/ttyAMA0 refers to the PL011. The primary UART is that assigned to the Linux console, which depends on the Raspberry Pi model as described above, and can be accessed via /dev/serial0.",
            "title": "The Raspberry Pi UARTs"
        },
        {
            "location": "/configuration/uart/index.html#mini-uart-and-cpu-core-frequency",
            "text": "The baud rate of the mini UART is linked to the core frequency of the VPU on the VC4 GPU. This means that as the VPU frequency governor varies the core frequency, the baud rate of the UART also changes. This makes the UART of limited use in the default state. Also, when the Linux console uses the mini UART (Raspberry Pi 3, Raspberry Pi Zero W), as a consequence of the UART being disabled, the console is also disabled.  The Linux console can be re-enabled by adding  enable_uart=1  to config.txt. This also fixes the core_freq to 250Mhz (unless force_turbo is set, when it will fixed to 400Mhz), which means that the UART baud rate stays consistent.   The default value of the  enable_uart  flag depends on the actual roles of the UARTs, so that if ttyAMA0 is assigned to the BT module,  enable_uart  defaults to 0. If the mini UART is assigned to the BT module, then  enable_uart  defaults to 1. Note that if the UARTs are reassigned using a Device Tree Overlay (see below),  enable_uart  defaults will still obey this rule.",
            "title": "Mini UART and CPU core frequency"
        },
        {
            "location": "/configuration/uart/index.html#disabling-linuxs-use-of-console-uart",
            "text": "In a default install of Raspbian, the primary UART (serial0) is assigned to the Linux console. Using the serial port for other purposes requires this default behaviour to be changed. On startup,  systemd  checks the Linux kernel command line for any console entries, and will use the console defined therein. To stop this behaviour, the serial console setting needs to be removed from command line.  This can be done by using the  raspi-config  utility, or manually.  sudo raspi-config  Select option 5,  Interfacing options , then option P6,  Serial , and select  No . Exit raspi-config.  To manually change the settings, edit the kernel command line with  sudo nano /boot/cmdline.txt . Find the console entry that refers to the serial0 device, and remove it, including the baud rate setting. It will look something like  console=serial0,115200 . Make sure the rest of the line remains the same, as errors in this configuration can stop the Raspberry Pi from booting.  Reboot the Raspberry Pi for the change to take effect.",
            "title": "Disabling Linux's use of console UART"
        },
        {
            "location": "/configuration/uart/index.html#uart-output-on-gpio-pins",
            "text": "By default, the UART transmit and receive pins are on GPIO 14 and GPIO 15 respectively, which are pins 8 and 10 on the GPIO header.",
            "title": "UART output on GPIO pins"
        },
        {
            "location": "/configuration/uart/index.html#uarts-and-device-tree",
            "text": "Various UART Device Tree Overlay definitions can be found in the kernel github tree. The two most useful overlays are  pi3-disable-bt  and  pi3-miniuart-bt .  pi3-disable-bt  disables the Bluetooth device and restores UART0/ttyAMA0 to GPIOs 14 and 15. It is also necessary to disable the system service that initialises the modem so it doesn't use the UART:  sudo systemctl disable hciuart .  pi3-miniuart-bt  switches the Raspberry Pi 3 and Raspberry Pi Zero W Bluetooth function to use the mini UART (ttyS0), and restores UART0/ttyAMA0 to GPIOs 14 and 15. Note that this may reduce the maximum usable baudrate (see mini UART limitations below). It is also necessary to edit /lib/systemd/system/hciuart.service and replace ttyAMA0 with ttyS0, unless you have a system with udev rules that create /dev/serial0 and /dev/serial1. In this case, use /dev/serial1 instead because it will always be correct. If cmdline.txt uses the alias serial0 to refer to the user-accessible port, the firmware will replace it with the appropriate port whether or not this overlay is used.  There are other UART-specific overlays in the folder. Refer to  /boot/overlays/README  for details on Device Tree Overlays, or run  dtoverlay -h overlay-name  for descriptions and usage information.  For full instructions on how to use Device Tree Overlays see  this page . In brief, add a line to the  config.txt  file to enable Device Tree Overlays. Note that the  -overlay.dts  part of the filename is removed.  ...\ndtoverlay=pi3-disable-bt\n...",
            "title": "UARTs and Device Tree"
        },
        {
            "location": "/configuration/uart/index.html#relevant-differences-between-pl011-and-mini-uart",
            "text": "The mini UART has smaller FIFOs. Combined with the lack of flow control, this makes it more prone to losing characters at higher baudrates. It is also generally less capable than the PL011, mainly due to its baud rate link to the VPU clock speed.  The particular deficiencies of the mini UART compared to the PL011 are :\n- No break detection\n- No framing errors detection\n- No parity bit\n- No receive timeout interrupt\n- No DCD, DSR, DTR or RI signals   Further documentation on the mini UART can be found in the SoC peripherals document  here .",
            "title": "Relevant differences between PL011 and mini UART"
        },
        {
            "location": "/configuration/warning-icons/index.html",
            "text": "Firmware warning icons\n\n\nUnder certain circumstances, the Raspberry Pi firmware will display a warning icon on the display, to indicate an issue.\n\n\nThere are currently three icons that can be displayed.\n\n\nUndervoltage warning\n\n\nIf the power supply to the Raspberry Pi drops below 4.63V (+/-5%), the following icon is displayed.\n\n\n\n\nOver temperature warning (80-85C)\n\n\nIf the temperature of the SoC is between 80C and 85C, the following icon is displayed. The ARM core(s) will be throttled back in an attempt to reduce the core temperature.\n\n\n\n\nOver temperature warning (over 85C)\n\n\nIf the temperature of the SoC is over 85C, the following icon is displayed. The ARM core(s) and the GPU will be throttled back in an attempt to reduce the core temperature.",
            "title": "Firmware warning icons"
        },
        {
            "location": "/configuration/warning-icons/index.html#firmware-warning-icons",
            "text": "Under certain circumstances, the Raspberry Pi firmware will display a warning icon on the display, to indicate an issue.  There are currently three icons that can be displayed.",
            "title": "Firmware warning icons"
        },
        {
            "location": "/configuration/warning-icons/index.html#undervoltage-warning",
            "text": "If the power supply to the Raspberry Pi drops below 4.63V (+/-5%), the following icon is displayed.",
            "title": "Undervoltage warning"
        },
        {
            "location": "/configuration/warning-icons/index.html#over-temperature-warning-80-85c",
            "text": "If the temperature of the SoC is between 80C and 85C, the following icon is displayed. The ARM core(s) will be throttled back in an attempt to reduce the core temperature.",
            "title": "Over temperature warning (80-85C)"
        },
        {
            "location": "/configuration/warning-icons/index.html#over-temperature-warning-over-85c",
            "text": "If the temperature of the SoC is over 85C, the following icon is displayed. The ARM core(s) and the GPU will be throttled back in an attempt to reduce the core temperature.",
            "title": "Over temperature warning (over 85C)"
        },
        {
            "location": "/configuration/config-txt/README/index.html",
            "text": "config.txt\n\n\nThe Raspberry Pi uses a configuration file instead of the \nBIOS\n you would expect to find on a conventional PC. The system configuration parameters, which would traditionally be edited and stored using a BIOS, are stored instead in an optional text file named \nconfig.txt\n. This is read by the GPU before the ARM CPU and Linux are initialised. It must therefore be located on the first (boot) partition of your SD card, alongside \nbootcode.bin\n and \nstart.elf\n. This file is normally accessible as \n/boot/config.txt\n from Linux, and must be edited as \nroot\n. From Windows or OS X it is visible as a file in the only accessible part of the card. If you need to apply some of the config settings below, but you don't have a \nconfig.txt\n on your boot partition yet, simply create it as a new text file.\n\n\nAny changes will only take effect after you have rebooted your Raspberry Pi. After Linux has booted, you can view the current active settings using the following commands:\n\n\n\n\n\n\nvcgencmd get_config <config>\n: this displays a specific config value, e.g. \nvcgencmd get_config arm_freq\n.\n\n\n\n\n\n\nvcgencmd get_config int\n: this lists all the integer config options that are set (non-zero).\n\n\n\n\n\n\nvcgencmd get_config str\n: this lists all the string config options that are set (non-null).\n\n\n\n\n\n\nNote that there are a few config settings that cannot be retrieved using \nvcgencmd\n.\n\n\nFile format\n\n\nThe \nconfig.txt\n file is read by the early-stage boot firmware, so it has a very simple file format. The format is a single \nproperty=value\n statement on each line, where \nvalue\n is either an integer or a string. Comments may be added, or existing config values may be commented out and disabled, by starting a line with the \n#\n character.\n\n\nHere is an example file:\n\n\n# Force the monitor to HDMI mode so that sound will be sent over HDMI cable\nhdmi_drive=2\n# Set monitor mode to DMT\nhdmi_group=2\n# Set monitor resolution to 1024x768 XGA 60Hz (HDMI_DMT_XGA_60)\nhdmi_mode=16\n# Make display smaller to stop text spilling off the screen\noverscan_left=20\noverscan_right=12\noverscan_top=10\noverscan_bottom=10\n\n\n\n\n\nconfig.txt Options\n\n\nA range of options can be specified using the config.txt file. These are split into different sections, indexed below:\n\n\n\n\nMemory\n\n\nLicence Keys/Codecs\n\n\nVideo/Display\n\n\nAudio\n\n\nCamera\n\n\nBoot\n\n\nPorts and Device Tree\n\n\nOverclocking\n\n\nConditional Filters\n\n\nMiscellaneous\n\n\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "config.txt"
        },
        {
            "location": "/configuration/config-txt/README/index.html#configtxt",
            "text": "The Raspberry Pi uses a configuration file instead of the  BIOS  you would expect to find on a conventional PC. The system configuration parameters, which would traditionally be edited and stored using a BIOS, are stored instead in an optional text file named  config.txt . This is read by the GPU before the ARM CPU and Linux are initialised. It must therefore be located on the first (boot) partition of your SD card, alongside  bootcode.bin  and  start.elf . This file is normally accessible as  /boot/config.txt  from Linux, and must be edited as  root . From Windows or OS X it is visible as a file in the only accessible part of the card. If you need to apply some of the config settings below, but you don't have a  config.txt  on your boot partition yet, simply create it as a new text file.  Any changes will only take effect after you have rebooted your Raspberry Pi. After Linux has booted, you can view the current active settings using the following commands:    vcgencmd get_config <config> : this displays a specific config value, e.g.  vcgencmd get_config arm_freq .    vcgencmd get_config int : this lists all the integer config options that are set (non-zero).    vcgencmd get_config str : this lists all the string config options that are set (non-null).    Note that there are a few config settings that cannot be retrieved using  vcgencmd .",
            "title": "config.txt"
        },
        {
            "location": "/configuration/config-txt/README/index.html#file-format",
            "text": "The  config.txt  file is read by the early-stage boot firmware, so it has a very simple file format. The format is a single  property=value  statement on each line, where  value  is either an integer or a string. Comments may be added, or existing config values may be commented out and disabled, by starting a line with the  #  character.  Here is an example file:  # Force the monitor to HDMI mode so that sound will be sent over HDMI cable\nhdmi_drive=2\n# Set monitor mode to DMT\nhdmi_group=2\n# Set monitor resolution to 1024x768 XGA 60Hz (HDMI_DMT_XGA_60)\nhdmi_mode=16\n# Make display smaller to stop text spilling off the screen\noverscan_left=20\noverscan_right=12\noverscan_top=10\noverscan_bottom=10",
            "title": "File format"
        },
        {
            "location": "/configuration/config-txt/README/index.html#configtxt-options",
            "text": "A range of options can be specified using the config.txt file. These are split into different sections, indexed below:   Memory  Licence Keys/Codecs  Video/Display  Audio  Camera  Boot  Ports and Device Tree  Overclocking  Conditional Filters  Miscellaneous   This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "config.txt Options"
        },
        {
            "location": "/configuration/config-txt/audio/index.html",
            "text": "Onboard analogue audio options in config.txt (3.5mm jack)\n\n\nThe onboard audio output uses config options to change the way the analogue audio is driven, and whether some firmware features are enabled or not.\n\n\ndisable_audio_dither\n\n\nBy default, a 1.0LSB dither is applied to the audio stream if it is routed to the analogue audio output. This can create audible background \"hiss\" in some situations, for example when the ALSA volume is set to a low level. Set \ndisable_audio_dither\n to \n1\n to disable dither application.\n\n\nenable_audio_dither\n\n\nAudio dither (see disable_audio_dither above) is normally disabled when the audio samples are larger than 16 bits. Set this option to \n1\n to force the use of dithering for all bit depths.\n\n\npwm_sample_bits\n\n\nThe \npwm_sample_bits\n command adjusts the bit depth of the analogue audio output. The default bit depth is \n11\n. Selecting bit depths below \n8\n will result in nonfunctional audio, as settings below \n8\n result in a PLL frequency too low to support. This is generally only useful as a demonstration of how bit depth affects quantisation noise.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Onboard analogue audio options in config.txt (3.5mm jack)"
        },
        {
            "location": "/configuration/config-txt/audio/index.html#onboard-analogue-audio-options-in-configtxt-35mm-jack",
            "text": "The onboard audio output uses config options to change the way the analogue audio is driven, and whether some firmware features are enabled or not.",
            "title": "Onboard analogue audio options in config.txt (3.5mm jack)"
        },
        {
            "location": "/configuration/config-txt/audio/index.html#disable_audio_dither",
            "text": "By default, a 1.0LSB dither is applied to the audio stream if it is routed to the analogue audio output. This can create audible background \"hiss\" in some situations, for example when the ALSA volume is set to a low level. Set  disable_audio_dither  to  1  to disable dither application.",
            "title": "disable_audio_dither"
        },
        {
            "location": "/configuration/config-txt/audio/index.html#enable_audio_dither",
            "text": "Audio dither (see disable_audio_dither above) is normally disabled when the audio samples are larger than 16 bits. Set this option to  1  to force the use of dithering for all bit depths.",
            "title": "enable_audio_dither"
        },
        {
            "location": "/configuration/config-txt/audio/index.html#pwm_sample_bits",
            "text": "The  pwm_sample_bits  command adjusts the bit depth of the analogue audio output. The default bit depth is  11 . Selecting bit depths below  8  will result in nonfunctional audio, as settings below  8  result in a PLL frequency too low to support. This is generally only useful as a demonstration of how bit depth affects quantisation noise.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "pwm_sample_bits"
        },
        {
            "location": "/configuration/config-txt/boot/index.html",
            "text": "Boot options in config.txt\n\n\nstart_file, fixup_file\n\n\nThese options specify the firmware files transferred to the Videocore GPU prior to booting.\n\n\nstart_file\n specifies the Videocore (VC4) firmware file to use.\n\nfixup_file\n specifies the file used to fix up memory locations used in the \nstart_file\n to match the GPU memory split. Note that the \nstart_file\n and the \nfixup_file\n are a matched pair - using unmatched files will stop the board from booting. This is an advanced option, so we advise that you use \nstart_x\n and \nstart_debug\n rather than this option.\n\n\nstart_x, start_debug\n\n\nThese provide a shortcut to some alternative \nstart_file\n and \nfixup_file\n settings, and are the recommended methods for selecting firmware configurations.\n\n\nstart_x=1\n implies\n   \nstart_file=start_x.elf\n\n   \nfixup_file=fixup_x.dat\n\n\nstart_debug=1\n implies\n   \nstart_file=start_db.elf\n\n   \nfixup_file=fixup_db.dat\n\n\nstart_x=1\n should be specified when using the camera module. Enabling the camera via \nraspi-config\n will set this automatically.\n\n\ndisable_commandline_tags\n\n\nSet the \ndisable_commandline_tags\n command to \n1\n to stop \nstart.elf\n from filling in ATAGS (memory from \n0x100\n) before launching the kernel.\n\n\ncmdline\n\n\ncmdline\n is the alternative filename on the boot partition from which to read the kernel command line string; the default value is \ncmdline.txt\n.\n\n\nkernel\n\n\nkernel\n is the alternative filename on the boot partition to use when loading the kernel. The default value on the Pi 1, Pi Zero, and Compute Module is \nkernel.img\n, and on the Pi 2, Pi 3, and Compute Module 3 it is \nkernel7.img\n. If \nkernel8.img\n is present on the Pi 3 or Compute Module 3, it will be loaded in preference and entered in 64-bit mode.\n\n\nkernel_address\n\n\nkernel_address\n is the memory address to which the kernel image should be loaded. 32-bit kernels are loaded to address \n0x8000\n by default, and 64-bit kernels to address \n0x80000\n. If \nkernel_old\n is set, kernels are loaded to the address \n0x0\n.\n\n\nkernel_old\n\n\nSet \nkernel_old\n to \n1\n to load the kernel to the memory address \n0x0\n.\n\n\nramfsfile\n\n\nramfsfile\n is the optional filename on the boot partition of a ramfs to load. More information is available \nhere\n.\n\n\nramfsaddr\n\n\nramfsaddr\n is the memory address to which the \nramfsfile\n should be loaded.\n\n\ninitramfs\n\n\nThe \ninitramfs\n command specifies both the ramfs filename \nand\n the memory address to which to load it. It performs the actions of both \nramfsfile\n and \nramfsaddr\n in one parameter. Example values are: \ninitramfs initramf.gz 0x00800000\n. \nNOTE:\n This option uses different syntax from all the other options, and you should not use a \n=\n character here.\n\n\ninit_uart_baud\n\n\ninit_uart_baud\n is the initial UART baud rate. The default value is \n115200\n.\n\n\ninit_uart_clock\n\n\ninit_uart_clock\n is the initial UART clock frequency. The default value is \n48000000\n (48MHz). Note that this clock only applies to UART0 (ttyAMA0 in Linux), and that the maximum baudrate for the UART is limited to 1/16th of the clock. The default UART on the Pi 3 and Pi Zero is UART1 (ttyS0 in Linux), and its clock is the core VPU clock - at least 250MHz.\n\n\nbootcode_delay\n\n\nThe \nbootcode_delay\n command delays for a given number of seconds in \nbootcode.bin\n before loading \nstart.elf\n: the default value is \n0\n.\n\n\nThis is particularly useful to insert a delay before reading the EDID of the monitor, for example if the Pi and monitor are powered from the same source, but the monitor takes longer to start up than the Pi. Try setting this value if the display detection is wrong on initial boot, but is correct if you soft-reboot the Pi without removing power from the monitor.\n\n\nboot_delay\n\n\nThe \nboot_delay\n command instructs to wait for a given number of seconds in \nstart.elf\n before loading the kernel: the default value is \n1\n. The total delay in milliseconds is calculated as \n(1000 x boot_delay) + boot_delay_ms\n. This can be useful if your SD card needs a while to get ready before Linux is able to boot from it.\n\n\nboot_delay_ms\n\n\nThe \nboot_delay_ms\n command means wait for a given number of milliseconds in \nstart.elf\n, together with \nboot_delay\n, before loading the kernel. The default value is \n0\n.\n\n\ndisable_splash\n\n\nIf \ndisable_splash\n is set to \n1\n, the rainbow splash screen will not be shown on boot. The default value is \n0\n.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Boot options in config.txt"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#boot-options-in-configtxt",
            "text": "",
            "title": "Boot options in config.txt"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#start_file-fixup_file",
            "text": "These options specify the firmware files transferred to the Videocore GPU prior to booting.  start_file  specifies the Videocore (VC4) firmware file to use. fixup_file  specifies the file used to fix up memory locations used in the  start_file  to match the GPU memory split. Note that the  start_file  and the  fixup_file  are a matched pair - using unmatched files will stop the board from booting. This is an advanced option, so we advise that you use  start_x  and  start_debug  rather than this option.",
            "title": "start_file, fixup_file"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#start_x-start_debug",
            "text": "These provide a shortcut to some alternative  start_file  and  fixup_file  settings, and are the recommended methods for selecting firmware configurations.  start_x=1  implies\n    start_file=start_x.elf \n    fixup_file=fixup_x.dat  start_debug=1  implies\n    start_file=start_db.elf \n    fixup_file=fixup_db.dat  start_x=1  should be specified when using the camera module. Enabling the camera via  raspi-config  will set this automatically.",
            "title": "start_x, start_debug"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#disable_commandline_tags",
            "text": "Set the  disable_commandline_tags  command to  1  to stop  start.elf  from filling in ATAGS (memory from  0x100 ) before launching the kernel.",
            "title": "disable_commandline_tags"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#cmdline",
            "text": "cmdline  is the alternative filename on the boot partition from which to read the kernel command line string; the default value is  cmdline.txt .",
            "title": "cmdline"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#kernel",
            "text": "kernel  is the alternative filename on the boot partition to use when loading the kernel. The default value on the Pi 1, Pi Zero, and Compute Module is  kernel.img , and on the Pi 2, Pi 3, and Compute Module 3 it is  kernel7.img . If  kernel8.img  is present on the Pi 3 or Compute Module 3, it will be loaded in preference and entered in 64-bit mode.",
            "title": "kernel"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#kernel_address",
            "text": "kernel_address  is the memory address to which the kernel image should be loaded. 32-bit kernels are loaded to address  0x8000  by default, and 64-bit kernels to address  0x80000 . If  kernel_old  is set, kernels are loaded to the address  0x0 .",
            "title": "kernel_address"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#kernel_old",
            "text": "Set  kernel_old  to  1  to load the kernel to the memory address  0x0 .",
            "title": "kernel_old"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#ramfsfile",
            "text": "ramfsfile  is the optional filename on the boot partition of a ramfs to load. More information is available  here .",
            "title": "ramfsfile"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#ramfsaddr",
            "text": "ramfsaddr  is the memory address to which the  ramfsfile  should be loaded.",
            "title": "ramfsaddr"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#initramfs",
            "text": "The  initramfs  command specifies both the ramfs filename  and  the memory address to which to load it. It performs the actions of both  ramfsfile  and  ramfsaddr  in one parameter. Example values are:  initramfs initramf.gz 0x00800000 .  NOTE:  This option uses different syntax from all the other options, and you should not use a  =  character here.",
            "title": "initramfs"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#init_uart_baud",
            "text": "init_uart_baud  is the initial UART baud rate. The default value is  115200 .",
            "title": "init_uart_baud"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#init_uart_clock",
            "text": "init_uart_clock  is the initial UART clock frequency. The default value is  48000000  (48MHz). Note that this clock only applies to UART0 (ttyAMA0 in Linux), and that the maximum baudrate for the UART is limited to 1/16th of the clock. The default UART on the Pi 3 and Pi Zero is UART1 (ttyS0 in Linux), and its clock is the core VPU clock - at least 250MHz.",
            "title": "init_uart_clock"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#bootcode_delay",
            "text": "The  bootcode_delay  command delays for a given number of seconds in  bootcode.bin  before loading  start.elf : the default value is  0 .  This is particularly useful to insert a delay before reading the EDID of the monitor, for example if the Pi and monitor are powered from the same source, but the monitor takes longer to start up than the Pi. Try setting this value if the display detection is wrong on initial boot, but is correct if you soft-reboot the Pi without removing power from the monitor.",
            "title": "bootcode_delay"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#boot_delay",
            "text": "The  boot_delay  command instructs to wait for a given number of seconds in  start.elf  before loading the kernel: the default value is  1 . The total delay in milliseconds is calculated as  (1000 x boot_delay) + boot_delay_ms . This can be useful if your SD card needs a while to get ready before Linux is able to boot from it.",
            "title": "boot_delay"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#boot_delay_ms",
            "text": "The  boot_delay_ms  command means wait for a given number of milliseconds in  start.elf , together with  boot_delay , before loading the kernel. The default value is  0 .",
            "title": "boot_delay_ms"
        },
        {
            "location": "/configuration/config-txt/boot/index.html#disable_splash",
            "text": "If  disable_splash  is set to  1 , the rainbow splash screen will not be shown on boot. The default value is  0 .  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "disable_splash"
        },
        {
            "location": "/configuration/config-txt/camera/index.html",
            "text": "Camera Settings in config.txt\n\n\ndisable_camera_led\n\n\nSetting \ndisable_camera_led\n to \n1\n prevents the red camera LED from turning on when recording video or taking a still picture. This is useful for preventing reflections when the camera is facing a window, for example.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Camera Settings in config.txt"
        },
        {
            "location": "/configuration/config-txt/camera/index.html#camera-settings-in-configtxt",
            "text": "",
            "title": "Camera Settings in config.txt"
        },
        {
            "location": "/configuration/config-txt/camera/index.html#disable_camera_led",
            "text": "Setting  disable_camera_led  to  1  prevents the red camera LED from turning on when recording video or taking a still picture. This is useful for preventing reflections when the camera is facing a window, for example.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "disable_camera_led"
        },
        {
            "location": "/configuration/config-txt/codeclicence/index.html",
            "text": "Licence key and codec options in config.txt\n\n\nHardware decoding of additional codecs can be enabled by \npurchasing a licence\n that is locked to the CPU serial number of your Raspberry Pi.\n\n\ndecode_MPG2\n\n\ndecode_MPG2\n is a licence key to allow hardware MPEG-2 decoding, e.g. \ndecode_MPG2=0x12345678\n.\n\n\ndecode_WVC1\n\n\ndecode_WVC1\n is a licence key to allow hardware VC-1 decoding, e.g. \ndecode_WVC1=0x12345678\n.\n\n\nIf you have multiple Raspberry Pis and you've bought a codec licence for each of them, you can list up to eight licence keys in a single \nconfig.txt\n, for example \ndecode_MPG2=0x12345678,0xabcdabcd,0x87654321\n. This enables you to swap the same SD card between the different Pis without having to edit \nconfig.txt\n each time.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Licence key and codec options in config.txt"
        },
        {
            "location": "/configuration/config-txt/codeclicence/index.html#licence-key-and-codec-options-in-configtxt",
            "text": "Hardware decoding of additional codecs can be enabled by  purchasing a licence  that is locked to the CPU serial number of your Raspberry Pi.",
            "title": "Licence key and codec options in config.txt"
        },
        {
            "location": "/configuration/config-txt/codeclicence/index.html#decode_mpg2",
            "text": "decode_MPG2  is a licence key to allow hardware MPEG-2 decoding, e.g.  decode_MPG2=0x12345678 .",
            "title": "decode_MPG2"
        },
        {
            "location": "/configuration/config-txt/codeclicence/index.html#decode_wvc1",
            "text": "decode_WVC1  is a licence key to allow hardware VC-1 decoding, e.g.  decode_WVC1=0x12345678 .  If you have multiple Raspberry Pis and you've bought a codec licence for each of them, you can list up to eight licence keys in a single  config.txt , for example  decode_MPG2=0x12345678,0xabcdabcd,0x87654321 . This enables you to swap the same SD card between the different Pis without having to edit  config.txt  each time.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "decode_WVC1"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html",
            "text": "Conditional filters in config.txt\n\n\nWhen a single SD card (or card image) is being used with one Pi and one monitor, it is easy to set \nconfig.txt\n as required for that specific combination and keep it that way, amending it only when something changes.\n\n\nHowever, if one Pi is swapped between different monitors, or if the SD card (or card image) is being swapped between multiple Pis, a single set of settings may no longer be sufficient. Conditional filters allow you to define certain sections of the config file to be used only in specific cases, allowing a single \nconfig.txt\n to create different configurations when read by different hardware.\n\n\nThe \n[all]\n filter\n\n\nThis is the most basic filter. It resets all previously set filters and allows any settings listed below it to be applied to all hardware.\n\n\n[all]\n\n\n\n\n\nIt is usually a good idea to add an \n[all]\n filter at the end of groups of filtered settings to avoid unintentionally combining filters (see below).\n\n\nThe \n[pi1]\n and \n[pi2]\n (etc.) filters\n\n\nAny settings below a \n[pi1]\n filter will only be applied to Pi 1 (A, A+, B, B+) hardware, including the original Compute Module.\nAny settings below a \n[pi2]\n filter will only be applied to Pi 2 hardware. The \n[pi3]\n filter is applicable to Pi 3 and Compute Module 3 hardware, while \n[pi0]\n covers Pi Zero and Pi Zero W.\n\n\n[pi1]\n\n\n[pi2]\n\n\n[pi3]\n\n\n[pi0]\n\n\n\n\n\n\nThese are particularly useful for defining different \nkernel\n, \ninitramfs\n, and \ncmdline\n settings, as the Pi 1 and Pi 2 require different kernels. They can also be useful to define different overclocking settings, as the Pi 1 and Pi 2 have different default speeds. For example, to define separate \ninitramfs\n images for each:\n\n\n[pi1]\n\n\ninitramfs initrd.img-3.18.7+ followkernel\n\n\n[pi2]\n\n\ninitramfs initrd.img-3.18.7-v7+ followkernel\n\n\n[all]\n\n\n\n\n\n\nRemember to use the \n[all]\n filter at the end, so that any subsequent settings aren't limited to Pi 2 hardware only.\n\n\nThe \n[none]\n filter\n\n\nThe \n[none]\n filter prevents any settings that follow from being applied to any hardware. Although there is nothing that you can't do without \n[none]\n, it can be a useful way to keep groups of unused settings in config.txt without having to comment out every line.\n\n\n[none]\n\n\n\n\n\nThe \n[EDID=*]\n filter\n\n\nWhen switching between multiple monitors while using a single SD card in your Pi, and where a blank config isn't sufficient to automatically select the desired resolution for each one, this allows specific settings to be chosen based on the monitors' EDID names.\n\n\nTo view the EDID name of a specific monitor, run the following command:\n\n\ntvservice -n\n\n\n\n\n\nThis will print something like this:\n\n\ndevice_name=VSC-TD2220\n\n\n\n\n\nYou can then specify settings that apply only to this monitor:\n\n\n[EDID=VSC-TD2220]\n\n\nhdmi_group\n=\n2\n\n\nhdmi_mode\n=\n82\n\n\n[all]\n\n\n\n\n\n\nThis forces 1920x1080 DVT mode for the specified monitor, without affecting any other monitors.\n\n\nNote that these settings apply only at boot, so the monitor must be connected at boot time and the Pi must be able to read its EDID information to find the correct name. Hotplugging a different monitor into the Pi after boot will not select different settings.\n\n\nThe serial number filter\n\n\nSometimes settings should only be applied to a single specific Pi, even if you swap the SD card to a different one. Examples include licence keys and overclocking settings (although the licence keys already support SD card swapping in a different way). You can also use this to select different display settings, even if the EDID identification above is not possible, provided that you don't swap monitors between your Pis. For example, if your monitor doesn't supply a usable EDID name, or if you are using composite output (for which EDID cannot be read).\n\n\nTo view the serial number of your Pi, run the following command:\n\n\ncat /proc/cpuinfo\n\n\n\n\n\nThe serial will be shown as a 16-digit hex value at the bottom. For example, if you see:\n\n\nSerial\n          \n:\n \n0000000012345678\n\n\n\n\n\n\nthen you can define settings that will only be applied to this specific Pi:\n\n\n[0x12345678]\n\n\n# settings here are applied only to the Pi with this serial\n\n\n[all]\n\n\n# settings here are applied to all hardware\n\n\n\n\n\n\nCombining conditional filters\n\n\nFilters of the same type replace each other, so \n[pi2]\n overrides \n[pi1]\n, because it is not possible for both to be true at once.\n\n\nFilters of different types can be combined simply by listing them one after the other, for example:\n\n\n# settings here are applied to all hardware\n[EDID=VSC-TD2220]\n# settings here are applied only if monitor VSC-TD2220 is connected\n[pi2]\n# settings here are applied only if monitor VSC-TD2220 is connected *and* on a Pi 2\n[all]\n# settings here are applied to all hardware\n\n\n\n\n\nUse the \n[all]\n filter to reset all previous filters and avoid unintentionally combining different filter types.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Conditional filters in config.txt"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#conditional-filters-in-configtxt",
            "text": "When a single SD card (or card image) is being used with one Pi and one monitor, it is easy to set  config.txt  as required for that specific combination and keep it that way, amending it only when something changes.  However, if one Pi is swapped between different monitors, or if the SD card (or card image) is being swapped between multiple Pis, a single set of settings may no longer be sufficient. Conditional filters allow you to define certain sections of the config file to be used only in specific cases, allowing a single  config.txt  to create different configurations when read by different hardware.",
            "title": "Conditional filters in config.txt"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#the-all-filter",
            "text": "This is the most basic filter. It resets all previously set filters and allows any settings listed below it to be applied to all hardware.  [all]  It is usually a good idea to add an  [all]  filter at the end of groups of filtered settings to avoid unintentionally combining filters (see below).",
            "title": "The [all] filter"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#the-pi1-and-pi2-etc-filters",
            "text": "Any settings below a  [pi1]  filter will only be applied to Pi 1 (A, A+, B, B+) hardware, including the original Compute Module.\nAny settings below a  [pi2]  filter will only be applied to Pi 2 hardware. The  [pi3]  filter is applicable to Pi 3 and Compute Module 3 hardware, while  [pi0]  covers Pi Zero and Pi Zero W.  [pi1]  [pi2]  [pi3]  [pi0]   These are particularly useful for defining different  kernel ,  initramfs , and  cmdline  settings, as the Pi 1 and Pi 2 require different kernels. They can also be useful to define different overclocking settings, as the Pi 1 and Pi 2 have different default speeds. For example, to define separate  initramfs  images for each:  [pi1]  initramfs initrd.img-3.18.7+ followkernel  [pi2]  initramfs initrd.img-3.18.7-v7+ followkernel  [all]   Remember to use the  [all]  filter at the end, so that any subsequent settings aren't limited to Pi 2 hardware only.",
            "title": "The [pi1] and [pi2] (etc.) filters"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#the-none-filter",
            "text": "The  [none]  filter prevents any settings that follow from being applied to any hardware. Although there is nothing that you can't do without  [none] , it can be a useful way to keep groups of unused settings in config.txt without having to comment out every line.  [none]",
            "title": "The [none] filter"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#the-edid-filter",
            "text": "When switching between multiple monitors while using a single SD card in your Pi, and where a blank config isn't sufficient to automatically select the desired resolution for each one, this allows specific settings to be chosen based on the monitors' EDID names.  To view the EDID name of a specific monitor, run the following command:  tvservice -n  This will print something like this:  device_name=VSC-TD2220  You can then specify settings that apply only to this monitor:  [EDID=VSC-TD2220]  hdmi_group = 2  hdmi_mode = 82  [all]   This forces 1920x1080 DVT mode for the specified monitor, without affecting any other monitors.  Note that these settings apply only at boot, so the monitor must be connected at boot time and the Pi must be able to read its EDID information to find the correct name. Hotplugging a different monitor into the Pi after boot will not select different settings.",
            "title": "The [EDID=*] filter"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#the-serial-number-filter",
            "text": "Sometimes settings should only be applied to a single specific Pi, even if you swap the SD card to a different one. Examples include licence keys and overclocking settings (although the licence keys already support SD card swapping in a different way). You can also use this to select different display settings, even if the EDID identification above is not possible, provided that you don't swap monitors between your Pis. For example, if your monitor doesn't supply a usable EDID name, or if you are using composite output (for which EDID cannot be read).  To view the serial number of your Pi, run the following command:  cat /proc/cpuinfo  The serial will be shown as a 16-digit hex value at the bottom. For example, if you see:  Serial            :   0000000012345678   then you can define settings that will only be applied to this specific Pi:  [0x12345678]  # settings here are applied only to the Pi with this serial  [all]  # settings here are applied to all hardware",
            "title": "The serial number filter"
        },
        {
            "location": "/configuration/config-txt/conditional/index.html#combining-conditional-filters",
            "text": "Filters of the same type replace each other, so  [pi2]  overrides  [pi1] , because it is not possible for both to be true at once.  Filters of different types can be combined simply by listing them one after the other, for example:  # settings here are applied to all hardware\n[EDID=VSC-TD2220]\n# settings here are applied only if monitor VSC-TD2220 is connected\n[pi2]\n# settings here are applied only if monitor VSC-TD2220 is connected *and* on a Pi 2\n[all]\n# settings here are applied to all hardware  Use the  [all]  filter to reset all previous filters and avoid unintentionally combining different filter types.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Combining conditional filters"
        },
        {
            "location": "/configuration/config-txt/memory/index.html",
            "text": "Memory options in config.txt\n\n\ngpu_mem\n\n\nGPU memory in megabytes. This sets the memory split between the CPU and GPU; the CPU gets the remaining memory. Minimum value is \n16\n; maximum value is \n192\n, \n448\n, or \n944\n, depending on whether you are using a 256M, 512MB, or 1024MB Pi. The default value is \n64\n.\n\n\nSetting \ngpu_mem\n to low values may automatically disable certain firmware features, as there are some things the GPU cannot do if it has access to too little memory. So if a feature you are trying to use isn't working, try setting a larger GPU memory split.\n\n\nUsing \ngpu_mem_256\n, \ngpu_mem_512\n, and \ngpu_mem_1024\n allows you to swap the same SD card between 256MB, 512MB, and 1024MB Pis without having to edit \nconfig.txt\n each time:\n\n\ngpu_mem_256\n\n\nThe \ngpu_mem_256\n command sets the GPU memory in megabytes for the 256MB Raspberry Pi (it is ignored if memory size is not 256MB). This overrides \ngpu_mem\n. The maximum value is \n192\n and the default is not set.\n\n\ngpu_mem_512\n\n\nThe \ngpu_mem_512\n command sets the GPU memory in megabytes for the 512MB Raspberry Pi (it is ignored if memory size is not 512MB). This overrides \ngpu_mem\n. The maximum value is \n448\n and the default is not set.\n\n\ngpu_mem_1024\n\n\nThe \ngpu_mem_1024\n command sets the GPU memory in megabytes for the 1024MB Raspberry Pi 2 (it is ignored if memory size is not 1024MB). This overrides \ngpu_mem\n. The maximum value is \n944\n and the default is not set.\n\n\ndisable_l2cache\n\n\nSetting this to \n1\n disables the CPU's access to the GPU's L2 cache, and requires a corresponding L2 disabled kernel. Default value is \n0\n.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Memory options in config.txt"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#memory-options-in-configtxt",
            "text": "",
            "title": "Memory options in config.txt"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#gpu_mem",
            "text": "GPU memory in megabytes. This sets the memory split between the CPU and GPU; the CPU gets the remaining memory. Minimum value is  16 ; maximum value is  192 ,  448 , or  944 , depending on whether you are using a 256M, 512MB, or 1024MB Pi. The default value is  64 .  Setting  gpu_mem  to low values may automatically disable certain firmware features, as there are some things the GPU cannot do if it has access to too little memory. So if a feature you are trying to use isn't working, try setting a larger GPU memory split.  Using  gpu_mem_256 ,  gpu_mem_512 , and  gpu_mem_1024  allows you to swap the same SD card between 256MB, 512MB, and 1024MB Pis without having to edit  config.txt  each time:",
            "title": "gpu_mem"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#gpu_mem_256",
            "text": "The  gpu_mem_256  command sets the GPU memory in megabytes for the 256MB Raspberry Pi (it is ignored if memory size is not 256MB). This overrides  gpu_mem . The maximum value is  192  and the default is not set.",
            "title": "gpu_mem_256"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#gpu_mem_512",
            "text": "The  gpu_mem_512  command sets the GPU memory in megabytes for the 512MB Raspberry Pi (it is ignored if memory size is not 512MB). This overrides  gpu_mem . The maximum value is  448  and the default is not set.",
            "title": "gpu_mem_512"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#gpu_mem_1024",
            "text": "The  gpu_mem_1024  command sets the GPU memory in megabytes for the 1024MB Raspberry Pi 2 (it is ignored if memory size is not 1024MB). This overrides  gpu_mem . The maximum value is  944  and the default is not set.",
            "title": "gpu_mem_1024"
        },
        {
            "location": "/configuration/config-txt/memory/index.html#disable_l2cache",
            "text": "Setting this to  1  disables the CPU's access to the GPU's L2 cache, and requires a corresponding L2 disabled kernel. Default value is  0 .  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "disable_l2cache"
        },
        {
            "location": "/configuration/config-txt/misc/index.html",
            "text": "Miscellaneous options in config.txt\n\n\navoid_warnings\n\n\nThe \nwarning symbols\n can be disabled using this option, although this is not advised.\n\n\navoid_warnings=1\n disables the warning overlays.\n\navoid_warnings=2\n disables the warning overlays, but additionally allows turbo mode even when low-voltage is present.\n\n\nlogging_level\n\n\nSets the Videocore logging level. The value is a Videocore-specific bitmask.\n\n\narm_64bit\n\n\nIf set, this forces the kernel loading system to assume a 64-bit kernel.\n\n\ninclude\n\n\nCauses the content of the specified file to be inserted into the current file.\n\n\nFor example, adding the line \ninclude extraconfig.txt\n to \nconfig.txt\n will include the content of \nextraconfig.txt\n file in the \nconfig.txt\n file.",
            "title": "Miscellaneous options in config.txt"
        },
        {
            "location": "/configuration/config-txt/misc/index.html#miscellaneous-options-in-configtxt",
            "text": "",
            "title": "Miscellaneous options in config.txt"
        },
        {
            "location": "/configuration/config-txt/misc/index.html#avoid_warnings",
            "text": "The  warning symbols  can be disabled using this option, although this is not advised.  avoid_warnings=1  disables the warning overlays. avoid_warnings=2  disables the warning overlays, but additionally allows turbo mode even when low-voltage is present.",
            "title": "avoid_warnings"
        },
        {
            "location": "/configuration/config-txt/misc/index.html#logging_level",
            "text": "Sets the Videocore logging level. The value is a Videocore-specific bitmask.",
            "title": "logging_level"
        },
        {
            "location": "/configuration/config-txt/misc/index.html#arm_64bit",
            "text": "If set, this forces the kernel loading system to assume a 64-bit kernel.",
            "title": "arm_64bit"
        },
        {
            "location": "/configuration/config-txt/misc/index.html#include",
            "text": "Causes the content of the specified file to be inserted into the current file.  For example, adding the line  include extraconfig.txt  to  config.txt  will include the content of  extraconfig.txt  file in the  config.txt  file.",
            "title": "include"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html",
            "text": "Overclocking options in config.txt\n\n\nNOTE:\n Setting any overclocking parameters to values other than those used by \nraspi-config\n may set a permanent bit within the SoC, making it possible to detect that your Pi has been overclocked. The specific circumstances where the overclock bit is set are if \nforce_turbo\n is set to \n1\n and any of the \nover_voltage_*\n options are set to a value > \n0\n. See the \nblog post on Turbo Mode\n for more information.\n\n\nThe latest kernel has a \ncpufreq\n kernel driver with the \"ondemand\" governor enabled by default. It has no effect if you have no overclock settings, but if you overclock, the CPU frequency will vary with processor load. Non-default values are only used when required, according to the governor. You can adjust the minimum values with the \n*_min\n config options, or disable dynamic clocking (and force overclocking) with \nforce_turbo=1\n. For more information \nsee here\n.\n\n\nOverclocking and overvoltage will be disabled at runtime when the SoC reaches 85\u00b0C in order to cool it down. You should not hit this limit on Raspberry Pi models 1 or 2, but it is more likely with the Raspberry Pi 3. For more information \nsee here\n. Overclocking and overvoltage are also disabled when an undervoltage situation is detected.\n\n\nOverclocking options\n\n\n\n\n\n\n\n\nOption\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\narm_freq\n\n\nFrequency of the ARM CPU in MHz. The default value is \n1000\n for the Pi Zero and Pi Zero W, \n700\n for Pi 1, \n900\n for Pi 2, \n1200\n for the Pi 3.\n\n\n\n\n\n\ngpu_freq\n\n\nSets \ncore_freq\n, \nh264_freq\n, \nisp_freq\n, and \nv3d_freq\n together. On Pi 1/Pi 2 the default value is \n250\n for all items, on Pi 3/Pi Zero /Pi Zero W \ncore_freq\n defaults to \n400\n and \nh264_freq\n, \nisp_freq\n and \nv3d_freq\ndefault to \n300\n.\n\n\n\n\n\n\ncore_freq\n\n\nFrequency of the GPU processor core in MHz. It has an impact on CPU performance because it drives the L2 cache and memory bus. The default value is \n250\n for the Pi 1/Pi 2 and \n400\n for the Pi 3 and Pi Zero  and Pi Zero W. Note that the L2 cache benefits only the Pi Zero/Pi Zero W and Pi 1, but there is a small benefit for SDRAM on the Pi 2/Pi 3.\n\n\n\n\n\n\nh264_freq\n\n\nFrequency of the hardware video block in MHz. Individual override of the \ngpu_freq\n setting.\n\n\n\n\n\n\nisp_freq\n\n\nFrequency of the image sensor pipeline block in MHz. Individual override of the \ngpu_freq\n setting.\n\n\n\n\n\n\nv3d_freq\n\n\nFrequency of the 3D block in MHz. Individual override of the \ngpu_freq\n setting.\n\n\n\n\n\n\nsdram_freq\n\n\nFrequency of the SDRAM in MHz. The default value is \n400\n for the Pi 1 and Pi 2, \n450\n on the Pi 3, Pi Zero and Pi Zero W.\n\n\n\n\n\n\nover_voltage\n\n\nCPU/GPU core voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. In other words, specifying -16 will give 0.8V as the GPU/core voltage, and specifying 8 will give 1.4V. For defaults see table below. Values above 6 are only allowed when \nforce_turbo\n is specified: this sets the warranty bit if \nover_voltage_*\n is also set.\n\n\n\n\n\n\nover_voltage_sdram\n\n\nSets \nover_voltage_sdram_c\n, \nover_voltage_sdram_i\n, and \nover_voltage_sdram_p\n together.\n\n\n\n\n\n\nover_voltage_sdram_c\n\n\nSDRAM controller voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is \n0\n (1.2V).\n\n\n\n\n\n\nover_voltage_sdram_i\n\n\nSDRAM I/O voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is \n0\n (1.2V).\n\n\n\n\n\n\nover_voltage_sdram_p\n\n\nSDRAM phy voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is \n0\n (1.2V).\n\n\n\n\n\n\nforce_turbo\n\n\nForces turbo mode frequencies even when the ARM cores are not busy. Enabling this may set the warranty bit if \nover_voltage_*\n is also set.\n\n\n\n\n\n\ninitial_turbo\n\n\nEnables turbo mode from boot for the given value in seconds, or until cpufreq sets a frequency. For more information \nsee here\n. The default value is \n0\n, maximum value is \n60\n.\n\n\n\n\n\n\narm_freq_min\n\n\nMinimum value of arm_freq used for dynamic frequency clocking. The default value is \n700\n for the Pi Zero/Pi 1, \n600\n for the Pi 2/Pi 3.\n\n\n\n\n\n\ncore_freq_min\n\n\nMinimum value of \ncore_freq\n used for dynamic frequency clocking. The default value is \n250\n.\n\n\n\n\n\n\ngpu_freq_min\n\n\nMinimum value of \ngpu_freq\n used for dynamic frequency clocking. The default value is \n250\n.\n\n\n\n\n\n\nh264_freq_min\n\n\nMinimum value of \nh264_freq\n used for dynamic frequency clocking. The default value is \n250\n.\n\n\n\n\n\n\nisp_freq_min\n\n\nMinimum value of \nisp_freq\n used for dynamic frequency clocking. The default value is \n250\n.\n\n\n\n\n\n\nv3d_freq_min\n\n\nMinimum value of \nv3d_freq\n used for dynamic frequency clocking. The default value is \n250\n.\n\n\n\n\n\n\nsdram_freq_min\n\n\nMinimum value of \nsdram_freq\n used for dynamic frequency clocking. The default value is \n400\n.\n\n\n\n\n\n\nover_voltage_min\n\n\nMinimum value of \nover_voltage\n used for dynamic frequency clocking. The default value is \n0\n.\n\n\n\n\n\n\ntemp_limit\n\n\nOverheat protection. This sets the clocks and voltages to default when the SoC reaches this value in Celsius.  The default value is \n85\n. Values over 85 are clamped to 85.\n\n\n\n\n\n\n\n\nThis table describes the overvoltage settings for the various Pi models. The firmware uses Adaptive Voltage Scaling (AVS) to determine the optimum voltage to set. Note that for each integer rise in over_voltage, the voltage will be 25mV higher.\n\n\n\n\n\n\n\n\nVersion\n\n\nDefault Overvoltage\n\n\nSetting\n\n\n\n\n\n\n\n\n\n\nPi 1\n\n\n1.2V\n\n\n0\n\n\n\n\n\n\nPi 2\n\n\n1.2-1.3125V\n\n\n0\n\n\n\n\n\n\nPi 3\n\n\n1.2-1.3125V\n\n\n0\n\n\n\n\n\n\nPi Zero\n\n\n1.35V\n\n\n6\n\n\n\n\n\n\n\n\nforce_turbo\n\n\nBy default (\nforce_turbo=0\n) the \"On Demand\" CPU frequency driver will raise clocks to their maximum frequencies when the ARM cores are busy and will lower them to the minimum frequencies when the ARM cores are idle.\n\n\nforce_turbo=1\n overrides this behaviour and forces maximum frequencies even when the ARM cores are not busy.\n\n\nnever_over_voltage\n\n\nSets a bit in the OTP memory (one time programmable) that prevents the device from being overvoltaged. This is intended to lock the device down so the warranty bit cannot be set either inadvertently or maliciously by using an invalid overvoltage.\n\n\ndisable_auto_turbo\n\n\nOn the Pi 2/Pi 3, setting this flag will disable the GPU from moving into turbo mode, which it can do in particular load cases.\n\n\nClocks relationship\n\n\nThe GPU core, CPU, SDRAM and GPU each have their own PLLs and can have unrelated frequencies. The h264, v3d and ISP blocks share a PLL. For more information \nsee here\n.\n\n\nTo view the Pi's current frequency, type: \ncat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq\n. Divide the result by 1000 to find the value in MHz.\n\n\nMonitoring core temperature\n\n\nTo view the Pi's temperature, type: \ncat /sys/class/thermal/thermal_zone0/temp\n. Divide the result by 1000 to find the value in Celsius.\n\n\nWhilst hitting the temperature limit is not harmful to the SoC, it will cause CPU throttling. A heatsink can help to control the core temperature and therefore performance. This is especially useful if the Pi is running inside a case. Airflow over the heatsink will make cooling more efficient. A suitable heatsink is the self-adhesive BGA (ball-grid-array) 14x14x10 mm heatsink available from \nRS Components\n.\n\n\nWith firmware from 12th September 2016 or later, when the core temperature is between 80'C and 85'C, a warning icon showing a red half-filled thermometer will be displayed, and the ARM cores will be throttled back. If the temperature exceeds 85'C, an icon showing a fully-filled thermometer will be displayed, and both the ARM cores and the GPU will be throttled back.\n\n\nSee the page on \nwarning icons\n for more details.\n\n\nMonitoring voltage\n\n\nIt is essential to keep the supply voltage above 4.8V for reliable performance. Note that the voltage from some USB chargers/power supplies can fall as low as 4.2V. This is because they are usually designed to charge a 3.7V LiPo battery, not to supply 5V to a computer. \n\n\nTo monitor the Pi's PSU voltage, you will need to use a multimeter to measure between the VCC and GND pins on the GPIO. More information is available in \npower\n.\n\n\nIf the voltage drops below 4.63v (+-5%), recent versions of the firmware will show a yellow lightning bolt symbol on the display to indicate a lack of power.\n\n\nSee the page on \nwarning icons\n for more details.\n\n\nOverclocking problems\n\n\nMost overclocking issues show up immediately with a failure to boot. If this occurs, hold down the \nshift\n key during the next boot. This will temporarily disable all overclocking, allowing you to boot successfully and then edit your settings.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Overclocking options in config.txt"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#overclocking-options-in-configtxt",
            "text": "NOTE:  Setting any overclocking parameters to values other than those used by  raspi-config  may set a permanent bit within the SoC, making it possible to detect that your Pi has been overclocked. The specific circumstances where the overclock bit is set are if  force_turbo  is set to  1  and any of the  over_voltage_*  options are set to a value >  0 . See the  blog post on Turbo Mode  for more information.  The latest kernel has a  cpufreq  kernel driver with the \"ondemand\" governor enabled by default. It has no effect if you have no overclock settings, but if you overclock, the CPU frequency will vary with processor load. Non-default values are only used when required, according to the governor. You can adjust the minimum values with the  *_min  config options, or disable dynamic clocking (and force overclocking) with  force_turbo=1 . For more information  see here .  Overclocking and overvoltage will be disabled at runtime when the SoC reaches 85\u00b0C in order to cool it down. You should not hit this limit on Raspberry Pi models 1 or 2, but it is more likely with the Raspberry Pi 3. For more information  see here . Overclocking and overvoltage are also disabled when an undervoltage situation is detected.",
            "title": "Overclocking options in config.txt"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#overclocking-options",
            "text": "Option  Description      arm_freq  Frequency of the ARM CPU in MHz. The default value is  1000  for the Pi Zero and Pi Zero W,  700  for Pi 1,  900  for Pi 2,  1200  for the Pi 3.    gpu_freq  Sets  core_freq ,  h264_freq ,  isp_freq , and  v3d_freq  together. On Pi 1/Pi 2 the default value is  250  for all items, on Pi 3/Pi Zero /Pi Zero W  core_freq  defaults to  400  and  h264_freq ,  isp_freq  and  v3d_freq default to  300 .    core_freq  Frequency of the GPU processor core in MHz. It has an impact on CPU performance because it drives the L2 cache and memory bus. The default value is  250  for the Pi 1/Pi 2 and  400  for the Pi 3 and Pi Zero  and Pi Zero W. Note that the L2 cache benefits only the Pi Zero/Pi Zero W and Pi 1, but there is a small benefit for SDRAM on the Pi 2/Pi 3.    h264_freq  Frequency of the hardware video block in MHz. Individual override of the  gpu_freq  setting.    isp_freq  Frequency of the image sensor pipeline block in MHz. Individual override of the  gpu_freq  setting.    v3d_freq  Frequency of the 3D block in MHz. Individual override of the  gpu_freq  setting.    sdram_freq  Frequency of the SDRAM in MHz. The default value is  400  for the Pi 1 and Pi 2,  450  on the Pi 3, Pi Zero and Pi Zero W.    over_voltage  CPU/GPU core voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. In other words, specifying -16 will give 0.8V as the GPU/core voltage, and specifying 8 will give 1.4V. For defaults see table below. Values above 6 are only allowed when  force_turbo  is specified: this sets the warranty bit if  over_voltage_*  is also set.    over_voltage_sdram  Sets  over_voltage_sdram_c ,  over_voltage_sdram_i , and  over_voltage_sdram_p  together.    over_voltage_sdram_c  SDRAM controller voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is  0  (1.2V).    over_voltage_sdram_i  SDRAM I/O voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is  0  (1.2V).    over_voltage_sdram_p  SDRAM phy voltage adjustment. [-16,8] equates to [0.8V,1.4V] with 0.025V steps. The default value is  0  (1.2V).    force_turbo  Forces turbo mode frequencies even when the ARM cores are not busy. Enabling this may set the warranty bit if  over_voltage_*  is also set.    initial_turbo  Enables turbo mode from boot for the given value in seconds, or until cpufreq sets a frequency. For more information  see here . The default value is  0 , maximum value is  60 .    arm_freq_min  Minimum value of arm_freq used for dynamic frequency clocking. The default value is  700  for the Pi Zero/Pi 1,  600  for the Pi 2/Pi 3.    core_freq_min  Minimum value of  core_freq  used for dynamic frequency clocking. The default value is  250 .    gpu_freq_min  Minimum value of  gpu_freq  used for dynamic frequency clocking. The default value is  250 .    h264_freq_min  Minimum value of  h264_freq  used for dynamic frequency clocking. The default value is  250 .    isp_freq_min  Minimum value of  isp_freq  used for dynamic frequency clocking. The default value is  250 .    v3d_freq_min  Minimum value of  v3d_freq  used for dynamic frequency clocking. The default value is  250 .    sdram_freq_min  Minimum value of  sdram_freq  used for dynamic frequency clocking. The default value is  400 .    over_voltage_min  Minimum value of  over_voltage  used for dynamic frequency clocking. The default value is  0 .    temp_limit  Overheat protection. This sets the clocks and voltages to default when the SoC reaches this value in Celsius.  The default value is  85 . Values over 85 are clamped to 85.     This table describes the overvoltage settings for the various Pi models. The firmware uses Adaptive Voltage Scaling (AVS) to determine the optimum voltage to set. Note that for each integer rise in over_voltage, the voltage will be 25mV higher.     Version  Default Overvoltage  Setting      Pi 1  1.2V  0    Pi 2  1.2-1.3125V  0    Pi 3  1.2-1.3125V  0    Pi Zero  1.35V  6",
            "title": "Overclocking options"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#force_turbo",
            "text": "By default ( force_turbo=0 ) the \"On Demand\" CPU frequency driver will raise clocks to their maximum frequencies when the ARM cores are busy and will lower them to the minimum frequencies when the ARM cores are idle.  force_turbo=1  overrides this behaviour and forces maximum frequencies even when the ARM cores are not busy.",
            "title": "force_turbo"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#never_over_voltage",
            "text": "Sets a bit in the OTP memory (one time programmable) that prevents the device from being overvoltaged. This is intended to lock the device down so the warranty bit cannot be set either inadvertently or maliciously by using an invalid overvoltage.",
            "title": "never_over_voltage"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#disable_auto_turbo",
            "text": "On the Pi 2/Pi 3, setting this flag will disable the GPU from moving into turbo mode, which it can do in particular load cases.",
            "title": "disable_auto_turbo"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#clocks-relationship",
            "text": "The GPU core, CPU, SDRAM and GPU each have their own PLLs and can have unrelated frequencies. The h264, v3d and ISP blocks share a PLL. For more information  see here .  To view the Pi's current frequency, type:  cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq . Divide the result by 1000 to find the value in MHz.",
            "title": "Clocks relationship"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#monitoring-core-temperature",
            "text": "To view the Pi's temperature, type:  cat /sys/class/thermal/thermal_zone0/temp . Divide the result by 1000 to find the value in Celsius.  Whilst hitting the temperature limit is not harmful to the SoC, it will cause CPU throttling. A heatsink can help to control the core temperature and therefore performance. This is especially useful if the Pi is running inside a case. Airflow over the heatsink will make cooling more efficient. A suitable heatsink is the self-adhesive BGA (ball-grid-array) 14x14x10 mm heatsink available from  RS Components .  With firmware from 12th September 2016 or later, when the core temperature is between 80'C and 85'C, a warning icon showing a red half-filled thermometer will be displayed, and the ARM cores will be throttled back. If the temperature exceeds 85'C, an icon showing a fully-filled thermometer will be displayed, and both the ARM cores and the GPU will be throttled back.  See the page on  warning icons  for more details.",
            "title": "Monitoring core temperature"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#monitoring-voltage",
            "text": "It is essential to keep the supply voltage above 4.8V for reliable performance. Note that the voltage from some USB chargers/power supplies can fall as low as 4.2V. This is because they are usually designed to charge a 3.7V LiPo battery, not to supply 5V to a computer.   To monitor the Pi's PSU voltage, you will need to use a multimeter to measure between the VCC and GND pins on the GPIO. More information is available in  power .  If the voltage drops below 4.63v (+-5%), recent versions of the firmware will show a yellow lightning bolt symbol on the display to indicate a lack of power.  See the page on  warning icons  for more details.",
            "title": "Monitoring voltage"
        },
        {
            "location": "/configuration/config-txt/overclocking/index.html#overclocking-problems",
            "text": "Most overclocking issues show up immediately with a failure to boot. If this occurs, hold down the  shift  key during the next boot. This will temporarily disable all overclocking, allowing you to boot successfully and then edit your settings.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Overclocking problems"
        },
        {
            "location": "/configuration/config-txt/video/index.html",
            "text": "Video options in config.txt\n\n\nComposite video mode options\n\n\nsdtv_mode\n\n\nThe \nsdtv_mode\n command defines the TV standard used for composite video output over the yellow RCA jack. The default value is \n0\n.\n\n\n\n\n\n\n\n\nsdtv_mode\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n0\n\n\nNormal NTSC\n\n\n\n\n\n\n1\n\n\nJapanese version of NTSC \u2013 no pedestal\n\n\n\n\n\n\n2\n\n\nNormal PAL\n\n\n\n\n\n\n3\n\n\nBrazilian version of PAL \u2013 525/60 rather than 625/50, different subcarrier\n\n\n\n\n\n\n\n\nsdtv_aspect\n\n\nThe \nsdtv_aspect\n command defines the aspect ratio for composite video output. The default value is \n1\n.\n\n\n\n\n\n\n\n\nsdtv_aspect\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n1\n\n\n4:3\n\n\n\n\n\n\n2\n\n\n14:9\n\n\n\n\n\n\n3\n\n\n16:9\n\n\n\n\n\n\n\n\nsdtv_disable_colourburst\n\n\nSetting \nsdtv_disable_colourburst\n to \n1\n disables colourburst on composite video output. The picture will be displayed in monochrome, but it may appear sharper.\n\n\nHDMI mode options\n\n\nhdmi_safe\n\n\nSetting \nhdmi_safe\n to \n1\n will lead to \"safe mode\" settings being used to try to boot with maximum HDMI compatibility. This is the same as setting the following parameters:\n\n\nhdmi_force_hotplug=1\nhdmi_ignore_edid=0xa5000080\nconfig_hdmi_boost=4\nhdmi_group=2\nhdmi_mode=4\ndisable_overscan=0\noverscan_left=24\noverscan_right=24\noverscan_top=24\noverscan_bottom=24\n\n\n\n\n\nhdmi_ignore_edid\n\n\nSetting \nhdmi_ignore_edid\n to \n0xa5000080\n enables the ignoring of EDID/display data if your display does not have an accurate \nEDID\n. It requires this unusual value to ensure that it is not triggered accidentally.\n\n\nhdmi_edid_file\n\n\nSetting \nhdmi_edid_file\n to \n1\n will cause the GPU to read EDID data from the \nedid.dat\n file, located in the boot partition, instead of reading it from the monitor. More information is available \nhere\n.\n\n\nhdmi_force_edid_audio\n\n\nSetting \nhdmi_force_edid_audio\n to \n1\n pretends that all audio formats are supported by the display, allowing passthrough of DTS/AC3 even when this is not reported as supported.\n\n\nhdmi_ignore_edid_audio\n\n\nSetting \nhdmi_ignore_edid_audio\n to \n1\n pretends that all audio formats are unsupported by the display. This means ALSA will default to the analogue audio (headphone) jack.\n\n\nhdmi_force_edid_3d\n\n\nSetting \nhdmi_force_edid_3d\n to \n1\n pretends that all CEA modes support 3D, even when the EDID does not indicate support for this.\n\n\navoid_edid_fuzzy_match\n\n\nSetting \navoid_edid_fuzzy_match\n to \n1\n avoids \nfuzzy matching\n of modes described in the EDID. Instead, it will pick the standard mode with the matching resolution and closest framerate, even if the blanking settings are wrong.\n\n\nhdmi_ignore_cec_init\n\n\nSetting \nhdmi_ignore_cec_init\n to \n1\n will stop the initial active source message being sent during bootup. This prevents a CEC-enabled TV from coming out of standby and channel-switching when you are rebooting your Raspberry Pi.\n\n\nhdmi_ignore_cec\n\n\nSetting \nhdmi_ignore_cec\n to \n1\n pretends that \nCEC\n is not supported at all by the TV. No CEC functions will be supported.\n\n\ncec_osd_name\n\n\nThe \ncec_osd_name\n command sets the initial CEC name of the device. The default is Raspberry Pi.\n\n\nhdmi_pixel_encoding\n\n\nThe \nhdmi_pixel_encoding\n command forces the pixel encoding mode. By default, it will use the mode requested from the EDID, so you shouldn't need to change it.\n\n\n\n\n\n\n\n\nhdmi_pixel_encoding\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n0\n\n\ndefault (RGB limited for CEA, RGB full for DMT)\n\n\n\n\n\n\n1\n\n\nRGB limited (16-235)\n\n\n\n\n\n\n2\n\n\nRGB full (0-255)\n\n\n\n\n\n\n3\n\n\nYCbCr limited (16-235)\n\n\n\n\n\n\n4\n\n\nYCbCr full (0-255)\n\n\n\n\n\n\n\n\nhdmi_blanking\n\n\nThe \nhdmi_blanking\n command allows you to choose whether the HDMI output should be switched off when DPMS is triggered. This is to mimic the behaviour of other computers. After a specific amount of time, the display will become blank and go into low-power/standby mode due to receiving no signal.\n\n\nNOTE:\n This feature may cause issues when using applications which don't use the framebuffer, such as omxplayer.\n\n\n\n\n\n\n\n\nhdmi_blanking\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n0\n\n\nHDMI Output will blank instead of being disabled\n\n\n\n\n\n\n1\n\n\nHDMI Output will be disabled rather than just blanking\n\n\n\n\n\n\n\n\nhdmi_drive\n\n\nThe \nhdmi_drive\n command allows you to choose between HDMI and DVI output modes.\n\n\n\n\n\n\n\n\nhdmi_drive\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n1\n\n\nNormal DVI mode (no sound)\n\n\n\n\n\n\n2\n\n\nNormal HDMI mode (sound will be sent if supported and enabled)\n\n\n\n\n\n\n\n\nconfig_hdmi_boost\n\n\nConfigures the signal strength of the HDMI interface. The default value is \n0\n and the maximum is \n11\n.\n\n\nThe default value for the original Model B and A is \n2\n. The default value for the Model B+ and all later models is \n5\n.\n\n\nIf you are seeing HDMI issues (speckling, interference) then try \n7\n. Very long HDMI cables may need up to \n11\n, but values this high should not be used unless absolutely necessary.\n\n\nhdmi_group\n\n\nThe \nhdmi_group\n command defines the HDMI output group to be either CEA (Consumer Electronics Association, the standard typically used by TVs) or DMT (Display Monitor Timings, the standard typically used by monitors). This setting should be used in conjunction with \nhdmi_mode\n.\n\n\n\n\n\n\n\n\nhdmi_group\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n0\n\n\nAuto-detect from EDID\n\n\n\n\n\n\n1\n\n\nCEA\n\n\n\n\n\n\n2\n\n\nDMT\n\n\n\n\n\n\n\n\nhdmi_mode\n\n\nTogether with \nhdmi_group\n, \nhdmi_mode\n defines the HDMI output format.\n\n\nTo set a custom display mode not listed here, see \nthis thread\n.\n\n\nThese values are valid if \nhdmi_group=1\n (CEA):\n\n\n\n\n\n\n\n\nhdmi_mode\n\n\nresolution\n\n\nfrequency\n\n\nnotes\n\n\n\n\n\n\n\n\n\n\n1\n\n\nVGA (640x480)\n\n\n\n\n\n\n\n\n\n\n2\n\n\n480p\n\n\n60Hz\n\n\n\n\n\n\n\n\n3\n\n\n480p\n\n\n60Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n4\n\n\n720p\n\n\n60Hz\n\n\n\n\n\n\n\n\n5\n\n\n1080i\n\n\n60Hz\n\n\n\n\n\n\n\n\n6\n\n\n480i\n\n\n60Hz\n\n\n\n\n\n\n\n\n7\n\n\n480i\n\n\n60Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n8\n\n\n240p\n\n\n60Hz\n\n\n\n\n\n\n\n\n9\n\n\n240p\n\n\n60Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n10\n\n\n480i\n\n\n60Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n11\n\n\n480i\n\n\n60Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n12\n\n\n240p\n\n\n60Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n13\n\n\n240p\n\n\n60Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n14\n\n\n480p\n\n\n60Hz\n\n\npixel doubling\n\n\n\n\n\n\n15\n\n\n480p\n\n\n60Hz\n\n\npixel doubling, 16:9 aspect ratio\n\n\n\n\n\n\n16\n\n\n1080p\n\n\n60Hz\n\n\n\n\n\n\n\n\n17\n\n\n576p\n\n\n50Hz\n\n\n\n\n\n\n\n\n18\n\n\n576p\n\n\n50Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n19\n\n\n720p\n\n\n50Hz\n\n\n\n\n\n\n\n\n20\n\n\n1080i\n\n\n50Hz\n\n\n\n\n\n\n\n\n21\n\n\n576i\n\n\n50Hz\n\n\n\n\n\n\n\n\n22\n\n\n576i\n\n\n50Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n23\n\n\n288p\n\n\n50Hz\n\n\n\n\n\n\n\n\n24\n\n\n288p\n\n\n50Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n25\n\n\n576i\n\n\n50Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n26\n\n\n576i\n\n\n50Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n27\n\n\n288p\n\n\n50Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n28\n\n\n288p\n\n\n50Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n29\n\n\n576p\n\n\n50Hz\n\n\npixel doubling\n\n\n\n\n\n\n30\n\n\n576p\n\n\n50Hz\n\n\npixel doubling, 16:9 aspect ratio\n\n\n\n\n\n\n31\n\n\n1080p\n\n\n50Hz\n\n\n\n\n\n\n\n\n32\n\n\n1080p\n\n\n24Hz\n\n\n\n\n\n\n\n\n33\n\n\n1080p\n\n\n25Hz\n\n\n\n\n\n\n\n\n34\n\n\n1080p\n\n\n30Hz\n\n\n\n\n\n\n\n\n35\n\n\n480p\n\n\n60Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n36\n\n\n480p\n\n\n60Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n37\n\n\n576p\n\n\n50Hz\n\n\npixel quadrupling\n\n\n\n\n\n\n38\n\n\n576p\n\n\n50Hz\n\n\npixel quadrupling, 16:9 aspect ratio\n\n\n\n\n\n\n39\n\n\n1080i\n\n\n50Hz\n\n\nreduced blanking\n\n\n\n\n\n\n40\n\n\n1080i\n\n\n100Hz\n\n\n\n\n\n\n\n\n41\n\n\n720p\n\n\n100Hz\n\n\n\n\n\n\n\n\n42\n\n\n576p\n\n\n100Hz\n\n\n\n\n\n\n\n\n43\n\n\n576p\n\n\n100Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n44\n\n\n576i\n\n\n100Hz\n\n\n\n\n\n\n\n\n45\n\n\n576i\n\n\n100Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n46\n\n\n1080i\n\n\n120Hz\n\n\n\n\n\n\n\n\n47\n\n\n720p\n\n\n120Hz\n\n\n\n\n\n\n\n\n48\n\n\n480p\n\n\n120Hz\n\n\n\n\n\n\n\n\n49\n\n\n480p\n\n\n120Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n50\n\n\n480i\n\n\n120Hz\n\n\n\n\n\n\n\n\n51\n\n\n480i\n\n\n120Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n52\n\n\n576p\n\n\n200Hz\n\n\n\n\n\n\n\n\n53\n\n\n576p\n\n\n200Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n54\n\n\n576i\n\n\n200Hz\n\n\n\n\n\n\n\n\n55\n\n\n576i\n\n\n200Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n56\n\n\n480p\n\n\n240Hz\n\n\n\n\n\n\n\n\n57\n\n\n480p\n\n\n240Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n58\n\n\n480i\n\n\n240Hz\n\n\n\n\n\n\n\n\n59\n\n\n480i\n\n\n240Hz\n\n\n16:9 aspect ratio\n\n\n\n\n\n\n\n\nIn the table above, the modes with a 16:9 aspect ratio are a widescreen variant of a mode which usually has 4:3 aspect ratio. Pixel doubling and quadrupling indicates a higher clock rate, with each pixel repeated two or four times respectively.\n\n\nThese values are valid if \nhdmi_group=2\n (DMT):\n\n\n\n\n\n\n\n\nhdmi_mode\n\n\nresolution\n\n\nfrequency\n\n\nnotes\n\n\n\n\n\n\n\n\n\n\n1\n\n\n640x350\n\n\n85Hz\n\n\n\n\n\n\n\n\n2\n\n\n640x400\n\n\n85Hz\n\n\n\n\n\n\n\n\n3\n\n\n720x400\n\n\n85Hz\n\n\n\n\n\n\n\n\n4\n\n\n640x480\n\n\n60Hz\n\n\n\n\n\n\n\n\n5\n\n\n640x480\n\n\n72Hz\n\n\n\n\n\n\n\n\n6\n\n\n640x480\n\n\n75Hz\n\n\n\n\n\n\n\n\n7\n\n\n640x480\n\n\n85Hz\n\n\n\n\n\n\n\n\n8\n\n\n800x600\n\n\n56Hz\n\n\n\n\n\n\n\n\n9\n\n\n800x600\n\n\n60Hz\n\n\n\n\n\n\n\n\n10\n\n\n800x600\n\n\n72Hz\n\n\n\n\n\n\n\n\n11\n\n\n800x600\n\n\n75Hz\n\n\n\n\n\n\n\n\n12\n\n\n800x600\n\n\n85Hz\n\n\n\n\n\n\n\n\n13\n\n\n800x600\n\n\n120Hz\n\n\n\n\n\n\n\n\n14\n\n\n848x480\n\n\n60Hz\n\n\n\n\n\n\n\n\n15\n\n\n1024x768\n\n\n43Hz\n\n\nincompatible with the Raspberry Pi\n\n\n\n\n\n\n16\n\n\n1024x768\n\n\n60Hz\n\n\n\n\n\n\n\n\n17\n\n\n1024x768\n\n\n70Hz\n\n\n\n\n\n\n\n\n18\n\n\n1024x768\n\n\n75Hz\n\n\n\n\n\n\n\n\n19\n\n\n1024x768\n\n\n85Hz\n\n\n\n\n\n\n\n\n20\n\n\n1024x768\n\n\n120Hz\n\n\n\n\n\n\n\n\n21\n\n\n1152x864\n\n\n75Hz\n\n\n\n\n\n\n\n\n22\n\n\n1280x768\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n23\n\n\n1280x768\n\n\n60Hz\n\n\n\n\n\n\n\n\n24\n\n\n1280x768\n\n\n75Hz\n\n\n\n\n\n\n\n\n25\n\n\n1280x768\n\n\n85Hz\n\n\n\n\n\n\n\n\n26\n\n\n1280x768\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n27\n\n\n1280x800\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n28\n\n\n1280x800\n\n\n60Hz\n\n\n\n\n\n\n\n\n29\n\n\n1280x800\n\n\n75Hz\n\n\n\n\n\n\n\n\n30\n\n\n1280x800\n\n\n85Hz\n\n\n\n\n\n\n\n\n31\n\n\n1280x800\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n32\n\n\n1280x960\n\n\n60Hz\n\n\n\n\n\n\n\n\n33\n\n\n1280x960\n\n\n85Hz\n\n\n\n\n\n\n\n\n34\n\n\n1280x960\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n35\n\n\n1280x1024\n\n\n60Hz\n\n\n\n\n\n\n\n\n36\n\n\n1280x1024\n\n\n75Hz\n\n\n\n\n\n\n\n\n37\n\n\n1280x1024\n\n\n85Hz\n\n\n\n\n\n\n\n\n38\n\n\n1280x1024\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n39\n\n\n1360x768\n\n\n60Hz\n\n\n\n\n\n\n\n\n40\n\n\n1360x768\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n41\n\n\n1400x1050\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n42\n\n\n1400x1050\n\n\n60Hz\n\n\n\n\n\n\n\n\n43\n\n\n1400x1050\n\n\n75Hz\n\n\n\n\n\n\n\n\n44\n\n\n1400x1050\n\n\n85Hz\n\n\n\n\n\n\n\n\n45\n\n\n1400x1050\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n46\n\n\n1440x900\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n47\n\n\n1440x900\n\n\n60Hz\n\n\n\n\n\n\n\n\n48\n\n\n1440x900\n\n\n75Hz\n\n\n\n\n\n\n\n\n49\n\n\n1440x900\n\n\n85Hz\n\n\n\n\n\n\n\n\n50\n\n\n1440x900\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n51\n\n\n1600x1200\n\n\n60Hz\n\n\n\n\n\n\n\n\n52\n\n\n1600x1200\n\n\n65Hz\n\n\n\n\n\n\n\n\n53\n\n\n1600x1200\n\n\n70Hz\n\n\n\n\n\n\n\n\n54\n\n\n1600x1200\n\n\n75Hz\n\n\n\n\n\n\n\n\n55\n\n\n1600x1200\n\n\n85Hz\n\n\n\n\n\n\n\n\n56\n\n\n1600x1200\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n57\n\n\n1680x1050\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n58\n\n\n1680x1050\n\n\n60Hz\n\n\n\n\n\n\n\n\n59\n\n\n1680x1050\n\n\n75Hz\n\n\n\n\n\n\n\n\n60\n\n\n1680x1050\n\n\n85Hz\n\n\n\n\n\n\n\n\n61\n\n\n1680x1050\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n62\n\n\n1792x1344\n\n\n60Hz\n\n\n\n\n\n\n\n\n63\n\n\n1792x1344\n\n\n75Hz\n\n\n\n\n\n\n\n\n64\n\n\n1792x1344\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n65\n\n\n1856x1392\n\n\n60Hz\n\n\n\n\n\n\n\n\n66\n\n\n1856x1392\n\n\n75Hz\n\n\n\n\n\n\n\n\n67\n\n\n1856x1392\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n68\n\n\n1920x1200\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n69\n\n\n1920x1200\n\n\n60Hz\n\n\n\n\n\n\n\n\n70\n\n\n1920x1200\n\n\n75Hz\n\n\n\n\n\n\n\n\n71\n\n\n1920x1200\n\n\n85Hz\n\n\n\n\n\n\n\n\n72\n\n\n1920x1200\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n73\n\n\n1920x1440\n\n\n60Hz\n\n\n\n\n\n\n\n\n74\n\n\n1920x1440\n\n\n75Hz\n\n\n\n\n\n\n\n\n75\n\n\n1920x1440\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n76\n\n\n2560x1600\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n77\n\n\n2560x1600\n\n\n60Hz\n\n\n\n\n\n\n\n\n78\n\n\n2560x1600\n\n\n75Hz\n\n\n\n\n\n\n\n\n79\n\n\n2560x1600\n\n\n85Hz\n\n\n\n\n\n\n\n\n80\n\n\n2560x1600\n\n\n120Hz\n\n\nreduced blanking\n\n\n\n\n\n\n81\n\n\n1366x768\n\n\n60Hz\n\n\n\n\n\n\n\n\n82\n\n\n1920x1080\n\n\n60Hz\n\n\n1080p\n\n\n\n\n\n\n83\n\n\n1600x900\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n84\n\n\n2048x1152\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n85\n\n\n1280x720\n\n\n60Hz\n\n\n720p\n\n\n\n\n\n\n86\n\n\n1366x768\n\n\n\n\nreduced blanking\n\n\n\n\n\n\n\n\nNote that there is a \npixel clock limit\n.The highest supported mode is 1920x1200 at 60Hz with reduced blanking.\n\n\nhdmi_force_mode\n\n\nSetting to \n1\n will remove all other modes except the ones specified by \nhdmi_mode\n and \nhdmi_group\n from the internal list, meaning they will not appear in any enumerated lists of modes. This option may help if a display seems to be ignoring the \nhdmi_mode\n and \nhdmi_group\n settings.\n\n\nedid_content_type\n\n\nForces the edit content type to a specific value.\n\n\nThe options are:\n - 0 = EDID_ContentType_NODATA, content type none.\n - 1 = EDID_ContentType_Graphics, content type graphics, ITC must be set to 1\n - 2 = EDID_ContentType_Photo, content type photo\n - 3 = EDID_ContentType_Cinema,  content type cinema\n - 4 = EDID_ContentType_Game,  content type game\n\n\nWhich values are valid for my monitor?\n\n\nYour HDMI monitor may only support a limited set of formats. To find out which formats are supported, use the following method:\n\n\n\n\nSet the output format to VGA 60Hz (\nhdmi_group=1\n and \nhdmi_mode=1\n) and boot up your Raspberry Pi\n\n\nEnter the following command to give a list of CEA-supported modes: \n/opt/vc/bin/tvservice -m CEA\n\n\nEnter the following command to give a list of DMT-supported modes: \n/opt/vc/bin/tvservice -m DMT\n\n\nEnter the following command to show your current state: \n/opt/vc/bin/tvservice -s\n\n\nEnter the following commands to dump more detailed information from your monitor: \n/opt/vc/bin/tvservice -d edid.dat; /opt/vc/bin/edidparser edid.dat\n\n\n\n\nThe \nedid.dat\n should also be provided when troubleshooting problems with the default HDMI mode.\n\n\nCustom mode\n\n\nIf your monitor requires a mode that is not in one of the tables above, then it's possible to define a custom \nCVT\n mode for it instead:\n\n\nhdmi_cvt=<width> <height> <framerate> <aspect> <margins> <interlace> <rb>\n\n\n\n\n\n\n\n\n\n\n\nValue\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nwidth\n\n\n(required)\n\n\nwidth in pixels\n\n\n\n\n\n\nheight\n\n\n(required)\n\n\nheight in pixels\n\n\n\n\n\n\nframerate\n\n\n(required)\n\n\nframerate in Hz\n\n\n\n\n\n\naspect\n\n\n3\n\n\naspect ratio 1=4:3, 2=14:9, 3=16:9, 4=5:4, 5=16:10, 6=15:9\n\n\n\n\n\n\nmargins\n\n\n0\n\n\n0=margins disabled, 1=margins enabled\n\n\n\n\n\n\ninterlace\n\n\n0\n\n\n0=progressive, 1=interlaced\n\n\n\n\n\n\nrb\n\n\n0\n\n\n0=normal, 1=reduced blanking\n\n\n\n\n\n\n\n\nFields at the end can be omitted to use the default values.\n\n\nNote that this simply \ncreates\n the mode (group 2 mode 87). In order to make the Pi use this by default, you must add some additional settings. For example, the following selects an 800 \u00d7 480 resolution and enables audio drive:\n\n\nhdmi_cvt=800 480 60 6\nhdmi_group=2\nhdmi_mode=87\nhdmi_drive=2\n\n\n\n\n\nThis may not work if your monitor does not support standard CVT timings.\n\n\nLCD display/touchscreen options\n\n\nignore_lcd\n\n\nBy default the Raspberry Pi LCD display is used when it is detected on the I2C bus. \nignore_lcd=1\n will skip this detection phase, and therefore the LCD display will not be used.\n\n\ndisplay_default_lcd\n\n\nIf a Raspberry Pi DSI LCD is detected it will be used as the default display and will show the framebuffer. Setting \ndisplay_default_lcd=0\n will ensure the LCD is not the default display, which usually implies the HDMI output will be the default. The LCD can still be used by choosing its display number from supported applications, for example, omxplayer.\n\n\nlcd_framerate\n\n\nSpecify the framerate of the Raspberry Pi LCD display, in Hertz/fps. Defaults to 60Hz.\n\n\nlcd_rotate\n\n\nThis flips the display using the LCD's inbuilt flip functionality, which is a cheaper operation that using the GPU-based rotate operation.\n\n\nFor example, \nlcd_rotate=2\n will compensate for an upside down display.\n\n\ndisable_touchscreen\n\n\nEnable/disable the touchscreen.\n\n\ndisable_touchscreen=1\n will disable the touchscreen on the official Raspberry Pi LCD display.\n\n\nenable_dpi_lcd\n\n\nEnable LCD displays attached to the DPI GPIOs. This is to allow the use of third-party LCD displays using the parallel display interface.\n\n\ndpi_group, dpi_mode, dpi_output_format\n\n\nThe \ndpi_group\n and \ndpi_mode\n config.txt parameters are used to set either predetermined modes (DMT or CEA modes as used by HDMI above). A user can generate custom modes in much the same way as for HDMI.\n\n\ndpi_output_format\n is a bitmask specifying various parameters used to set up the display format. \n\n\nMore details on using the DPI modes and the output format can be found \nhere\n.\n\n\nGeneric display options\n\n\nhdmi_force_hotplug\n\n\nSetting \nhdmi_force_hotplug\n to \n1\n pretends that the HDMI hotplug signal is asserted, so it appears that a HDMI display is attached. In other words, HDMI output mode will be used, even if no HDMI monitor is detected.\n\n\nhdmi_ignore_hotplug\n\n\nSetting \nhdmi_ignore_hotplug\n to \n1\n pretends that the HDMI hotplug signal is not asserted, so it appears that a HDMI display is not attached. In other words, composite output mode will be used, even if an HDMI monitor is detected.\n\n\ndisable_overscan\n\n\nSet \ndisable_overscan\n to \n1\n to disable \noverscan\n.\n\n\noverscan_left\n\n\nThe \noverscan_left\n command specifies the number of pixels to skip on the left edge of the screen. Increase this value if the text flows off the left edge of the screen; decrease it if there is a black border between the left edge of the screen and the text.\n\n\noverscan_right\n\n\nThe \noverscan_right\n command specifies the number of pixels to skip on the right edge of the screen.\n\n\noverscan_top\n\n\nThe \noverscan_top\n command specifies the number of pixels to skip on the top edge of the screen.\n\n\noverscan_bottom\n\n\nThe \noverscan_bottom\n command specifies the number of pixels to skip on the bottom edge of the screen.\n\n\noverscan_scale\n\n\nSet \noverscan_scale\n to \n1\n to force any non-framebuffer layers to conform to the overscan settings.\n\n\nframebuffer_width\n\n\nThe \nframebuffer_width\n command specifies the console framebuffer width in pixels. The default is the display width minus the total horizontal overscan.\n\n\nframebuffer_height\n\n\nThe \nframebuffer_height\n command specifies the console framebuffer height in pixels. The default is the display height minus the total vertical overscan.\n\n\nmax_framebuffer_height, max_framebuffer_width\n\n\nSpecifies the maximum dimensions that the internal frame buffer is allowed to be. \n\n\nframebuffer_depth\n\n\nUse \nframebuffer_depth\n to specify the console framebuffer depth in bits per pixel. The default value is \n16\n.\n\n\n\n\n\n\n\n\nframebuffer_depth\n\n\nresult\n\n\nnotes\n\n\n\n\n\n\n\n\n\n\n8\n\n\n8bit framebuffer\n\n\nDefault RGB palette makes screen unreadable\n\n\n\n\n\n\n16\n\n\n16bit framebuffer\n\n\n\n\n\n\n\n\n24\n\n\n24bit framebuffer\n\n\nMay result in a corrupted display\n\n\n\n\n\n\n32\n\n\n32bit framebuffer\n\n\nMay need to be used in conjunction with \nframebuffer_ignore_alpha=1\n\n\n\n\n\n\n\n\nframebuffer_ignore_alpha\n\n\nSet \nframebuffer_ignore_alpha\n to \n1\n to disable the alpha channel. Can help with the display of a 32bit \nframebuffer_depth\n.\n\n\ntest_mode\n\n\nThe \ntest_mode\n command displays a test image and sound during boot (over the composite video and analogue audio outputs only) for the given number of seconds, before continuing to boot the OS as normal. This is used as a manufacturing test; the default value is \n0\n.\n\n\ndisplay_hdmi_rotate\n\n\nUse \ndisplay_hdmi_rotate\n to rotate or flip the HDMI display orientation. The default value is \n0\n.\n\n\n\n\n\n\n\n\ndisplay_hdmi_rotate\n\n\nresult\n\n\n\n\n\n\n\n\n\n\n0\n\n\nno rotation\n\n\n\n\n\n\n1\n\n\nrotate 90 degrees clockwise\n\n\n\n\n\n\n2\n\n\nrotate 180 degrees clockwise\n\n\n\n\n\n\n3\n\n\nrotate 270 degrees clockwise\n\n\n\n\n\n\n0x10000\n\n\nhorizontal flip\n\n\n\n\n\n\n0x20000\n\n\nvertical flip\n\n\n\n\n\n\n\n\nNote that the 90 and 270 degree rotation options require additional memory on the GPU, so these will not work with the 16MB GPU split.\n\n\ndisplay_lcd_rotate\n\n\nUse \ndisplay_lcd_rotate\n to rotate or flip the LCD orientation. Parameters are the same as \ndisplay_hdmi_rotate\n.\n\n\ndisplay_rotate\n\n\ndisplay_rotate\n is deprecated in the latest firmware but has been retained for backwards compatibility. Please use \ndisplay_lcd_rotate\n and \ndisplay_hdmi_rotate\n instead.\n\n\nUse \ndisplay_rotate\n to rotate or flip the screen orientation. Parameters are the same as \ndisplay_hdmi_rotate\n.\n\n\nOther options\n\n\ndispmanx_offline\n\n\nForces dispmanx composition to be done offline in two offscreen framebuffers. This can allow more dispmanx elements to be composited, but is slower and may limit screen framerate to typically 30fps.\n\n\nThis article uses content from the eLinux wiki page \nRPiconfig\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Video options in config.txt"
        },
        {
            "location": "/configuration/config-txt/video/index.html#video-options-in-configtxt",
            "text": "",
            "title": "Video options in config.txt"
        },
        {
            "location": "/configuration/config-txt/video/index.html#composite-video-mode-options",
            "text": "",
            "title": "Composite video mode options"
        },
        {
            "location": "/configuration/config-txt/video/index.html#sdtv_mode",
            "text": "The  sdtv_mode  command defines the TV standard used for composite video output over the yellow RCA jack. The default value is  0 .     sdtv_mode  result      0  Normal NTSC    1  Japanese version of NTSC \u2013 no pedestal    2  Normal PAL    3  Brazilian version of PAL \u2013 525/60 rather than 625/50, different subcarrier",
            "title": "sdtv_mode"
        },
        {
            "location": "/configuration/config-txt/video/index.html#sdtv_aspect",
            "text": "The  sdtv_aspect  command defines the aspect ratio for composite video output. The default value is  1 .     sdtv_aspect  result      1  4:3    2  14:9    3  16:9",
            "title": "sdtv_aspect"
        },
        {
            "location": "/configuration/config-txt/video/index.html#sdtv_disable_colourburst",
            "text": "Setting  sdtv_disable_colourburst  to  1  disables colourburst on composite video output. The picture will be displayed in monochrome, but it may appear sharper.",
            "title": "sdtv_disable_colourburst"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi-mode-options",
            "text": "",
            "title": "HDMI mode options"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_safe",
            "text": "Setting  hdmi_safe  to  1  will lead to \"safe mode\" settings being used to try to boot with maximum HDMI compatibility. This is the same as setting the following parameters:  hdmi_force_hotplug=1\nhdmi_ignore_edid=0xa5000080\nconfig_hdmi_boost=4\nhdmi_group=2\nhdmi_mode=4\ndisable_overscan=0\noverscan_left=24\noverscan_right=24\noverscan_top=24\noverscan_bottom=24",
            "title": "hdmi_safe"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_ignore_edid",
            "text": "Setting  hdmi_ignore_edid  to  0xa5000080  enables the ignoring of EDID/display data if your display does not have an accurate  EDID . It requires this unusual value to ensure that it is not triggered accidentally.",
            "title": "hdmi_ignore_edid"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_edid_file",
            "text": "Setting  hdmi_edid_file  to  1  will cause the GPU to read EDID data from the  edid.dat  file, located in the boot partition, instead of reading it from the monitor. More information is available  here .",
            "title": "hdmi_edid_file"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_force_edid_audio",
            "text": "Setting  hdmi_force_edid_audio  to  1  pretends that all audio formats are supported by the display, allowing passthrough of DTS/AC3 even when this is not reported as supported.",
            "title": "hdmi_force_edid_audio"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_ignore_edid_audio",
            "text": "Setting  hdmi_ignore_edid_audio  to  1  pretends that all audio formats are unsupported by the display. This means ALSA will default to the analogue audio (headphone) jack.",
            "title": "hdmi_ignore_edid_audio"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_force_edid_3d",
            "text": "Setting  hdmi_force_edid_3d  to  1  pretends that all CEA modes support 3D, even when the EDID does not indicate support for this.",
            "title": "hdmi_force_edid_3d"
        },
        {
            "location": "/configuration/config-txt/video/index.html#avoid_edid_fuzzy_match",
            "text": "Setting  avoid_edid_fuzzy_match  to  1  avoids  fuzzy matching  of modes described in the EDID. Instead, it will pick the standard mode with the matching resolution and closest framerate, even if the blanking settings are wrong.",
            "title": "avoid_edid_fuzzy_match"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_ignore_cec_init",
            "text": "Setting  hdmi_ignore_cec_init  to  1  will stop the initial active source message being sent during bootup. This prevents a CEC-enabled TV from coming out of standby and channel-switching when you are rebooting your Raspberry Pi.",
            "title": "hdmi_ignore_cec_init"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_ignore_cec",
            "text": "Setting  hdmi_ignore_cec  to  1  pretends that  CEC  is not supported at all by the TV. No CEC functions will be supported.",
            "title": "hdmi_ignore_cec"
        },
        {
            "location": "/configuration/config-txt/video/index.html#cec_osd_name",
            "text": "The  cec_osd_name  command sets the initial CEC name of the device. The default is Raspberry Pi.",
            "title": "cec_osd_name"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_pixel_encoding",
            "text": "The  hdmi_pixel_encoding  command forces the pixel encoding mode. By default, it will use the mode requested from the EDID, so you shouldn't need to change it.     hdmi_pixel_encoding  result      0  default (RGB limited for CEA, RGB full for DMT)    1  RGB limited (16-235)    2  RGB full (0-255)    3  YCbCr limited (16-235)    4  YCbCr full (0-255)",
            "title": "hdmi_pixel_encoding"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_blanking",
            "text": "The  hdmi_blanking  command allows you to choose whether the HDMI output should be switched off when DPMS is triggered. This is to mimic the behaviour of other computers. After a specific amount of time, the display will become blank and go into low-power/standby mode due to receiving no signal.  NOTE:  This feature may cause issues when using applications which don't use the framebuffer, such as omxplayer.     hdmi_blanking  result      0  HDMI Output will blank instead of being disabled    1  HDMI Output will be disabled rather than just blanking",
            "title": "hdmi_blanking"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_drive",
            "text": "The  hdmi_drive  command allows you to choose between HDMI and DVI output modes.     hdmi_drive  result      1  Normal DVI mode (no sound)    2  Normal HDMI mode (sound will be sent if supported and enabled)",
            "title": "hdmi_drive"
        },
        {
            "location": "/configuration/config-txt/video/index.html#config_hdmi_boost",
            "text": "Configures the signal strength of the HDMI interface. The default value is  0  and the maximum is  11 .  The default value for the original Model B and A is  2 . The default value for the Model B+ and all later models is  5 .  If you are seeing HDMI issues (speckling, interference) then try  7 . Very long HDMI cables may need up to  11 , but values this high should not be used unless absolutely necessary.",
            "title": "config_hdmi_boost"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_group",
            "text": "The  hdmi_group  command defines the HDMI output group to be either CEA (Consumer Electronics Association, the standard typically used by TVs) or DMT (Display Monitor Timings, the standard typically used by monitors). This setting should be used in conjunction with  hdmi_mode .     hdmi_group  result      0  Auto-detect from EDID    1  CEA    2  DMT",
            "title": "hdmi_group"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_mode",
            "text": "Together with  hdmi_group ,  hdmi_mode  defines the HDMI output format.  To set a custom display mode not listed here, see  this thread .  These values are valid if  hdmi_group=1  (CEA):     hdmi_mode  resolution  frequency  notes      1  VGA (640x480)      2  480p  60Hz     3  480p  60Hz  16:9 aspect ratio    4  720p  60Hz     5  1080i  60Hz     6  480i  60Hz     7  480i  60Hz  16:9 aspect ratio    8  240p  60Hz     9  240p  60Hz  16:9 aspect ratio    10  480i  60Hz  pixel quadrupling    11  480i  60Hz  pixel quadrupling, 16:9 aspect ratio    12  240p  60Hz  pixel quadrupling    13  240p  60Hz  pixel quadrupling, 16:9 aspect ratio    14  480p  60Hz  pixel doubling    15  480p  60Hz  pixel doubling, 16:9 aspect ratio    16  1080p  60Hz     17  576p  50Hz     18  576p  50Hz  16:9 aspect ratio    19  720p  50Hz     20  1080i  50Hz     21  576i  50Hz     22  576i  50Hz  16:9 aspect ratio    23  288p  50Hz     24  288p  50Hz  16:9 aspect ratio    25  576i  50Hz  pixel quadrupling    26  576i  50Hz  pixel quadrupling, 16:9 aspect ratio    27  288p  50Hz  pixel quadrupling    28  288p  50Hz  pixel quadrupling, 16:9 aspect ratio    29  576p  50Hz  pixel doubling    30  576p  50Hz  pixel doubling, 16:9 aspect ratio    31  1080p  50Hz     32  1080p  24Hz     33  1080p  25Hz     34  1080p  30Hz     35  480p  60Hz  pixel quadrupling    36  480p  60Hz  pixel quadrupling, 16:9 aspect ratio    37  576p  50Hz  pixel quadrupling    38  576p  50Hz  pixel quadrupling, 16:9 aspect ratio    39  1080i  50Hz  reduced blanking    40  1080i  100Hz     41  720p  100Hz     42  576p  100Hz     43  576p  100Hz  16:9 aspect ratio    44  576i  100Hz     45  576i  100Hz  16:9 aspect ratio    46  1080i  120Hz     47  720p  120Hz     48  480p  120Hz     49  480p  120Hz  16:9 aspect ratio    50  480i  120Hz     51  480i  120Hz  16:9 aspect ratio    52  576p  200Hz     53  576p  200Hz  16:9 aspect ratio    54  576i  200Hz     55  576i  200Hz  16:9 aspect ratio    56  480p  240Hz     57  480p  240Hz  16:9 aspect ratio    58  480i  240Hz     59  480i  240Hz  16:9 aspect ratio     In the table above, the modes with a 16:9 aspect ratio are a widescreen variant of a mode which usually has 4:3 aspect ratio. Pixel doubling and quadrupling indicates a higher clock rate, with each pixel repeated two or four times respectively.  These values are valid if  hdmi_group=2  (DMT):     hdmi_mode  resolution  frequency  notes      1  640x350  85Hz     2  640x400  85Hz     3  720x400  85Hz     4  640x480  60Hz     5  640x480  72Hz     6  640x480  75Hz     7  640x480  85Hz     8  800x600  56Hz     9  800x600  60Hz     10  800x600  72Hz     11  800x600  75Hz     12  800x600  85Hz     13  800x600  120Hz     14  848x480  60Hz     15  1024x768  43Hz  incompatible with the Raspberry Pi    16  1024x768  60Hz     17  1024x768  70Hz     18  1024x768  75Hz     19  1024x768  85Hz     20  1024x768  120Hz     21  1152x864  75Hz     22  1280x768   reduced blanking    23  1280x768  60Hz     24  1280x768  75Hz     25  1280x768  85Hz     26  1280x768  120Hz  reduced blanking    27  1280x800   reduced blanking    28  1280x800  60Hz     29  1280x800  75Hz     30  1280x800  85Hz     31  1280x800  120Hz  reduced blanking    32  1280x960  60Hz     33  1280x960  85Hz     34  1280x960  120Hz  reduced blanking    35  1280x1024  60Hz     36  1280x1024  75Hz     37  1280x1024  85Hz     38  1280x1024  120Hz  reduced blanking    39  1360x768  60Hz     40  1360x768  120Hz  reduced blanking    41  1400x1050   reduced blanking    42  1400x1050  60Hz     43  1400x1050  75Hz     44  1400x1050  85Hz     45  1400x1050  120Hz  reduced blanking    46  1440x900   reduced blanking    47  1440x900  60Hz     48  1440x900  75Hz     49  1440x900  85Hz     50  1440x900  120Hz  reduced blanking    51  1600x1200  60Hz     52  1600x1200  65Hz     53  1600x1200  70Hz     54  1600x1200  75Hz     55  1600x1200  85Hz     56  1600x1200  120Hz  reduced blanking    57  1680x1050   reduced blanking    58  1680x1050  60Hz     59  1680x1050  75Hz     60  1680x1050  85Hz     61  1680x1050  120Hz  reduced blanking    62  1792x1344  60Hz     63  1792x1344  75Hz     64  1792x1344  120Hz  reduced blanking    65  1856x1392  60Hz     66  1856x1392  75Hz     67  1856x1392  120Hz  reduced blanking    68  1920x1200   reduced blanking    69  1920x1200  60Hz     70  1920x1200  75Hz     71  1920x1200  85Hz     72  1920x1200  120Hz  reduced blanking    73  1920x1440  60Hz     74  1920x1440  75Hz     75  1920x1440  120Hz  reduced blanking    76  2560x1600   reduced blanking    77  2560x1600  60Hz     78  2560x1600  75Hz     79  2560x1600  85Hz     80  2560x1600  120Hz  reduced blanking    81  1366x768  60Hz     82  1920x1080  60Hz  1080p    83  1600x900   reduced blanking    84  2048x1152   reduced blanking    85  1280x720  60Hz  720p    86  1366x768   reduced blanking     Note that there is a  pixel clock limit .The highest supported mode is 1920x1200 at 60Hz with reduced blanking.",
            "title": "hdmi_mode"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_force_mode",
            "text": "Setting to  1  will remove all other modes except the ones specified by  hdmi_mode  and  hdmi_group  from the internal list, meaning they will not appear in any enumerated lists of modes. This option may help if a display seems to be ignoring the  hdmi_mode  and  hdmi_group  settings.",
            "title": "hdmi_force_mode"
        },
        {
            "location": "/configuration/config-txt/video/index.html#edid_content_type",
            "text": "Forces the edit content type to a specific value.  The options are:\n - 0 = EDID_ContentType_NODATA, content type none.\n - 1 = EDID_ContentType_Graphics, content type graphics, ITC must be set to 1\n - 2 = EDID_ContentType_Photo, content type photo\n - 3 = EDID_ContentType_Cinema,  content type cinema\n - 4 = EDID_ContentType_Game,  content type game",
            "title": "edid_content_type"
        },
        {
            "location": "/configuration/config-txt/video/index.html#which-values-are-valid-for-my-monitor",
            "text": "Your HDMI monitor may only support a limited set of formats. To find out which formats are supported, use the following method:   Set the output format to VGA 60Hz ( hdmi_group=1  and  hdmi_mode=1 ) and boot up your Raspberry Pi  Enter the following command to give a list of CEA-supported modes:  /opt/vc/bin/tvservice -m CEA  Enter the following command to give a list of DMT-supported modes:  /opt/vc/bin/tvservice -m DMT  Enter the following command to show your current state:  /opt/vc/bin/tvservice -s  Enter the following commands to dump more detailed information from your monitor:  /opt/vc/bin/tvservice -d edid.dat; /opt/vc/bin/edidparser edid.dat   The  edid.dat  should also be provided when troubleshooting problems with the default HDMI mode.",
            "title": "Which values are valid for my monitor?"
        },
        {
            "location": "/configuration/config-txt/video/index.html#custom-mode",
            "text": "If your monitor requires a mode that is not in one of the tables above, then it's possible to define a custom  CVT  mode for it instead:  hdmi_cvt=<width> <height> <framerate> <aspect> <margins> <interlace> <rb>     Value  Default  Description      width  (required)  width in pixels    height  (required)  height in pixels    framerate  (required)  framerate in Hz    aspect  3  aspect ratio 1=4:3, 2=14:9, 3=16:9, 4=5:4, 5=16:10, 6=15:9    margins  0  0=margins disabled, 1=margins enabled    interlace  0  0=progressive, 1=interlaced    rb  0  0=normal, 1=reduced blanking     Fields at the end can be omitted to use the default values.  Note that this simply  creates  the mode (group 2 mode 87). In order to make the Pi use this by default, you must add some additional settings. For example, the following selects an 800 \u00d7 480 resolution and enables audio drive:  hdmi_cvt=800 480 60 6\nhdmi_group=2\nhdmi_mode=87\nhdmi_drive=2  This may not work if your monitor does not support standard CVT timings.",
            "title": "Custom mode"
        },
        {
            "location": "/configuration/config-txt/video/index.html#lcd-displaytouchscreen-options",
            "text": "",
            "title": "LCD display/touchscreen options"
        },
        {
            "location": "/configuration/config-txt/video/index.html#ignore_lcd",
            "text": "By default the Raspberry Pi LCD display is used when it is detected on the I2C bus.  ignore_lcd=1  will skip this detection phase, and therefore the LCD display will not be used.",
            "title": "ignore_lcd"
        },
        {
            "location": "/configuration/config-txt/video/index.html#display_default_lcd",
            "text": "If a Raspberry Pi DSI LCD is detected it will be used as the default display and will show the framebuffer. Setting  display_default_lcd=0  will ensure the LCD is not the default display, which usually implies the HDMI output will be the default. The LCD can still be used by choosing its display number from supported applications, for example, omxplayer.",
            "title": "display_default_lcd"
        },
        {
            "location": "/configuration/config-txt/video/index.html#lcd_framerate",
            "text": "Specify the framerate of the Raspberry Pi LCD display, in Hertz/fps. Defaults to 60Hz.",
            "title": "lcd_framerate"
        },
        {
            "location": "/configuration/config-txt/video/index.html#lcd_rotate",
            "text": "This flips the display using the LCD's inbuilt flip functionality, which is a cheaper operation that using the GPU-based rotate operation.  For example,  lcd_rotate=2  will compensate for an upside down display.",
            "title": "lcd_rotate"
        },
        {
            "location": "/configuration/config-txt/video/index.html#disable_touchscreen",
            "text": "Enable/disable the touchscreen.  disable_touchscreen=1  will disable the touchscreen on the official Raspberry Pi LCD display.",
            "title": "disable_touchscreen"
        },
        {
            "location": "/configuration/config-txt/video/index.html#enable_dpi_lcd",
            "text": "Enable LCD displays attached to the DPI GPIOs. This is to allow the use of third-party LCD displays using the parallel display interface.",
            "title": "enable_dpi_lcd"
        },
        {
            "location": "/configuration/config-txt/video/index.html#dpi_group-dpi_mode-dpi_output_format",
            "text": "The  dpi_group  and  dpi_mode  config.txt parameters are used to set either predetermined modes (DMT or CEA modes as used by HDMI above). A user can generate custom modes in much the same way as for HDMI.  dpi_output_format  is a bitmask specifying various parameters used to set up the display format.   More details on using the DPI modes and the output format can be found  here .",
            "title": "dpi_group, dpi_mode, dpi_output_format"
        },
        {
            "location": "/configuration/config-txt/video/index.html#generic-display-options",
            "text": "",
            "title": "Generic display options"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_force_hotplug",
            "text": "Setting  hdmi_force_hotplug  to  1  pretends that the HDMI hotplug signal is asserted, so it appears that a HDMI display is attached. In other words, HDMI output mode will be used, even if no HDMI monitor is detected.",
            "title": "hdmi_force_hotplug"
        },
        {
            "location": "/configuration/config-txt/video/index.html#hdmi_ignore_hotplug",
            "text": "Setting  hdmi_ignore_hotplug  to  1  pretends that the HDMI hotplug signal is not asserted, so it appears that a HDMI display is not attached. In other words, composite output mode will be used, even if an HDMI monitor is detected.",
            "title": "hdmi_ignore_hotplug"
        },
        {
            "location": "/configuration/config-txt/video/index.html#disable_overscan",
            "text": "Set  disable_overscan  to  1  to disable  overscan .",
            "title": "disable_overscan"
        },
        {
            "location": "/configuration/config-txt/video/index.html#overscan_left",
            "text": "The  overscan_left  command specifies the number of pixels to skip on the left edge of the screen. Increase this value if the text flows off the left edge of the screen; decrease it if there is a black border between the left edge of the screen and the text.",
            "title": "overscan_left"
        },
        {
            "location": "/configuration/config-txt/video/index.html#overscan_right",
            "text": "The  overscan_right  command specifies the number of pixels to skip on the right edge of the screen.",
            "title": "overscan_right"
        },
        {
            "location": "/configuration/config-txt/video/index.html#overscan_top",
            "text": "The  overscan_top  command specifies the number of pixels to skip on the top edge of the screen.",
            "title": "overscan_top"
        },
        {
            "location": "/configuration/config-txt/video/index.html#overscan_bottom",
            "text": "The  overscan_bottom  command specifies the number of pixels to skip on the bottom edge of the screen.",
            "title": "overscan_bottom"
        },
        {
            "location": "/configuration/config-txt/video/index.html#overscan_scale",
            "text": "Set  overscan_scale  to  1  to force any non-framebuffer layers to conform to the overscan settings.",
            "title": "overscan_scale"
        },
        {
            "location": "/configuration/config-txt/video/index.html#framebuffer_width",
            "text": "The  framebuffer_width  command specifies the console framebuffer width in pixels. The default is the display width minus the total horizontal overscan.",
            "title": "framebuffer_width"
        },
        {
            "location": "/configuration/config-txt/video/index.html#framebuffer_height",
            "text": "The  framebuffer_height  command specifies the console framebuffer height in pixels. The default is the display height minus the total vertical overscan.",
            "title": "framebuffer_height"
        },
        {
            "location": "/configuration/config-txt/video/index.html#max_framebuffer_height-max_framebuffer_width",
            "text": "Specifies the maximum dimensions that the internal frame buffer is allowed to be.",
            "title": "max_framebuffer_height, max_framebuffer_width"
        },
        {
            "location": "/configuration/config-txt/video/index.html#framebuffer_depth",
            "text": "Use  framebuffer_depth  to specify the console framebuffer depth in bits per pixel. The default value is  16 .     framebuffer_depth  result  notes      8  8bit framebuffer  Default RGB palette makes screen unreadable    16  16bit framebuffer     24  24bit framebuffer  May result in a corrupted display    32  32bit framebuffer  May need to be used in conjunction with  framebuffer_ignore_alpha=1",
            "title": "framebuffer_depth"
        },
        {
            "location": "/configuration/config-txt/video/index.html#framebuffer_ignore_alpha",
            "text": "Set  framebuffer_ignore_alpha  to  1  to disable the alpha channel. Can help with the display of a 32bit  framebuffer_depth .",
            "title": "framebuffer_ignore_alpha"
        },
        {
            "location": "/configuration/config-txt/video/index.html#test_mode",
            "text": "The  test_mode  command displays a test image and sound during boot (over the composite video and analogue audio outputs only) for the given number of seconds, before continuing to boot the OS as normal. This is used as a manufacturing test; the default value is  0 .",
            "title": "test_mode"
        },
        {
            "location": "/configuration/config-txt/video/index.html#display_hdmi_rotate",
            "text": "Use  display_hdmi_rotate  to rotate or flip the HDMI display orientation. The default value is  0 .     display_hdmi_rotate  result      0  no rotation    1  rotate 90 degrees clockwise    2  rotate 180 degrees clockwise    3  rotate 270 degrees clockwise    0x10000  horizontal flip    0x20000  vertical flip     Note that the 90 and 270 degree rotation options require additional memory on the GPU, so these will not work with the 16MB GPU split.",
            "title": "display_hdmi_rotate"
        },
        {
            "location": "/configuration/config-txt/video/index.html#display_lcd_rotate",
            "text": "Use  display_lcd_rotate  to rotate or flip the LCD orientation. Parameters are the same as  display_hdmi_rotate .",
            "title": "display_lcd_rotate"
        },
        {
            "location": "/configuration/config-txt/video/index.html#display_rotate",
            "text": "display_rotate  is deprecated in the latest firmware but has been retained for backwards compatibility. Please use  display_lcd_rotate  and  display_hdmi_rotate  instead.  Use  display_rotate  to rotate or flip the screen orientation. Parameters are the same as  display_hdmi_rotate .",
            "title": "display_rotate"
        },
        {
            "location": "/configuration/config-txt/video/index.html#other-options",
            "text": "",
            "title": "Other options"
        },
        {
            "location": "/configuration/config-txt/video/index.html#dispmanx_offline",
            "text": "Forces dispmanx composition to be done offline in two offscreen framebuffers. This can allow more dispmanx elements to be composited, but is slower and may limit screen framerate to typically 30fps.  This article uses content from the eLinux wiki page  RPiconfig , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "dispmanx_offline"
        },
        {
            "location": "/configuration/wireless/README/index.html",
            "text": "Wireless connectivity\n\n\nThe following documentation is available:\n\n\n\n\nDesktop\n\n\nA guide to setting up wireless networking using the PIXEL desktop.\n\n\n\n\n\n\nCommand line\n\n\nA guide to setting up wireless networking from the command line.\n\n\n\n\n\n\nAccess point\n\n\nA guide to setting the Raspberry Pi up as an access point, and as a internet sharing device.",
            "title": "Wireless connectivity"
        },
        {
            "location": "/configuration/wireless/README/index.html#wireless-connectivity",
            "text": "The following documentation is available:   Desktop  A guide to setting up wireless networking using the PIXEL desktop.    Command line  A guide to setting up wireless networking from the command line.    Access point  A guide to setting the Raspberry Pi up as an access point, and as a internet sharing device.",
            "title": "Wireless connectivity"
        },
        {
            "location": "/configuration/wireless/access-point/index.html",
            "text": "Setting up a Raspberry Pi as an access point in a standalone network\n\n\nThe Raspberry Pi can be used as a wireless access point, running a standalone network. This can be done using the inbuilt wireless features of the Raspberry Pi 3 or Raspberry Pi Zero W, or by using a suitable USB wireless dongle that supports access points. \n\n\nNote that this documentation was tested on a Raspberry Pi 3, and it is possible that some USB dongles may need slight changes to their settings. If you are having trouble with a USB wireless dongle, please check the forums.\n\n\nTo add a Raspberry Pi-based access point to an existing network, see \nthis section\n.\n\n\nIn order to work as an access point, the Raspberry Pi will need to have access point software installed, along with DHCP server software to provide connecting devices with a network address. Ensure that your Raspberry Pi is using an up-to-date version of Raspbian (dated 2017 or later).\n\n\nUse the following to update your Raspbian installation:\n\n\nsudo apt-get update\nsudo apt-get upgrade\n\n\n\n\n\nInstall all the required software in one go with this command: \n\n\nsudo apt-get install dnsmasq hostapd\n\n\n\n\n\nSince the configuration files are not ready yet, turn the new software off as follows: \n\n\nsudo systemctl stop dnsmasq\nsudo systemctl stop hostapd\n\n\n\n\n\nConfiguring a static IP\n\n\nWe are configuring a standalone network to act as a server, so the Raspberry Pi needs to have a static IP address assigned to the wireless port. This documentation assumes that we are using the standard 192.168.x.x IP addresses for our wireless network, so we will assign the server the IP address 192.168.4.1. It is also assumed that the wireless device being used is \nwlan0\n.\n\n\nTo configure the static IP address, edit the dhcpcd configuration file with: \n\n\nsudo nano /etc/dhcpcd.conf\n\n\n\n\n\nGo to the end of the file and edit it so that it looks like the following:\n\n\ninterface\n \nwlan0\n\n    \nstatic\n \nip_address\n=\n192.168\n.\n4.1\n/\n24\n\n\n\n\n\n\nNow restart the dhcpcd daemon and set up the new \nwlan0\n configuration:\n\n\nsudo systemctl restart dhcpcd\n\n\n\n\n\nConfiguring the DHCP server (dnsmasq)\n\n\nThe DHCP service is provided by dnsmasq. By default, the configuration file contains a lot of information that is not needed, and it is easier to start from scratch. Rename this configuration file, and edit a new one:\n\n\nsudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig  \nsudo nano /etc/dnsmasq.conf\n\n\n\n\n\nType or copy the following information into the dnsmasq configuration file and save it:\n\n\ninterface=wlan0      # Use the require wireless interface - usually wlan0\n  dhcp-range=192.168.4.2,192.168.4.20,255.255.255.0,24h\n\n\n\n\n\nSo for \nwlan0\n, we are going to provide IP addresses between 192.168.4.2 and 192.168.4.20, with a lease time of 24 hours. If you are providing DHCP services for other network devices (e.g. eth0), you could add more sections with the appropriate interface header, with the range of addresses you intend to provide to that interface.\n\n\nThere are many more options for dnsmasq; see the \ndnsmasq documentation\n for more details.\n\n\nConfiguring the access point host software (hostapd)\n\n\nYou need to edit the hostapd configuration file, located at /etc/hostapd/hostapd.conf, to add the various parameters for your wireless network. After initial install, this will be a new/empty file.\n\n\nsudo nano /etc/hostapd/hostapd.conf\n\n\n\n\n\nAdd the information below to the configuration file. This configuration assumes we are using channel 7, with a network name of NameOfNetwork, and a password AardvarkBadgerHedgehog. Note that the name and password should \nnot\n have quotes around them. \n\n\ninterface=wlan0\ndriver=nl80211\nssid=NameOfNetwork\nhw_mode=g\nchannel=7\nwmm_enabled=0\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0\nwpa=2\nwpa_passphrase=AardvarkBadgerHedgehog\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP\nrsn_pairwise=CCMP\n\n\n\n\n\nWe now need to tell the system where to find this configuration file.\n\n\nsudo nano /etc/default/hostapd\n\n\n\n\n\nFind the line with #DAEMON_CONF, and replace it with this:\n\n\nDAEMON_CONF=\"/etc/hostapd/hostapd.conf\"\n\n\n\n\n\nStart it up\n\n\nNow start up the remaining services:\n\n\nsudo systemctl start hostapd\nsudo systemctl start dnsmasq\n\n\n\n\n\nAdd routing and masquerade\n\n\nEdit /etc/sysctl.conf and uncomment this line:\n\n\nnet.ipv4.ip_forward=1\n\n\n\n\n\nAdd a masquerade for outbound traffic on eth0:\n\n\nsudo iptables -t nat -A  POSTROUTING -o eth0 -j MASQUERADE\n\n\n\n\n\nSave the iptables rule.\n\n\nsudo sh -c \"iptables-save > /etc/iptables.ipv4.nat\"\n\n\n\n\n\nEdit /etc/rc.local and add this just above \"exit 0\" to install these rules on boot.\n\n\niptables-restore < /etc/iptables.ipv4.nat\n\n\n\n\n\nReboot\n\n\nUsing a wireless device, search for networks. The network SSID you specified in the hostapd configuration should now be present, and it should be accessible with the specified password.\n\n\nIf SSH is enabled on the Raspberry Pi access point, it should be possible to connect to it from another Linux box (or a system with SSH connectivity present) as follows, assuming the \npi\n account is present:\n\n\nssh\n \npi\n@192.168.4.1\n\n\n\n\n\n\nBy this point, the Raspberry Pi is acting as an access point, and other devices can associate with it. Associated devices can access the Raspberry Pi access point via its IP address for operations such as \nrsync\n, \nscp\n, or \nssh\n.\n\n\n\n\nUsing the Raspberry Pi as an access point to share an internet connection\n\n\nOne common use of the Raspberry Pi as an access point is to provide wireless connections to a wired Ethernet connection, so that anyone logged into the access point can access the internet, providing of course that the wired Ethernet on the Pi can connect to the internet via some sort of router.\n\n\nTo do this, a 'bridge' needs to put in place between the wireless device and the Ethernet device on the access point Raspberry Pi. This bridge will pass all traffic between the two interfaces. Install the following packages to enable the access point setup and bridging.\n\n\nsudo apt-get install hostapd bridge-utils\n\n\n\n\n\nSince the configuration files are not ready yet, turn the new software off as follows: \n\n\nsudo systemctl stop hostapd\n\n\n\n\n\nBridging creates a higher-level construct over the two ports being bridged. It is the bridge that is the network device, so we need to stop the \neth0\n and \nwlan0\n ports being allocated IP addresses by the DHCP client on the Raspberry Pi.\n\n\nsudo nano /etc/dhcpcd.conf\n\n\n\n\n\nAdd \ndenyinterfaces wlan0\n and \ndenyinterfaces eth0\n to the end of the file (but above any other added \ninterface\n lines) and save the file.\n\n\nAdd a new bridge, which in this case is called \nbr0\n.\n\n\nsudo brctl addbr br0\n\n\n\n\n\nConnect the network ports. In this case, connect \neth0\n to the bridge \nbr0\n.\n\n\nsudo brctl addif br0 eth0\n\n\n\n\n\nNow the interfaces file needs to be edited to adjust the various devices to work with bridging. \nsudo nano /etc/network/interfaces\n make the following edits.\n\n\nAdd the bridging information at the end of the file.\n\n\n# Bridge setup\nauto br0\niface br0 inet manual\nbridge_ports eth0 wlan0\n\n\n\n\n\nThe access point setup is almost the same as that shown in the previous section. Follow the instructions above to set up the \nhostapd.conf\n file, but add \nbridge=br0\n below the \ninterface=wlan0\n line, and remove or comment out the driver line.\n\n\ninterface=wlan0\nbridge=br0\n#driver=nl80211\n...\n\n\n\n\n\nNow reboot the Raspberry Pi.\n\n\nThere should now be a functioning bridge between the wireless LAN and the Ethernet connection on the Raspberry Pi, and any device associated with the Raspberry Pi access point will act as if it is connected to the access point's wired Ethernet.\n\n\nThe \nifconfig\n command will show the bridge, which will have been allocated an IP address via the wired Ethernet's DHCP server. The \nwlan0\n and \neth0\n no longer have IP addresses, as they are now controlled by the bridge. It is possible to use a static IP address for the bridge if required, but generally, if the Raspberry Pi access point is connected to a ADSL router, the DHCP address will be fine.",
            "title": "Setting up a Raspberry Pi as an access point in a standalone network"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#setting-up-a-raspberry-pi-as-an-access-point-in-a-standalone-network",
            "text": "The Raspberry Pi can be used as a wireless access point, running a standalone network. This can be done using the inbuilt wireless features of the Raspberry Pi 3 or Raspberry Pi Zero W, or by using a suitable USB wireless dongle that supports access points.   Note that this documentation was tested on a Raspberry Pi 3, and it is possible that some USB dongles may need slight changes to their settings. If you are having trouble with a USB wireless dongle, please check the forums.  To add a Raspberry Pi-based access point to an existing network, see  this section .  In order to work as an access point, the Raspberry Pi will need to have access point software installed, along with DHCP server software to provide connecting devices with a network address. Ensure that your Raspberry Pi is using an up-to-date version of Raspbian (dated 2017 or later).  Use the following to update your Raspbian installation:  sudo apt-get update\nsudo apt-get upgrade  Install all the required software in one go with this command:   sudo apt-get install dnsmasq hostapd  Since the configuration files are not ready yet, turn the new software off as follows:   sudo systemctl stop dnsmasq\nsudo systemctl stop hostapd",
            "title": "Setting up a Raspberry Pi as an access point in a standalone network"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#configuring-a-static-ip",
            "text": "We are configuring a standalone network to act as a server, so the Raspberry Pi needs to have a static IP address assigned to the wireless port. This documentation assumes that we are using the standard 192.168.x.x IP addresses for our wireless network, so we will assign the server the IP address 192.168.4.1. It is also assumed that the wireless device being used is  wlan0 .  To configure the static IP address, edit the dhcpcd configuration file with:   sudo nano /etc/dhcpcd.conf  Go to the end of the file and edit it so that it looks like the following:  interface   wlan0 \n     static   ip_address = 192.168 . 4.1 / 24   Now restart the dhcpcd daemon and set up the new  wlan0  configuration:  sudo systemctl restart dhcpcd",
            "title": "Configuring a static IP"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#configuring-the-dhcp-server-dnsmasq",
            "text": "The DHCP service is provided by dnsmasq. By default, the configuration file contains a lot of information that is not needed, and it is easier to start from scratch. Rename this configuration file, and edit a new one:  sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig  \nsudo nano /etc/dnsmasq.conf  Type or copy the following information into the dnsmasq configuration file and save it:  interface=wlan0      # Use the require wireless interface - usually wlan0\n  dhcp-range=192.168.4.2,192.168.4.20,255.255.255.0,24h  So for  wlan0 , we are going to provide IP addresses between 192.168.4.2 and 192.168.4.20, with a lease time of 24 hours. If you are providing DHCP services for other network devices (e.g. eth0), you could add more sections with the appropriate interface header, with the range of addresses you intend to provide to that interface.  There are many more options for dnsmasq; see the  dnsmasq documentation  for more details.",
            "title": "Configuring the DHCP server (dnsmasq)"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#configuring-the-access-point-host-software-hostapd",
            "text": "You need to edit the hostapd configuration file, located at /etc/hostapd/hostapd.conf, to add the various parameters for your wireless network. After initial install, this will be a new/empty file.  sudo nano /etc/hostapd/hostapd.conf  Add the information below to the configuration file. This configuration assumes we are using channel 7, with a network name of NameOfNetwork, and a password AardvarkBadgerHedgehog. Note that the name and password should  not  have quotes around them.   interface=wlan0\ndriver=nl80211\nssid=NameOfNetwork\nhw_mode=g\nchannel=7\nwmm_enabled=0\nmacaddr_acl=0\nauth_algs=1\nignore_broadcast_ssid=0\nwpa=2\nwpa_passphrase=AardvarkBadgerHedgehog\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=TKIP\nrsn_pairwise=CCMP  We now need to tell the system where to find this configuration file.  sudo nano /etc/default/hostapd  Find the line with #DAEMON_CONF, and replace it with this:  DAEMON_CONF=\"/etc/hostapd/hostapd.conf\"",
            "title": "Configuring the access point host software (hostapd)"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#start-it-up",
            "text": "Now start up the remaining services:  sudo systemctl start hostapd\nsudo systemctl start dnsmasq",
            "title": "Start it up"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#add-routing-and-masquerade",
            "text": "Edit /etc/sysctl.conf and uncomment this line:  net.ipv4.ip_forward=1  Add a masquerade for outbound traffic on eth0:  sudo iptables -t nat -A  POSTROUTING -o eth0 -j MASQUERADE  Save the iptables rule.  sudo sh -c \"iptables-save > /etc/iptables.ipv4.nat\"  Edit /etc/rc.local and add this just above \"exit 0\" to install these rules on boot.  iptables-restore < /etc/iptables.ipv4.nat  Reboot  Using a wireless device, search for networks. The network SSID you specified in the hostapd configuration should now be present, and it should be accessible with the specified password.  If SSH is enabled on the Raspberry Pi access point, it should be possible to connect to it from another Linux box (or a system with SSH connectivity present) as follows, assuming the  pi  account is present:  ssh   pi @192.168.4.1   By this point, the Raspberry Pi is acting as an access point, and other devices can associate with it. Associated devices can access the Raspberry Pi access point via its IP address for operations such as  rsync ,  scp , or  ssh .",
            "title": "Add routing and masquerade"
        },
        {
            "location": "/configuration/wireless/access-point/index.html#using-the-raspberry-pi-as-an-access-point-to-share-an-internet-connection",
            "text": "One common use of the Raspberry Pi as an access point is to provide wireless connections to a wired Ethernet connection, so that anyone logged into the access point can access the internet, providing of course that the wired Ethernet on the Pi can connect to the internet via some sort of router.  To do this, a 'bridge' needs to put in place between the wireless device and the Ethernet device on the access point Raspberry Pi. This bridge will pass all traffic between the two interfaces. Install the following packages to enable the access point setup and bridging.  sudo apt-get install hostapd bridge-utils  Since the configuration files are not ready yet, turn the new software off as follows:   sudo systemctl stop hostapd  Bridging creates a higher-level construct over the two ports being bridged. It is the bridge that is the network device, so we need to stop the  eth0  and  wlan0  ports being allocated IP addresses by the DHCP client on the Raspberry Pi.  sudo nano /etc/dhcpcd.conf  Add  denyinterfaces wlan0  and  denyinterfaces eth0  to the end of the file (but above any other added  interface  lines) and save the file.  Add a new bridge, which in this case is called  br0 .  sudo brctl addbr br0  Connect the network ports. In this case, connect  eth0  to the bridge  br0 .  sudo brctl addif br0 eth0  Now the interfaces file needs to be edited to adjust the various devices to work with bridging.  sudo nano /etc/network/interfaces  make the following edits.  Add the bridging information at the end of the file.  # Bridge setup\nauto br0\niface br0 inet manual\nbridge_ports eth0 wlan0  The access point setup is almost the same as that shown in the previous section. Follow the instructions above to set up the  hostapd.conf  file, but add  bridge=br0  below the  interface=wlan0  line, and remove or comment out the driver line.  interface=wlan0\nbridge=br0\n#driver=nl80211\n...  Now reboot the Raspberry Pi.  There should now be a functioning bridge between the wireless LAN and the Ethernet connection on the Raspberry Pi, and any device associated with the Raspberry Pi access point will act as if it is connected to the access point's wired Ethernet.  The  ifconfig  command will show the bridge, which will have been allocated an IP address via the wired Ethernet's DHCP server. The  wlan0  and  eth0  no longer have IP addresses, as they are now controlled by the bridge. It is possible to use a static IP address for the bridge if required, but generally, if the Raspberry Pi access point is connected to a ADSL router, the DHCP address will be fine.",
            "title": "Using the Raspberry Pi as an access point to share an internet connection"
        },
        {
            "location": "/configuration/wireless/desktop/index.html",
            "text": "Wireless connectivity in the PIXEL desktop\n\n\nA GUI is provided for setting up wireless connections in Raspbian with the PIXEL desktop. If you are not using the PIXEL desktop, you can set up wireless networking from the \ncommand line\n.\n\n\nWireless connections can be made via the network icon at the right hand end of the menu bar. If a wireless dongle is plugged in, left-clicking this icon will bring up a list of available wireless networks, as shown below. If no networks are found, it will show the message \"No APs found - scanning...\". Wait a few seconds without closing the menu, and it should find your network.\n\n\n\n\nThe icons on the right show whether a network is secured or not, and give an indication of its signal strength. Click the network that you want to connect to. If it is secured, a dialogue box will prompt you to enter the network key:\n\n\n\n\nEnter the key and press \nOK\n, then wait a couple of seconds. The network icon will flash briefly to show that a connection is being made. When it is ready, the icon will stop flashing and show the signal strength.",
            "title": "Wireless connectivity in the PIXEL desktop"
        },
        {
            "location": "/configuration/wireless/desktop/index.html#wireless-connectivity-in-the-pixel-desktop",
            "text": "A GUI is provided for setting up wireless connections in Raspbian with the PIXEL desktop. If you are not using the PIXEL desktop, you can set up wireless networking from the  command line .  Wireless connections can be made via the network icon at the right hand end of the menu bar. If a wireless dongle is plugged in, left-clicking this icon will bring up a list of available wireless networks, as shown below. If no networks are found, it will show the message \"No APs found - scanning...\". Wait a few seconds without closing the menu, and it should find your network.   The icons on the right show whether a network is secured or not, and give an indication of its signal strength. Click the network that you want to connect to. If it is secured, a dialogue box will prompt you to enter the network key:   Enter the key and press  OK , then wait a couple of seconds. The network icon will flash briefly to show that a connection is being made. When it is ready, the icon will stop flashing and show the signal strength.",
            "title": "Wireless connectivity in the PIXEL desktop"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html",
            "text": "Setting WiFi up via the command line\n\n\nThis method is suitable if you don't have access to the graphical user interface normally used to set up WiFi on the Raspberry Pi. It is particularly suitable for use with a serial console cable if you don't have access to a screen or wired Ethernet network. Note also that no additional software is required; everything you need is already included on the Raspberry Pi.   \n\n\nGetting WiFi network details\n\n\nTo scan for WiFi networks, use the command \nsudo iwlist wlan0 scan\n. This will list all available WiFi networks, along with other useful information. Look out for:\n\n\n\n\n\n\n'ESSID:\"testing\"' is the name of the WiFi network.   \n\n\n\n\n\n\n'IE: IEEE 802.11i/WPA2 Version 1' is the authentication used. In this case it's WPA2, the newer and more secure wireless standard which replaces WPA. This guide should work for WPA or WPA2, but may not work for WPA2 enterprise. For WEP hex keys, see the last example \nhere\n. You'll also need the password for the wireless network. For most home routers, this is found on a sticker on the back of the router. The ESSID (ssid) for the examples below is \ntesting\n and the password (psk) is \ntestingPassword\n.\n\n\n\n\n\n\nAdding the network details to the Raspberry Pi\n\n\nOpen the \nwpa-supplicant\n configuration file in nano:\n\n\nsudo nano /etc/wpa_supplicant/wpa_supplicant.conf\n  \n\n\nGo to the bottom of the file and add the following:   \n\n\nnetwork={\n    ssid=\"testing\"\n    psk=\"testingPassword\"\n}\n\n\n\n\n\nThe password can be configured either as the ASCII representation, in quotes as per the example above, or as a pre-encrypted 32 byte hexadecimal number. You can use the \nwpa_passphrase\n utility to generate an encrypted PSK. This takes the SSID and the password, and generates the encrypted PSK. With the example from above, you can generate the PSK with \nwpa_passphrase \"testing\" \"testingPassword\"\n. The output is as follows.\n\n\nnetwork={\n      ssid=\"testing\"\n      #psk=\"testingPassword\"\n      psk=131e1e221f6e06e3911a2d11ff2fac9182665c004de85300f9cac208a6a80531\n  }\n\nNote that the plain text version of the code is present, but commented out. You should delete this line from the final \nwpa_supplicant\n file for extra security.\n\n\nThe \nwpa_passphrase\n tool requires a password with between 8 and 63 characters. For more complex passphrases you can extract the content of a text file and use it as input for \nwpa_passphrase\n, if the password is stored as plain text inside a file somewhere, by calling \nwpa_passphrase \"testing\" < file_where_password_is_stored\n. For extra security, you should delete the \nfile_where_password_is_stored\n afterwards, so there is no plain text copy of the original password on the system.\n\n\nIf you are using the \nwpa_passphrase\n encrypted PSK you can either copy and paste the encrypted PSK into the \nwpa_supplicant.conf\n file,  or redirect the tools output to your configuration file by calling \nwpa_passphrase \"testing\" \"testingPassword\" >> /etc/wpa_supplicant/wpa_supplicant.conf\n. Note that this requires you to change to \nroot\n (by executing \nsudo su\n), or you can use \nwpa_passphrase \"testing\" \"testingPassword\" | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf > /dev/null\n, which will append the passphrase without having to change to \nroot\n. Both methods provide the necessary administrative privileges to change the file. Lastly, make sure you use \n>>\n, or use \n-a\n with \ntee\n, (both can be used to append text to an existing file) since \n>\n, or omitting \n-a\n when using \ntee\n, will erase all contents and \nthen\n append the output to the specified file. Note that the redirection to \n/dev/null\n at the end of the second form simply prevents \ntee\n from \nalso\n outputting to the screen (standard output).\n\n\nNow save the file by pressing \nCtrl+X\n, then \nY\n, then finally press \nEnter\n.  \n\n\nReconfigure the interface with \nwpa_cli -i wlan0 reconfigure\n.\n\n\nYou can verify whether it has successfully connected using \nifconfig wlan0\n. If the \ninet addr\n field has an address beside it, the Raspberry Pi has connected to the network. If not, check that your password and ESSID are correct.  \n\n\nUnsecured Networks\n\n\nIf the network you are connecting to does not use a password, the \nwpa_supplicant\n entry for the network will need to include the correct \nkey_mgmt\n entry.\ne.g.\n\n\nnetwork={\n    ssid=\"testing\"\n    key_mgmt=NONE\n}\n\n\n\n\n\nHidden Networks\n\n\nIf you are using a hidden network, an extra option in the \nwpa_supplicant file\n, \nscan_ssid\n, may help connection.\n\n\nnetwork={\n    ssid=\"yourHiddenSSID\"\n    scan_ssid=1\n    psk=\"Your_wifi_password\"\n}\n\n\n\n\n\nYou can verify whether it has successfully connected using \nifconfig wlan0\n. If the \ninet addr\n field has an address beside it, the Raspberry Pi has connected to the network. If not, check your password and ESSID are correct.   \n\n\nAdding multiple wireless network configurations\n\n\nOn recent versions of Raspbian, it is possible to set up multiple configurations for wireless networking. For example, you could set up one for home and one for school.\n\n\nFor example\n\n\nnetwork={\n    ssid=\"SchoolNetworkSSID\"\n    psk=\"passwordSchool\"\n    id_str=\"school\"\n}\n\nnetwork={\n    ssid=\"HomeNetworkSSID\"\n    psk=\"passwordHome\"\n    id_str=\"home\"\n}\n\n\n\n\n\nIf you have two networks in range, you can add the priority option to choose between them. The network in range, with the highest priority, will be the one that is connected.\n\n\nnetwork={\n    ssid=\"HomeOneSSID\"\n    psk=\"passwordOne\"\n    priority=1\n    id_str=\"homeOne\"\n}\n\nnetwork={\n    ssid=\"HomeTwoSSID\"\n    psk=\"passwordTwo\"\n    priority=2\n    id_str=\"homeTwo\"\n}",
            "title": "Setting WiFi up via the command line"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#setting-wifi-up-via-the-command-line",
            "text": "This method is suitable if you don't have access to the graphical user interface normally used to set up WiFi on the Raspberry Pi. It is particularly suitable for use with a serial console cable if you don't have access to a screen or wired Ethernet network. Note also that no additional software is required; everything you need is already included on the Raspberry Pi.",
            "title": "Setting WiFi up via the command line"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#getting-wifi-network-details",
            "text": "To scan for WiFi networks, use the command  sudo iwlist wlan0 scan . This will list all available WiFi networks, along with other useful information. Look out for:    'ESSID:\"testing\"' is the name of the WiFi network.       'IE: IEEE 802.11i/WPA2 Version 1' is the authentication used. In this case it's WPA2, the newer and more secure wireless standard which replaces WPA. This guide should work for WPA or WPA2, but may not work for WPA2 enterprise. For WEP hex keys, see the last example  here . You'll also need the password for the wireless network. For most home routers, this is found on a sticker on the back of the router. The ESSID (ssid) for the examples below is  testing  and the password (psk) is  testingPassword .",
            "title": "Getting WiFi network details"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#adding-the-network-details-to-the-raspberry-pi",
            "text": "Open the  wpa-supplicant  configuration file in nano:  sudo nano /etc/wpa_supplicant/wpa_supplicant.conf     Go to the bottom of the file and add the following:     network={\n    ssid=\"testing\"\n    psk=\"testingPassword\"\n}  The password can be configured either as the ASCII representation, in quotes as per the example above, or as a pre-encrypted 32 byte hexadecimal number. You can use the  wpa_passphrase  utility to generate an encrypted PSK. This takes the SSID and the password, and generates the encrypted PSK. With the example from above, you can generate the PSK with  wpa_passphrase \"testing\" \"testingPassword\" . The output is as follows.  network={\n      ssid=\"testing\"\n      #psk=\"testingPassword\"\n      psk=131e1e221f6e06e3911a2d11ff2fac9182665c004de85300f9cac208a6a80531\n  } \nNote that the plain text version of the code is present, but commented out. You should delete this line from the final  wpa_supplicant  file for extra security.  The  wpa_passphrase  tool requires a password with between 8 and 63 characters. For more complex passphrases you can extract the content of a text file and use it as input for  wpa_passphrase , if the password is stored as plain text inside a file somewhere, by calling  wpa_passphrase \"testing\" < file_where_password_is_stored . For extra security, you should delete the  file_where_password_is_stored  afterwards, so there is no plain text copy of the original password on the system.  If you are using the  wpa_passphrase  encrypted PSK you can either copy and paste the encrypted PSK into the  wpa_supplicant.conf  file,  or redirect the tools output to your configuration file by calling  wpa_passphrase \"testing\" \"testingPassword\" >> /etc/wpa_supplicant/wpa_supplicant.conf . Note that this requires you to change to  root  (by executing  sudo su ), or you can use  wpa_passphrase \"testing\" \"testingPassword\" | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf > /dev/null , which will append the passphrase without having to change to  root . Both methods provide the necessary administrative privileges to change the file. Lastly, make sure you use  >> , or use  -a  with  tee , (both can be used to append text to an existing file) since  > , or omitting  -a  when using  tee , will erase all contents and  then  append the output to the specified file. Note that the redirection to  /dev/null  at the end of the second form simply prevents  tee  from  also  outputting to the screen (standard output).  Now save the file by pressing  Ctrl+X , then  Y , then finally press  Enter .    Reconfigure the interface with  wpa_cli -i wlan0 reconfigure .  You can verify whether it has successfully connected using  ifconfig wlan0 . If the  inet addr  field has an address beside it, the Raspberry Pi has connected to the network. If not, check that your password and ESSID are correct.",
            "title": "Adding the network details to the Raspberry Pi"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#unsecured-networks",
            "text": "If the network you are connecting to does not use a password, the  wpa_supplicant  entry for the network will need to include the correct  key_mgmt  entry.\ne.g.  network={\n    ssid=\"testing\"\n    key_mgmt=NONE\n}",
            "title": "Unsecured Networks"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#hidden-networks",
            "text": "If you are using a hidden network, an extra option in the  wpa_supplicant file ,  scan_ssid , may help connection.  network={\n    ssid=\"yourHiddenSSID\"\n    scan_ssid=1\n    psk=\"Your_wifi_password\"\n}  You can verify whether it has successfully connected using  ifconfig wlan0 . If the  inet addr  field has an address beside it, the Raspberry Pi has connected to the network. If not, check your password and ESSID are correct.",
            "title": "Hidden Networks"
        },
        {
            "location": "/configuration/wireless/wireless-cli/index.html#adding-multiple-wireless-network-configurations",
            "text": "On recent versions of Raspbian, it is possible to set up multiple configurations for wireless networking. For example, you could set up one for home and one for school.  For example  network={\n    ssid=\"SchoolNetworkSSID\"\n    psk=\"passwordSchool\"\n    id_str=\"school\"\n}\n\nnetwork={\n    ssid=\"HomeNetworkSSID\"\n    psk=\"passwordHome\"\n    id_str=\"home\"\n}  If you have two networks in range, you can add the priority option to choose between them. The network in range, with the highest priority, will be the one that is connected.  network={\n    ssid=\"HomeOneSSID\"\n    psk=\"passwordOne\"\n    priority=1\n    id_str=\"homeOne\"\n}\n\nnetwork={\n    ssid=\"HomeTwoSSID\"\n    psk=\"passwordTwo\"\n    priority=2\n    id_str=\"homeTwo\"\n}",
            "title": "Adding multiple wireless network configurations"
        },
        {
            "location": "/hardware/README/index.html",
            "text": "Raspberry Pi Hardware\n\n\nTechnical information about Raspberry Pi hardware, including official add-ons and the Pi itself.\n\n\nContents\n\n\n\n\nRaspberry Pi\n\n\nCamera Module\n\n\nCompute Module\n\n\nSense HAT\n\n\nDisplay\n\n\nIndustrial use",
            "title": "Raspberry Pi Hardware"
        },
        {
            "location": "/hardware/README/index.html#raspberry-pi-hardware",
            "text": "Technical information about Raspberry Pi hardware, including official add-ons and the Pi itself.",
            "title": "Raspberry Pi Hardware"
        },
        {
            "location": "/hardware/README/index.html#contents",
            "text": "Raspberry Pi  Camera Module  Compute Module  Sense HAT  Display  Industrial use",
            "title": "Contents"
        },
        {
            "location": "/hardware/camera/README/index.html",
            "text": "Camera Module\n\n\nThe Raspberry Pi Camera Module is an official product from the Raspberry Pi Foundation. The original 5-megapixel model was \nreleased\n in 2013, and an 8-megapixel Camera Module v2 was \nreleased\n in 2016. For both iterations, there are visible light and infrared versions.\n\n\nHardware specification\n\n\n\n\n\n\n\n\n\n\nCamera Module v1\n\n\nCamera Module v2\n\n\n\n\n\n\n\n\n\n\nNet price\n\n\n$25\n\n\n$25\n\n\n\n\n\n\nSize\n\n\nAround 25 \u00d7 24 \u00d7 9 mm\n\n\n\n\n\n\n\n\nWeight\n\n\n3g\n\n\n3g\n\n\n\n\n\n\nStill resolution\n\n\n5 Megapixels\n\n\n8 Megapixels\n\n\n\n\n\n\nVideo modes\n\n\n1080p30, 720p60 and 640 \u00d7 480p60/90\n\n\n1080p30, 720p60 and 640 \u00d7 480p60/90\n\n\n\n\n\n\nLinux integration\n\n\nV4L2 driver available\n\n\nV4L2 driver available\n\n\n\n\n\n\nC programming API\n\n\nOpenMAX IL and others available\n\n\nOpenMAX IL and others available\n\n\n\n\n\n\nSensor\n\n\nOmniVision OV5647\n\n\nSony IMX219\n\n\n\n\n\n\nSensor resolution\n\n\n2592 \u00d7 1944 pixels\n\n\n3280 \u00d7 2464 pixels\n\n\n\n\n\n\nSensor image area\n\n\n3.76 \u00d7 2.74 mm\n\n\n3.68 x 2.76 mm (4.6 mm diagonal)\n\n\n\n\n\n\nPixel size\n\n\n1.4 \u00b5m \u00d7 1.4 \u00b5m\n\n\n1.12 \u00b5m x 1.12 \u00b5m\n\n\n\n\n\n\nOptical size\n\n\n1/4\"\n\n\n1/4\"\n\n\n\n\n\n\nFull-frame SLR lens equivalent\n\n\n35 mm\n\n\n\n\n\n\n\n\nS/N ratio\n\n\n36 dB\n\n\n\n\n\n\n\n\nDynamic range\n\n\n67 dB @ 8x gain\n\n\n\n\n\n\n\n\nSensitivity\n\n\n680 mV/lux-sec\n\n\n\n\n\n\n\n\nDark current\n\n\n16 mV/sec @ 60 C\n\n\n\n\n\n\n\n\nWell capacity\n\n\n4.3 Ke-\n\n\n\n\n\n\n\n\nFixed focus\n\n\n1 m to infinity\n\n\n\n\n\n\n\n\nFocal length\n\n\n3.60 mm +/- 0.01\n\n\n3.04 mm\n\n\n\n\n\n\nHorizontal field of view\n\n\n53.50  +/- 0.13 degrees\n\n\n62.2 degrees\n\n\n\n\n\n\nVertical field of view\n\n\n41.41 +/- 0.11 degrees\n\n\n48.8 degrees\n\n\n\n\n\n\nFocal ratio (F-Stop)\n\n\n2.9\n\n\n2.0\n\n\n\n\n\n\n\n\nHardware features\n\n\n\n\n\n\n\n\nAvailable\n\n\nImplemented\n\n\n\n\n\n\n\n\n\n\nChief ray angle correction\n\n\nYes\n\n\n\n\n\n\nGlobal and rolling shutter\n\n\nRolling shutter\n\n\n\n\n\n\nAutomatic exposure control (AEC)\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nAutomatic white balance (AWB)\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nAutomatic black level calibration (ABLC)\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nAutomatic 50/60 Hz luminance detection\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nFrame rate up to 120 fps\n\n\nMax 90fps. Limitations on frame size for the higher frame rates (VGA only for above 47fps)\n\n\n\n\n\n\nAEC/AGC 16-zone size/position/weight control\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nMirror and flip\n\n\nYes\n\n\n\n\n\n\nCropping\n\n\nNo - done by ISP instead (except 1080p mode)\n\n\n\n\n\n\nLens correction\n\n\nNo - done by ISP instead\n\n\n\n\n\n\nDefective pixel cancelling\n\n\nNo - done by ISP instead\n\n\n\n\n\n\n10-bit RAW RGB data\n\n\nYes - format conversions available via GPU\n\n\n\n\n\n\nSupport for LED and flash strobe mode\n\n\nLED flash\n\n\n\n\n\n\nSupport for internal and external frame synchronisation for frame exposure mode\n\n\nNo\n\n\n\n\n\n\nSupport for 2 \u00d7 2 binning for better SNR in low light conditions\n\n\nAnything output res below 1296 x 976 will use the 2 x 2 binned mode\n\n\n\n\n\n\nSupport for horizontal and vertical sub-sampling\n\n\nYes, via binning and skipping\n\n\n\n\n\n\nOn-chip phase lock loop (PLL)\n\n\nYes\n\n\n\n\n\n\nStandard serial SCCB interface\n\n\nYes\n\n\n\n\n\n\nDigital video port (DVP) parallel output interface\n\n\nNo\n\n\n\n\n\n\nMIPI interface (two lanes)\n\n\nYes\n\n\n\n\n\n\n32 bytes of embedded one-time programmable (OTP) memory\n\n\nNo\n\n\n\n\n\n\nEmbedded 1.5V regulator for core power\n\n\nYes\n\n\n\n\n\n\n\n\nSoftware features\n\n\nFull camera software documentation can be found at \nraspbian/applications/camera\n.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPicture formats\n\n\nJPEG (accelerated), JPEG + RAW, GIF, BMP, PNG, YUV420, RGB888\n\n\n\n\n\n\nVideo formats\n\n\nraw h.264 (accelerated)\n\n\n\n\n\n\nEffects\n\n\nnegative, solarise, posterize, whiteboard, blackboard, sketch, denoise, emboss, oilpaint, hatch, gpen, pastel, watercolour, film, blur, saturation\n\n\n\n\n\n\nExposure modes\n\n\nauto, night, nightpreview, backlight, spotlight, sports, snow, beach, verylong, fixedfps, antishake, fireworks\n\n\n\n\n\n\nMetering modes\n\n\naverage, spot, backlit, matrix\n\n\n\n\n\n\nAutomatic white balance modes\n\n\noff, auto, sun, cloud, shade, tungsten, fluorescent, incandescent, flash, horizon\n\n\n\n\n\n\nTriggers\n\n\nKeypress, UNIX signal, timeout\n\n\n\n\n\n\nExtra modes\n\n\ndemo, burst/timelapse, circular buffer, video with motion vectors, segmented video, live preview on 3D models\n\n\n\n\n\n\n\n\nMechanical drawing\n\n\n\n\nCamera Module v2 \nPDF",
            "title": "Camera Module"
        },
        {
            "location": "/hardware/camera/README/index.html#camera-module",
            "text": "The Raspberry Pi Camera Module is an official product from the Raspberry Pi Foundation. The original 5-megapixel model was  released  in 2013, and an 8-megapixel Camera Module v2 was  released  in 2016. For both iterations, there are visible light and infrared versions.",
            "title": "Camera Module"
        },
        {
            "location": "/hardware/camera/README/index.html#hardware-specification",
            "text": "Camera Module v1  Camera Module v2      Net price  $25  $25    Size  Around 25 \u00d7 24 \u00d7 9 mm     Weight  3g  3g    Still resolution  5 Megapixels  8 Megapixels    Video modes  1080p30, 720p60 and 640 \u00d7 480p60/90  1080p30, 720p60 and 640 \u00d7 480p60/90    Linux integration  V4L2 driver available  V4L2 driver available    C programming API  OpenMAX IL and others available  OpenMAX IL and others available    Sensor  OmniVision OV5647  Sony IMX219    Sensor resolution  2592 \u00d7 1944 pixels  3280 \u00d7 2464 pixels    Sensor image area  3.76 \u00d7 2.74 mm  3.68 x 2.76 mm (4.6 mm diagonal)    Pixel size  1.4 \u00b5m \u00d7 1.4 \u00b5m  1.12 \u00b5m x 1.12 \u00b5m    Optical size  1/4\"  1/4\"    Full-frame SLR lens equivalent  35 mm     S/N ratio  36 dB     Dynamic range  67 dB @ 8x gain     Sensitivity  680 mV/lux-sec     Dark current  16 mV/sec @ 60 C     Well capacity  4.3 Ke-     Fixed focus  1 m to infinity     Focal length  3.60 mm +/- 0.01  3.04 mm    Horizontal field of view  53.50  +/- 0.13 degrees  62.2 degrees    Vertical field of view  41.41 +/- 0.11 degrees  48.8 degrees    Focal ratio (F-Stop)  2.9  2.0",
            "title": "Hardware specification"
        },
        {
            "location": "/hardware/camera/README/index.html#hardware-features",
            "text": "Available  Implemented      Chief ray angle correction  Yes    Global and rolling shutter  Rolling shutter    Automatic exposure control (AEC)  No - done by ISP instead    Automatic white balance (AWB)  No - done by ISP instead    Automatic black level calibration (ABLC)  No - done by ISP instead    Automatic 50/60 Hz luminance detection  No - done by ISP instead    Frame rate up to 120 fps  Max 90fps. Limitations on frame size for the higher frame rates (VGA only for above 47fps)    AEC/AGC 16-zone size/position/weight control  No - done by ISP instead    Mirror and flip  Yes    Cropping  No - done by ISP instead (except 1080p mode)    Lens correction  No - done by ISP instead    Defective pixel cancelling  No - done by ISP instead    10-bit RAW RGB data  Yes - format conversions available via GPU    Support for LED and flash strobe mode  LED flash    Support for internal and external frame synchronisation for frame exposure mode  No    Support for 2 \u00d7 2 binning for better SNR in low light conditions  Anything output res below 1296 x 976 will use the 2 x 2 binned mode    Support for horizontal and vertical sub-sampling  Yes, via binning and skipping    On-chip phase lock loop (PLL)  Yes    Standard serial SCCB interface  Yes    Digital video port (DVP) parallel output interface  No    MIPI interface (two lanes)  Yes    32 bytes of embedded one-time programmable (OTP) memory  No    Embedded 1.5V regulator for core power  Yes",
            "title": "Hardware features"
        },
        {
            "location": "/hardware/camera/README/index.html#software-features",
            "text": "Full camera software documentation can be found at  raspbian/applications/camera .           Picture formats  JPEG (accelerated), JPEG + RAW, GIF, BMP, PNG, YUV420, RGB888    Video formats  raw h.264 (accelerated)    Effects  negative, solarise, posterize, whiteboard, blackboard, sketch, denoise, emboss, oilpaint, hatch, gpen, pastel, watercolour, film, blur, saturation    Exposure modes  auto, night, nightpreview, backlight, spotlight, sports, snow, beach, verylong, fixedfps, antishake, fireworks    Metering modes  average, spot, backlit, matrix    Automatic white balance modes  off, auto, sun, cloud, shade, tungsten, fluorescent, incandescent, flash, horizon    Triggers  Keypress, UNIX signal, timeout    Extra modes  demo, burst/timelapse, circular buffer, video with motion vectors, segmented video, live preview on 3D models",
            "title": "Software features"
        },
        {
            "location": "/hardware/camera/README/index.html#mechanical-drawing",
            "text": "Camera Module v2  PDF",
            "title": "Mechanical drawing"
        },
        {
            "location": "/hardware/computemodule/README/index.html",
            "text": "Compute Module\n\n\nEmbedded Raspberry Pi.\n\n\n\n\nDatasheet\n\n\nDatasheet for the Compute Modules and related boards\n\n\n\n\n\n\nSchematics\n\n\nSchematics for the Compute Modules and related boards\n\n\n\n\n\n\nCMIO and CMCDA design files\n\n\nDesign data for Compute Module IO and camera/display adapter boards\n\n\n\n\n\n\nCompute Module hardware design guide\n\n\nNotes for designing with the Compute Module\n\n\n\n\n\n\nFlashing the Compute Module eMMC\n\n\nHow to (re)write the eMMC flash on the Compute Module, using a Compute Module IO Board\n\n\n\n\n\n\nCompute Module attaching and enabling peripherals guide\n\n\nGuide to wiring up peripherals and enabling them, using Device Tree\n\n\n\n\n\n\nAttaching a Raspberry Pi camera\n \n\n\nHow to attach a Raspberry Pi camera to the Compute Module IO Board\n\n\n\n\n\n\nAttaching the official 7-inch display\n\n\nHow to attach the Raspberry Pi 7-inch display to the Compute Module IO Board",
            "title": "Compute Module"
        },
        {
            "location": "/hardware/computemodule/README/index.html#compute-module",
            "text": "Embedded Raspberry Pi.   Datasheet  Datasheet for the Compute Modules and related boards    Schematics  Schematics for the Compute Modules and related boards    CMIO and CMCDA design files  Design data for Compute Module IO and camera/display adapter boards    Compute Module hardware design guide  Notes for designing with the Compute Module    Flashing the Compute Module eMMC  How to (re)write the eMMC flash on the Compute Module, using a Compute Module IO Board    Compute Module attaching and enabling peripherals guide  Guide to wiring up peripherals and enabling them, using Device Tree    Attaching a Raspberry Pi camera    How to attach a Raspberry Pi camera to the Compute Module IO Board    Attaching the official 7-inch display  How to attach the Raspberry Pi 7-inch display to the Compute Module IO Board",
            "title": "Compute Module"
        },
        {
            "location": "/hardware/computemodule/cm-designguide/index.html",
            "text": "Compute Module Hardware Design Guide\n\n\nFor design guidelines please see the \nCompute Module datasheet.",
            "title": "Compute Module Hardware Design Guide"
        },
        {
            "location": "/hardware/computemodule/cm-designguide/index.html#compute-module-hardware-design-guide",
            "text": "For design guidelines please see the  Compute Module datasheet.",
            "title": "Compute Module Hardware Design Guide"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html",
            "text": "Flashing the Compute Module eMMC\n\n\nThe Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board.\n\n\nPlease also read the section on the \nCompute Module Datasheet\n.\n\n\nSteps to flash the eMMC on a Compute Module\n\n\nTo flash the Compute Module eMMC, you either need a Linux system (a Raspberry Pi is recommended, or Ubuntu on a PC) or a Windows system (Windows 7 is recommended). For BCM2837 (CM3), a bug which affected the Mac has been fixed, so this will also work.\n\n\nNote\n There is a bug in the BCM2835 (CM1) bootloader which returns a slightly incorrect USB packet to the host. Most USB hosts seem to ignore this benign bug and work fine; we do, however, see some USB ports that don't work due to this bug. We don't quite understand why some ports fail, as it doesn't seem to be correlated with whether they are USB2 or USB3 (we have seen both types working), but it's likely to be specific to the host controller and driver. This bug has been fixed in BCM2837.\n\n\nFor Windows users\n\n\nUnder Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually.\n\n\nWindows installer\n\n\nFor those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit.\n\n\nPlease ensure you are not writing to any USB devices whilst the installer is running.\n\n\n\n\nDownload and run the \nWindows installer\n to install the drivers and boot tool.\n\n\nPlug your host PC USB into the CMIO USB SLAVE port, making sure J4 is set to the EN position.\n\n\nApply power to the CMIO board; Windows should now find the hardware and install the driver.\n\n\nOnce the driver installation is complete, run the \nRPiBoot.exe\n tool that was previously installed.\n\n\nAfter a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device).\n\n\n\n\nSetting up the Compute Module IO board\n\n\nEnsure the Compute Module itself is correctly installed on the IO board. It should lie parallel with the board, with the engagement clips clicked into place.\n\n\nMake sure that J4 (USB SLAVE BOOT ENABLE) is set to the 'EN' position.\n\n\nUse a micro USB cable to connect the IO board to the host device.\n\n\nDo not power up yet.\n\n\nBuilding rpiboot on your host system (Cygwin/Linux)\n\n\nWe will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Pi or other Debian-based Linux machine, use the following command:\n\n\nsudo apt-get install git\n\n\n\n\n\nGit may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this:\n\n\nsudo date MMDDhhmm\n\n\n\n\n\nwhere \nMM\n is the month, \nDD\n is the date, and \nhh\n and \nmm\n are hours and minutes respectively.\n\n\nClone the \nusbboot\n tool repository:\n\n\ngit clone --depth\n=\n1\n https://github.com/raspberrypi/usbboot\n\ncd\n usbboot\n\n\n\n\n\nlibusb\n must be installed. If you are using Cygwin, please make sure \nlibusb\n is installed as previously described. On the Raspberry Pi or other Debian-based Linux, enter the following command:\n\n\nsudo apt-get install libusb-1.0-0-dev\n\n\n\n\n\nNow build and install the \nusbboot\n tool:\n\n\nmake\n\n\n\n\n\nRun the \nusbboot\n tool and it will wait for a connection:\n\n\nsudo ./rpiboot\n\n\n\n\n\nNow plug the host machine into the Compute Module IO board USB slave port (J15) and power the CMIO board on. The \nrpiboot\n tool will discover the Compute Module and send boot code to allow access to the eMMC. \n\n\nWriting to the eMMC - Windows\n\n\nAfter \nrpiboot\n completes, a new USB mass storage drive will appear in Windows. We recommend following this \nguide\n and using Win32DiskImager to write images to the drive, rather than trying to use \n/dev/sda\n etc. from Cygwin.\n\n\nOnce you have written an OS image, make sure J4 (USB SLAVE BOOT ENABLE) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should result in the Compute Module booting the OS image from eMMC.\n\n\nWriting to the eMMC - Linux\n\n\nAfter \nrpiboot\n completes, you will see a new device appear; this is commonly \n/dev/sda\n on a Pi but it could be another location such as \n/dev/sdb\n, so check in \n/dev/\n or run \nlsblk\n before running \nrpiboot\n so you can see what changes.\n\n\nYou now need to write a raw OS image (such as \nRaspbian\n) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change \n/dev/sdX\n to the appropriate device.)\n\n\nsudo dd \nif\n=\nraw_os_image_of_your_choice.img \nof\n=\n/dev/sdX \nbs\n=\n4MiB\n\n\n\n\n\nOnce the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspbian) in \n/dev\n. In total, you should see something similar to this:\n\n\n/dev/sdX    <- Device\n/dev/sdX1   <- First partition \n(\nFAT\n)\n\n/dev/sdX2   <- Second partition \n(\nLinux filesystem\n)\n\n\n\n\n\n\nThe \n/dev/sdX1\n and \n/dev/sdX2\n partitions can now be mounted normally.\n\n\nMake sure J4 (USB SLAVE BOOT ENABLE) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC.",
            "title": "Flashing the Compute Module eMMC"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#flashing-the-compute-module-emmc",
            "text": "The Compute Module has an on-board eMMC device connected to the primary SD card interface. This guide explains how to write data to the eMMC storage using a Compute Module IO board.  Please also read the section on the  Compute Module Datasheet .",
            "title": "Flashing the Compute Module eMMC"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#steps-to-flash-the-emmc-on-a-compute-module",
            "text": "To flash the Compute Module eMMC, you either need a Linux system (a Raspberry Pi is recommended, or Ubuntu on a PC) or a Windows system (Windows 7 is recommended). For BCM2837 (CM3), a bug which affected the Mac has been fixed, so this will also work.  Note  There is a bug in the BCM2835 (CM1) bootloader which returns a slightly incorrect USB packet to the host. Most USB hosts seem to ignore this benign bug and work fine; we do, however, see some USB ports that don't work due to this bug. We don't quite understand why some ports fail, as it doesn't seem to be correlated with whether they are USB2 or USB3 (we have seen both types working), but it's likely to be specific to the host controller and driver. This bug has been fixed in BCM2837.  For Windows users  Under Windows, an installer is available to install the required drivers and boot tool automatically. Alternatively, a user can compile and run it using Cygwin and/or install the drivers manually.",
            "title": "Steps to flash the eMMC on a Compute Module"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#windows-installer",
            "text": "For those who just want to enable the Compute Module eMMC as a mass storage device under Windows, the stand-alone installer is the recommended option. This installer has been tested on Windows 10 32-bit and 64-bit, and Windows XP 32-bit.  Please ensure you are not writing to any USB devices whilst the installer is running.   Download and run the  Windows installer  to install the drivers and boot tool.  Plug your host PC USB into the CMIO USB SLAVE port, making sure J4 is set to the EN position.  Apply power to the CMIO board; Windows should now find the hardware and install the driver.  Once the driver installation is complete, run the  RPiBoot.exe  tool that was previously installed.  After a few seconds, the Compute Module eMMC will pop up under Windows as a disk (USB mass storage device).",
            "title": "Windows installer"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#setting-up-the-compute-module-io-board",
            "text": "Ensure the Compute Module itself is correctly installed on the IO board. It should lie parallel with the board, with the engagement clips clicked into place.  Make sure that J4 (USB SLAVE BOOT ENABLE) is set to the 'EN' position.  Use a micro USB cable to connect the IO board to the host device.  Do not power up yet.",
            "title": "Setting up the Compute Module IO board"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#building-rpiboot-on-your-host-system-cygwinlinux",
            "text": "We will be using Git to get the rpiboot source code, so ensure Git is installed. In Cygwin, use the Cygwin installer. On a Pi or other Debian-based Linux machine, use the following command:  sudo apt-get install git  Git may produce an error if the date is not set correctly. On a Raspberry Pi, enter the following to correct this:  sudo date MMDDhhmm  where  MM  is the month,  DD  is the date, and  hh  and  mm  are hours and minutes respectively.  Clone the  usbboot  tool repository:  git clone --depth = 1  https://github.com/raspberrypi/usbboot cd  usbboot  libusb  must be installed. If you are using Cygwin, please make sure  libusb  is installed as previously described. On the Raspberry Pi or other Debian-based Linux, enter the following command:  sudo apt-get install libusb-1.0-0-dev  Now build and install the  usbboot  tool:  make  Run the  usbboot  tool and it will wait for a connection:  sudo ./rpiboot  Now plug the host machine into the Compute Module IO board USB slave port (J15) and power the CMIO board on. The  rpiboot  tool will discover the Compute Module and send boot code to allow access to the eMMC.",
            "title": "Building rpiboot on your host system (Cygwin/Linux)"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#writing-to-the-emmc-windows",
            "text": "After  rpiboot  completes, a new USB mass storage drive will appear in Windows. We recommend following this  guide  and using Win32DiskImager to write images to the drive, rather than trying to use  /dev/sda  etc. from Cygwin.  Once you have written an OS image, make sure J4 (USB SLAVE BOOT ENABLE) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should result in the Compute Module booting the OS image from eMMC.",
            "title": "Writing to the eMMC - Windows"
        },
        {
            "location": "/hardware/computemodule/cm-emmc-flashing/index.html#writing-to-the-emmc-linux",
            "text": "After  rpiboot  completes, you will see a new device appear; this is commonly  /dev/sda  on a Pi but it could be another location such as  /dev/sdb , so check in  /dev/  or run  lsblk  before running  rpiboot  so you can see what changes.  You now need to write a raw OS image (such as  Raspbian ) to the device. Note the following command may take some time to complete, depending on the size of the image: (Change  /dev/sdX  to the appropriate device.)  sudo dd  if = raw_os_image_of_your_choice.img  of = /dev/sdX  bs = 4MiB  Once the image has been written, unplug and re-plug the USB; you should see two partitions appear (for Raspbian) in  /dev . In total, you should see something similar to this:  /dev/sdX    <- Device\n/dev/sdX1   <- First partition  ( FAT ) \n/dev/sdX2   <- Second partition  ( Linux filesystem )   The  /dev/sdX1  and  /dev/sdX2  partitions can now be mounted normally.  Make sure J4 (USB SLAVE BOOT ENABLE) is set to the disabled position and/or nothing is plugged into the USB slave port. Power cycling the IO board should now result in the Compute Module booting from eMMC.",
            "title": "Writing to the eMMC - Linux"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html",
            "text": "Compute Module Attaching and Enabling Peripherals Guide\n\n\n Note that unless explicitly stated otherwise, these instructions will work identically on Compute Module and Compute Module 3 Module+IO board(s). \n\n\nIntroduction\n\n\nThis guide is designed to help developers using the Compute Module (and Compute Module 3) get to grips with how to wire up peripherals to the Compute Module pins, and how to make changes to the software to enable these peripherals to work correctly.\n\n\nThe Compute Module (CM) and Compute Module 3 (CM3) contain the Raspberry Pi BCM2835 (or BCM2837 for CM3) system on a chip (SoC) or 'processor', memory, and eMMC. The eMMC is similar to an SD card but is soldered onto the board. Unlike SD cards, the eMMC is specifically designed to be used as a disk and has extra features that make it more reliable in this use case. Most of the pins of the SoC (GPIO, two CSI camera interfaces, two DSI display interfaces, HDMI etc) are freely available and can be wired up as the user sees fit (or, if unused, can usually be left unconnected). The Compute Module is a DDR2 SODIMM form-factor-compatible module, so any DDR2 SODIMM socket should be able to be used (note the pinout is NOT the same as an actual SODIMM memory module).\n\n\nTo use the Compute Module, a user needs to design a (relatively simple) 'motherboard' which can provide power to the Compute Module (3.3V and 1.8V at minimum), and which connects the pins to the required peripherals for the user's application.\n\n\nRaspberry Pi provides a minimal motherboard for the Compute Module (called the Compute Module IO Board, or CMIO Board) which powers the module, brings out the GPIO to pin headers, and brings the camera and display interfaces out to FFC connectors. It also provides HDMI, USB, and an 'ACT' LED, as well as the ability to program the eMMC of a module via USB from a PC or Raspberry Pi.\n\n\nThis guide first explains the boot process and how Device Tree is used to describe attached hardware; these are essential things to understand when designing with the Compute Module. It then provides a worked example of attaching an I2C and an SPI peripheral to a CMIO (or CMIO V3 for CM3) Board and creating the Device Tree files necessary to make both peripherals work under Linux, starting from a vanilla Raspbian OS image.\n\n\nBCM283x GPIOs\n\n\nBCM283x has three banks of General-Purpose Input/Output (GPIO) pins: 28 pins on Bank 0, 18 pins on Bank 1, and 8 pins on Bank 2, making 54 pins in total. These pins can be used as true GPIO  pins, i.e. software can set them as inputs or outputs, read and/or set state, and use them as interrupts. They also can be set to 'alternate functions' such as I2C, SPI, I2S, UART, SD card, and others.\n\n\nOn a Compute Module, both Bank 0 and Bank 1 are free to use. Bank 2 is used for eMMC and HDMI hot plug detect and ACT LED / USB boot control.\n\n\nIt is useful on a running system to look at the state of each of the GPIO pins (what function they are set to, and the voltage level at the pin) so that you can see if the system is set up as expected. This is particularly helpful if you want to see if a Device Tree is working as expected, or to get a look at the pin states during hardware debug.\n\n\nRaspberry Pi provides the \nraspi-gpio\n package which is a tool for hacking and debugging GPIO (NOTE: you need to run it as root).\nTo install \nraspi-gpio\n:\n\n\nsudo apt-get install raspi-gpio\n\n\n\n\n\nIf \napt-get\n can't find the \nraspi-gpio\n package, you will need to do an update first:\n\n\nsudo apt-get update\n\n\n\n\n\nTo get help on \nraspi-gpio\n, run it with the \nhelp\n argument:\n\n\nsudo raspi-gpio help\n\n\n\n\n\nFor example, to see the current function and level of all GPIO pins use:\n\n\nsudo raspi-gpio get\n\n\n\n\n\nNote that \nraspi-gpio\n can be used with the \nfuncs\n argument to get a list of all supported GPIO functions per pin. It will print out a table in CSV format. The idea is to pipe the table to a \n.csv\n file and then load this file using e.g. Excel:\n\n\nsudo raspi-gpio funcs > gpio-funcs.csv\n\n\n\n\n\nBCM283x Boot Process\n\n\nBCM283x devices consist of a VideoCore GPU and ARM CPU cores. The GPU is in fact a system consisting of a DSP processor and hardware accelerators for imaging, video encode and decode, 3D graphics, and image compositing.\n\n\nIn BCM283x devices, it is the DSP core in the GPU that boots first. It is responsible for general setup and housekeeping before booting up the main ARM processor(s).\n\n\nThe BCM283x devices as used on Raspberry Pi and Compute Module boards have a three-stage boot process:\n\n\n\n\n\n\nThe GPU DSP comes out of reset and executes code from a small internal ROM (the boot ROM). The sole purpose of this code is to load a second stage boot loader via one of the external interfaces. On a Raspberry Pi or Compute Module, this code first looks for a second stage boot loader on the SD card (eMMC); it expects this to be called \nbootcode.bin\n and to be on the first partition (which must be FAT32). If no SD card is found or \nbootcode.bin\n is not found, the Boot ROM sits and waits in 'USB boot' mode, waiting for a host to give it a second stage boot loader via the USB interface.\n\n\n\n\n\n\nThe second stage boot loader (\nbootcode.bin\n on the sdcard or \nusbbootcode.bin\n for usb boot) is responsible for setting up the LPDDR2 SDRAM interface and various other critical system functions and then loading and executing the main GPU firmware (called \nstart.elf\n, again on the primary SD card partition).\n\n\n\n\n\n\nstart.elf\n takes over and is responsible for further system setup and booting up the ARM processor subsystem, and contains the firmware that runs on the various parts of the GPU. It first reads \ndt-blob.bin\n to determine initial GPIO pin states and GPU-specific interfaces and clocks, then parses \nconfig.txt\n. It then loads an ARM device tree file (e.g. \nbcm2708-rpi-cm.dtb\n for a Compute Module) and any device tree overlays specified in \nconfig.txt\n before starting the ARM subsystem and passing the device tree data to the booting Linux kernel.\n\n\n\n\n\n\nDevice Tree\n\n\nDevice Tree\n is a special way of encoding all the information about the hardware attached to a system (and consequently required drivers).\n\n\nOn a Pi or Compute Module there are several files in the first FAT partition of the SD/eMMC that are binary 'Device Tree' files. These binary files (usually with extension \n.dtb\n) are compiled from human readable text descriptions (usually files with extension \n.dts\n) by the Device Tree compiler.\n\n\nOn a standard Raspbian image in the first (FAT) partition you will find two different types of device tree files, one is used by the GPU only and the rest are standard ARM device tree files for each of the BCM283x based Pi products:\n\n\n\n\ndt-blob.bin\n (used by the GPU)\n\n\nbcm2708-rpi-b.dtb\n (Used for Pi model A and B)\n\n\nbcm2708-rpi-b-plus.dtb\n (Used for Pi model B+ and A+)\n\n\nbcm2709-rpi-2-b.dtb\n (Used for Pi 2 model B)\n\n\nbcm2710-rpi-3-b.dtb\n (Used for Pi 3 model B)\n\n\nbcm2708-rpi-cm.dtb\n (Used for Pi Compute Module)\n\n\nbcm2710-rpi-cm3.dtb\n (Used for Pi Compute Module 3)\n\n\n\n\nNOTE \ndt-blob.bin\n by default does not exist as there is a 'default' version compiled into \nstart.elf\n, but for Compute Module projects it will often be necessary to provide a \ndt-blob.bin\n (which overrides the default built-in file).\n\n\nNote that \ndt-blob.bin\n is in compiled device tree format, but is only read by the GPU firmware to set up functions exclusive to the GPU - see below.\n\n\nA guide to creating dt-blob.bin is \nhere\n.\nA comprehensive guide to the Linux Device Tree for Raspberry Pi is \nhere\n.\n\n\nDuring boot, the user can specify a specific ARM device tree to use via the \ndevice_tree\n parameter in \nconfig.txt\n, for example adding the line \ndevice_tree=mydt.dtb\n to \nconfig.txt\n where \nmydt.dtb\n is the dtb file to load instead of one of the standard ARM dtb files. While a user can create a full device tree for their Compute Module product, the recommended way to add hardware is to use overlays (see next section).\n\n\nIn addition to loading an ARM dtb, \nstart.elf\n supports loading additional Device Tree 'overlays' via the \ndtoverlay\n parameter in \nconfig.txt\n, for example adding as many \ndtoverlay=myoverlay\n lines as required as overlays to \nconfig.txt\n, noting that overlays live in \n/overlays\n and are suffixed \n-overlay.dtb\n e.g. \n/overlays/myoverlay-overlay.dtb\n. Overlays are merged with the base dtb file before the data is passed to the Linux kernel when it starts.\n\n\nOverlays are used to add data to the base dtb that (nominally) describes non board-specific hardware. This includes GPIO pins used and their function, as well as the device(s) attached, so that the correct drivers can be loaded. The convention is that on a Raspberry Pi, all hardware attached to the Bank0 GPIOs (the GPIO header) should be described using an overlay. On a Compute Module all hardware attached to the Bank0 and Bank1 GPIOs should be described in an overlay file. You don't have to follow these conventions: you can roll all the information into one single dtb file, as previously described, replacing \nbcm2708-rpi-cm.dtb\n. However, following the conventions means that you can use a 'standard' Raspbian release, with its standard base dtb and all the product-specific information contained in a separate overlay. Occasionally the base dtb might change - usually in a way that will not break overlays - which is why using an overlay is suggested.\n\n\ndt-blob.bin\n\n\nWhen \nstart.elf\n runs, it first reads something called \ndt-blob.bin\n. This is a special form of Device Tree blob which tells the GPU how to (initially) set up the GPIO pin states, and also any information about GPIOs/peripherals that are controlled (owned) by the GPU, rather than being used via Linux on the ARM. For example, the Raspberry Pi Camera peripheral is managed by the GPU, and the GPU needs exclusive access to an I2C interface to talk to it, as well as a couple of control pins. I2C0 on most Pi Boards and Compute Modules is nominally reserved for exclusive GPU use. The information on which GPIO pins the GPU should use for I2C0, and to control the camera functions, comes from \ndt-blob.bin\n. \n\n\nNOTE: the \nstart.elf\n firmware has a 'built-in' default \ndt-blob.bin\n which is used if no \ndt-blob.bin\n is found on the root of the first FAT partition. Most Compute Module projects will want to provide their own custom \ndt-blob.bin\n. Note that \ndt-blob.bin\n specifies which pin is for HDMI hot plug detect, although this should never change on Compute Module. It can also be used to set up a GPIO as a GPCLK output, and specify an ACT LED that the GPU can use while booting. Other functions may be added in future. For information on \ndt-blob.bin\n see \nhere\n.\n\n\nminimal-cm-dt-blob.dts\n is an example \n.dts\n device tree file that sets up the HDMI hot plug detect and ACT LED and sets all other GPIOs to be inputs with default pulls.\n\n\nTo compile the \nminimal-cm-dt-blob.dts\n to \ndt-blob.bin\n use the Device Tree Compiler \ndtc\n:\n\n\ndtc -I dts -O dtb -o dt-blob.bin minimal-cm-dt-blob.dts\n\n\n\n\n\nARM Linux Device Tree\n\n\nAfter \nstart.elf\n has read \ndt-blob.bin\n and set up the initial pin states and clocks, it reads \nconfig.txt\n which contains many other options for system setup (see \nhere\n for a comprehensive guide).\n\n\nAfter reading \nconfig.txt\n another device tree file specific to the board the hardware is running on is read: this is \nbcm2708-rpi-cm.dtb\n for a Compute Module, or \nbcm2710-rpi-cm.dtb\n for CM3. This file is a standard ARM Linux device tree file, which details how hardware is attached to the processor: what peripheral devices exist in the SoC and where, which GPIOs are used, what functions those GPIOs have, and what physical devices are connected. This file will set up the GPIOs appropriately, overwriting the pin state set up in \ndt-blob.bin\n if it is different. It will also try to load driver(s) for the specific device(s).\n\n\nAlthough the \nbcm2708-rpi-cm.dtb\n file can be used to load all attached devices, the recommendation for Compute Module users is to leave this file alone. Instead, use the one supplied in the standard Raspbian software image, and add devices using a custom 'overlay' file as previously described. The \nbcm2708-rpi-cm.dtb\n file contains (disabled) entries for the various peripherals (I2C, SPI, I2S etc.) and no GPIO pin definitions, apart from the eMMC/SD Card peripheral which has GPIO defs and is enabled, because it is always on the same pins. The idea is that the separate overlay file will enable the required interfaces, describe the pins used, and also describe the required drivers. The \nstart.elf\n firmware will read and merge the \nbcm2708-rpi-cm.dtb\n with the overlay data before giving the merged device tree to the Linux kernel as it boots up.\n\n\nDevice Tree Source and Compilation\n\n\nThe Raspbian image provides compiled dtb files, but where are the source dts files? They live in the Raspberry Pi Linux kernel branch, on \nGitHub\n. Look in the \narch/arm/boot/dts\n folder.\n\n\nSome default overlay dts files live in \narch/arm/boot/dts/overlays\n. Corresponding overlays for standard hardware that can be attached to a \nRaspberry Pi\n in the Raspbian image are on the FAT partition in the \n/overlays\n directory. Note that these assume certain pins on BANK0, as they are for use on a Raspberry Pi. In general, use the source of these standard overlays as a guide to creating your own, unless you are using the same GPIO pins as you would be using if the hardware was plugged into the GPIO header of a Raspberry Pi.\n\n\nCompiling these dts files to dtb files requires an up-to-date version of the Device Tree compiler \ndtc\n. More information can be found \nhere\n, but the easy way to install an appropriate version on a Pi is to run:\n\n\nsudo apt-get install device-tree-compiler\n\n\n\n\n\nIf you are building your own kernel then the build host also gets a version in \nscripts/dtc\n. You can arrange for your overlays to be built automatically by adding them to \nMakefile\n in \narch/arm/boot/dts/overlays\n, and using the 'dtbs' make target.\n\n\nDevice Tree Debugging\n\n\nWhen the Linux kernel is booted on the ARM core(s), the GPU provides it with a fully assembled device tree, assembled from the base dts and any overlays. This full tree is available via the Linux proc interface in \n/proc/device-tree\n, where nodes become directories and properties become files.\n\n\nYou can use \ndtc\n to write this out as a human readable dts file for debugging. You can see the fully assembled device tree, which is often very useful:\n\n\ndtc -I fs -O dts -o proc-dt.dts /proc/device-tree\n\n\n\n\n\nAs previously explained in the GPIO section, it is also very useful to use \nraspi-gpio\n to look at the setup of the GPIO pins to check that they are as you expect:\n\n\nraspi-gpio get\n\n\n\n\n\nIf something seems to be going awry, useful information can also be found by dumping the GPU log messages:\n\n\nsudo vcdbg log msg\n\n\n\n\n\nYou can include more diagnostics in the output by adding \ndtdebug=1\n to \nconfig.txt\n.\n\n\nGetting Help\n\n\nPlease use the \nDevice Tree subforum\n on the Raspberry Pi forums to ask Device Tree related questions.\n\n\nExamples\n\n\nFor these simple examples I used a CMIO board with peripherals attached via jumper wires.\n\n\nFor each of the examples we assume a CM+CMIO or CM3+CMIO3 board with a clean install of the latest Raspbian Lite version on the CM. See instructions \nhere\n.\n\n\nThe examples here require internet connectivity, so a USB hub plus keyboard plus WiFi or Ethernet dongle plugged into the CMIO USB port is recommended.\n\n\nIf you suspect any issues or bugs with Device Tree it is always best to try a \nsudo rpi-update\n to make sure you are using the latest firmware. \n\n\nWARNING: if you have edited any of the default .dtb files in \n/boot\n or \n/boot/overlays\n these may be overwritten by rpi-update.\n\n\nPlease post any issues, bugs or questions on the Raspberry Pi \nDevice Tree subforum\n.\n\n\nExample 1 - attaching an I2C RTC to BANK1 pins\n\n\nIn this simple example we wire an NXP PCF8523 real time clock (RTC) to the CMIO board BANK1 GPIO pins: 3V3, GND, I2C1_SDA on GPIO44 and I2C1_SCL on GPIO45.\n\n\nDownload \nminimal-cm-dt-blob.dts\n and copy it to the SD card FAT partition, located in \n/boot\n when the CM has booted.\n\n\nEdit \nminimal-cm-dt-blob.dts\n and change the pin states of GPIO44 and 45 to be I2C1 with pull-ups:\n\n\nsudo nano /boot/minimal-cm-dt-blob.dts\n\n\n\n\n\nChange lines:\n\n\npin@p44 { function = \"input\"; termination = \"pull_down\"; }; // DEFAULT STATE WAS INPUT NO PULL\npin@p45 { function = \"input\"; termination = \"pull_down\"; }; // DEFAULT STATE WAS INPUT NO PULL\n\n\n\n\n\nto:\n\n\npin@p44 { function = \"i2c1\"; termination = \"pull_up\"; }; // SDA1\npin@p45 { function = \"i2c1\"; termination = \"pull_up\"; }; // SCL1\n\n\n\n\n\nNOTE: we could use this \ndt-blob.dts\n with no changes The Linux Device Tree will (re)configure these pins during Linux kernel boot when the specific drivers are loaded, so it is up to you whether you modify \ndt-blob.dts\n. I like to configure \ndt-blob.dts\n to what I expect the final GPIOs to be, as they are then set to their final state as soon as possible during the GPU boot stage, but this is not strictly necessary. You may find that in some cases you do need pins to be configured at GPU boot time, so they are in a specific state when Linux drivers are loaded. For example, a reset line may need to be held in the correct orientation.\n\n\nCompile \ndt-blob.bin\n:\n\n\nsudo dtc -I dts -O dtb -o /boot/dt-blob.bin /boot/minimal-cm-dt-blob.dts\n\n\n\n\n\nGrab \nexample1-overlay.dts\n and put it in \n/boot\n then compile it:\n\n\nsudo dtc -@ -I dts -O dtb -o /boot/overlays/example1.dtbo /boot/example1-overlay.dts\n\n\n\n\n\nNote the '-@' in the \ndtc\n command line. This is necessary if you are compiling dts files with external references, as overlays tend to be.\n\n\nEdit \n/boot/config.txt\n and add the line:\n\n\ndtoverlay=example1\n\n\n\n\n\nNow save and reboot.\n\n\nOnce rebooted, you should see an rtc0 entry in /dev. Running:\n\n\nsudo hwclock\n\n\n\n\n\nwill return with the hardware clock time, and not an error.\n\n\nExample 2 - Attaching an ENC28J60 SPI Ethernet Controller on BANK0\n\n\nIn this example we use one of the already available overlays in /boot/overlays to add an ENC28J60 SPI Ethernet controller to BANK0. The Ethernet controller is connected to SPI pins CE0, MISO, MOSI and SCLK (GPIO8-11 respectively), as well as GPIO25 for a falling edge interrupt, and of course GND and 3V3.\n\n\nIn this example we won't change \ndt-blob.bin\n, although of course you can if you wish. We should see that Linux Device Tree correctly sets up the pins.\n\n\nEdit \n/boot/config.txt\n and add the line:\n\n\ndtoverlay=enc28j60\n\n\n\n\n\nNow save and reboot.\n\n\nOnce rebooted you should see, as before, an rtc0 entry in /dev. Running:\n\n\nsudo hwclock\n\n\n\n\n\nwill return with the hardware clock time, and not an error.\n\n\nYou should also have Ethernet connectivity:\n\n\nping 8.8.8.8\n\n\n\n\n\nshould work.\n\n\nfinally running:\n\n\nsudo raspi-gpio get\n\n\n\n\n\nshould show that GPIO8-11 have changed to ALT0 (SPI) functions.\n\n\nAttaching a camera or cameras\n\n\nTo attach a camera or cameras see the documentation \nhere",
            "title": "Compute Module Attaching and Enabling Peripherals Guide"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#compute-module-attaching-and-enabling-peripherals-guide",
            "text": "Note that unless explicitly stated otherwise, these instructions will work identically on Compute Module and Compute Module 3 Module+IO board(s).",
            "title": "Compute Module Attaching and Enabling Peripherals Guide"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#introduction",
            "text": "This guide is designed to help developers using the Compute Module (and Compute Module 3) get to grips with how to wire up peripherals to the Compute Module pins, and how to make changes to the software to enable these peripherals to work correctly.  The Compute Module (CM) and Compute Module 3 (CM3) contain the Raspberry Pi BCM2835 (or BCM2837 for CM3) system on a chip (SoC) or 'processor', memory, and eMMC. The eMMC is similar to an SD card but is soldered onto the board. Unlike SD cards, the eMMC is specifically designed to be used as a disk and has extra features that make it more reliable in this use case. Most of the pins of the SoC (GPIO, two CSI camera interfaces, two DSI display interfaces, HDMI etc) are freely available and can be wired up as the user sees fit (or, if unused, can usually be left unconnected). The Compute Module is a DDR2 SODIMM form-factor-compatible module, so any DDR2 SODIMM socket should be able to be used (note the pinout is NOT the same as an actual SODIMM memory module).  To use the Compute Module, a user needs to design a (relatively simple) 'motherboard' which can provide power to the Compute Module (3.3V and 1.8V at minimum), and which connects the pins to the required peripherals for the user's application.  Raspberry Pi provides a minimal motherboard for the Compute Module (called the Compute Module IO Board, or CMIO Board) which powers the module, brings out the GPIO to pin headers, and brings the camera and display interfaces out to FFC connectors. It also provides HDMI, USB, and an 'ACT' LED, as well as the ability to program the eMMC of a module via USB from a PC or Raspberry Pi.  This guide first explains the boot process and how Device Tree is used to describe attached hardware; these are essential things to understand when designing with the Compute Module. It then provides a worked example of attaching an I2C and an SPI peripheral to a CMIO (or CMIO V3 for CM3) Board and creating the Device Tree files necessary to make both peripherals work under Linux, starting from a vanilla Raspbian OS image.",
            "title": "Introduction"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#bcm283x-gpios",
            "text": "BCM283x has three banks of General-Purpose Input/Output (GPIO) pins: 28 pins on Bank 0, 18 pins on Bank 1, and 8 pins on Bank 2, making 54 pins in total. These pins can be used as true GPIO  pins, i.e. software can set them as inputs or outputs, read and/or set state, and use them as interrupts. They also can be set to 'alternate functions' such as I2C, SPI, I2S, UART, SD card, and others.  On a Compute Module, both Bank 0 and Bank 1 are free to use. Bank 2 is used for eMMC and HDMI hot plug detect and ACT LED / USB boot control.  It is useful on a running system to look at the state of each of the GPIO pins (what function they are set to, and the voltage level at the pin) so that you can see if the system is set up as expected. This is particularly helpful if you want to see if a Device Tree is working as expected, or to get a look at the pin states during hardware debug.  Raspberry Pi provides the  raspi-gpio  package which is a tool for hacking and debugging GPIO (NOTE: you need to run it as root).\nTo install  raspi-gpio :  sudo apt-get install raspi-gpio  If  apt-get  can't find the  raspi-gpio  package, you will need to do an update first:  sudo apt-get update  To get help on  raspi-gpio , run it with the  help  argument:  sudo raspi-gpio help  For example, to see the current function and level of all GPIO pins use:  sudo raspi-gpio get  Note that  raspi-gpio  can be used with the  funcs  argument to get a list of all supported GPIO functions per pin. It will print out a table in CSV format. The idea is to pipe the table to a  .csv  file and then load this file using e.g. Excel:  sudo raspi-gpio funcs > gpio-funcs.csv",
            "title": "BCM283x GPIOs"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#bcm283x-boot-process",
            "text": "BCM283x devices consist of a VideoCore GPU and ARM CPU cores. The GPU is in fact a system consisting of a DSP processor and hardware accelerators for imaging, video encode and decode, 3D graphics, and image compositing.  In BCM283x devices, it is the DSP core in the GPU that boots first. It is responsible for general setup and housekeeping before booting up the main ARM processor(s).  The BCM283x devices as used on Raspberry Pi and Compute Module boards have a three-stage boot process:    The GPU DSP comes out of reset and executes code from a small internal ROM (the boot ROM). The sole purpose of this code is to load a second stage boot loader via one of the external interfaces. On a Raspberry Pi or Compute Module, this code first looks for a second stage boot loader on the SD card (eMMC); it expects this to be called  bootcode.bin  and to be on the first partition (which must be FAT32). If no SD card is found or  bootcode.bin  is not found, the Boot ROM sits and waits in 'USB boot' mode, waiting for a host to give it a second stage boot loader via the USB interface.    The second stage boot loader ( bootcode.bin  on the sdcard or  usbbootcode.bin  for usb boot) is responsible for setting up the LPDDR2 SDRAM interface and various other critical system functions and then loading and executing the main GPU firmware (called  start.elf , again on the primary SD card partition).    start.elf  takes over and is responsible for further system setup and booting up the ARM processor subsystem, and contains the firmware that runs on the various parts of the GPU. It first reads  dt-blob.bin  to determine initial GPIO pin states and GPU-specific interfaces and clocks, then parses  config.txt . It then loads an ARM device tree file (e.g.  bcm2708-rpi-cm.dtb  for a Compute Module) and any device tree overlays specified in  config.txt  before starting the ARM subsystem and passing the device tree data to the booting Linux kernel.",
            "title": "BCM283x Boot Process"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#device-tree",
            "text": "Device Tree  is a special way of encoding all the information about the hardware attached to a system (and consequently required drivers).  On a Pi or Compute Module there are several files in the first FAT partition of the SD/eMMC that are binary 'Device Tree' files. These binary files (usually with extension  .dtb ) are compiled from human readable text descriptions (usually files with extension  .dts ) by the Device Tree compiler.  On a standard Raspbian image in the first (FAT) partition you will find two different types of device tree files, one is used by the GPU only and the rest are standard ARM device tree files for each of the BCM283x based Pi products:   dt-blob.bin  (used by the GPU)  bcm2708-rpi-b.dtb  (Used for Pi model A and B)  bcm2708-rpi-b-plus.dtb  (Used for Pi model B+ and A+)  bcm2709-rpi-2-b.dtb  (Used for Pi 2 model B)  bcm2710-rpi-3-b.dtb  (Used for Pi 3 model B)  bcm2708-rpi-cm.dtb  (Used for Pi Compute Module)  bcm2710-rpi-cm3.dtb  (Used for Pi Compute Module 3)   NOTE  dt-blob.bin  by default does not exist as there is a 'default' version compiled into  start.elf , but for Compute Module projects it will often be necessary to provide a  dt-blob.bin  (which overrides the default built-in file).  Note that  dt-blob.bin  is in compiled device tree format, but is only read by the GPU firmware to set up functions exclusive to the GPU - see below.  A guide to creating dt-blob.bin is  here .\nA comprehensive guide to the Linux Device Tree for Raspberry Pi is  here .  During boot, the user can specify a specific ARM device tree to use via the  device_tree  parameter in  config.txt , for example adding the line  device_tree=mydt.dtb  to  config.txt  where  mydt.dtb  is the dtb file to load instead of one of the standard ARM dtb files. While a user can create a full device tree for their Compute Module product, the recommended way to add hardware is to use overlays (see next section).  In addition to loading an ARM dtb,  start.elf  supports loading additional Device Tree 'overlays' via the  dtoverlay  parameter in  config.txt , for example adding as many  dtoverlay=myoverlay  lines as required as overlays to  config.txt , noting that overlays live in  /overlays  and are suffixed  -overlay.dtb  e.g.  /overlays/myoverlay-overlay.dtb . Overlays are merged with the base dtb file before the data is passed to the Linux kernel when it starts.  Overlays are used to add data to the base dtb that (nominally) describes non board-specific hardware. This includes GPIO pins used and their function, as well as the device(s) attached, so that the correct drivers can be loaded. The convention is that on a Raspberry Pi, all hardware attached to the Bank0 GPIOs (the GPIO header) should be described using an overlay. On a Compute Module all hardware attached to the Bank0 and Bank1 GPIOs should be described in an overlay file. You don't have to follow these conventions: you can roll all the information into one single dtb file, as previously described, replacing  bcm2708-rpi-cm.dtb . However, following the conventions means that you can use a 'standard' Raspbian release, with its standard base dtb and all the product-specific information contained in a separate overlay. Occasionally the base dtb might change - usually in a way that will not break overlays - which is why using an overlay is suggested.",
            "title": "Device Tree"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#dt-blobbin",
            "text": "When  start.elf  runs, it first reads something called  dt-blob.bin . This is a special form of Device Tree blob which tells the GPU how to (initially) set up the GPIO pin states, and also any information about GPIOs/peripherals that are controlled (owned) by the GPU, rather than being used via Linux on the ARM. For example, the Raspberry Pi Camera peripheral is managed by the GPU, and the GPU needs exclusive access to an I2C interface to talk to it, as well as a couple of control pins. I2C0 on most Pi Boards and Compute Modules is nominally reserved for exclusive GPU use. The information on which GPIO pins the GPU should use for I2C0, and to control the camera functions, comes from  dt-blob.bin .   NOTE: the  start.elf  firmware has a 'built-in' default  dt-blob.bin  which is used if no  dt-blob.bin  is found on the root of the first FAT partition. Most Compute Module projects will want to provide their own custom  dt-blob.bin . Note that  dt-blob.bin  specifies which pin is for HDMI hot plug detect, although this should never change on Compute Module. It can also be used to set up a GPIO as a GPCLK output, and specify an ACT LED that the GPU can use while booting. Other functions may be added in future. For information on  dt-blob.bin  see  here .  minimal-cm-dt-blob.dts  is an example  .dts  device tree file that sets up the HDMI hot plug detect and ACT LED and sets all other GPIOs to be inputs with default pulls.  To compile the  minimal-cm-dt-blob.dts  to  dt-blob.bin  use the Device Tree Compiler  dtc :  dtc -I dts -O dtb -o dt-blob.bin minimal-cm-dt-blob.dts",
            "title": "dt-blob.bin"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#arm-linux-device-tree",
            "text": "After  start.elf  has read  dt-blob.bin  and set up the initial pin states and clocks, it reads  config.txt  which contains many other options for system setup (see  here  for a comprehensive guide).  After reading  config.txt  another device tree file specific to the board the hardware is running on is read: this is  bcm2708-rpi-cm.dtb  for a Compute Module, or  bcm2710-rpi-cm.dtb  for CM3. This file is a standard ARM Linux device tree file, which details how hardware is attached to the processor: what peripheral devices exist in the SoC and where, which GPIOs are used, what functions those GPIOs have, and what physical devices are connected. This file will set up the GPIOs appropriately, overwriting the pin state set up in  dt-blob.bin  if it is different. It will also try to load driver(s) for the specific device(s).  Although the  bcm2708-rpi-cm.dtb  file can be used to load all attached devices, the recommendation for Compute Module users is to leave this file alone. Instead, use the one supplied in the standard Raspbian software image, and add devices using a custom 'overlay' file as previously described. The  bcm2708-rpi-cm.dtb  file contains (disabled) entries for the various peripherals (I2C, SPI, I2S etc.) and no GPIO pin definitions, apart from the eMMC/SD Card peripheral which has GPIO defs and is enabled, because it is always on the same pins. The idea is that the separate overlay file will enable the required interfaces, describe the pins used, and also describe the required drivers. The  start.elf  firmware will read and merge the  bcm2708-rpi-cm.dtb  with the overlay data before giving the merged device tree to the Linux kernel as it boots up.",
            "title": "ARM Linux Device Tree"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#device-tree-source-and-compilation",
            "text": "The Raspbian image provides compiled dtb files, but where are the source dts files? They live in the Raspberry Pi Linux kernel branch, on  GitHub . Look in the  arch/arm/boot/dts  folder.  Some default overlay dts files live in  arch/arm/boot/dts/overlays . Corresponding overlays for standard hardware that can be attached to a  Raspberry Pi  in the Raspbian image are on the FAT partition in the  /overlays  directory. Note that these assume certain pins on BANK0, as they are for use on a Raspberry Pi. In general, use the source of these standard overlays as a guide to creating your own, unless you are using the same GPIO pins as you would be using if the hardware was plugged into the GPIO header of a Raspberry Pi.  Compiling these dts files to dtb files requires an up-to-date version of the Device Tree compiler  dtc . More information can be found  here , but the easy way to install an appropriate version on a Pi is to run:  sudo apt-get install device-tree-compiler  If you are building your own kernel then the build host also gets a version in  scripts/dtc . You can arrange for your overlays to be built automatically by adding them to  Makefile  in  arch/arm/boot/dts/overlays , and using the 'dtbs' make target.",
            "title": "Device Tree Source and Compilation"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#device-tree-debugging",
            "text": "When the Linux kernel is booted on the ARM core(s), the GPU provides it with a fully assembled device tree, assembled from the base dts and any overlays. This full tree is available via the Linux proc interface in  /proc/device-tree , where nodes become directories and properties become files.  You can use  dtc  to write this out as a human readable dts file for debugging. You can see the fully assembled device tree, which is often very useful:  dtc -I fs -O dts -o proc-dt.dts /proc/device-tree  As previously explained in the GPIO section, it is also very useful to use  raspi-gpio  to look at the setup of the GPIO pins to check that they are as you expect:  raspi-gpio get  If something seems to be going awry, useful information can also be found by dumping the GPU log messages:  sudo vcdbg log msg  You can include more diagnostics in the output by adding  dtdebug=1  to  config.txt .",
            "title": "Device Tree Debugging"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#getting-help",
            "text": "Please use the  Device Tree subforum  on the Raspberry Pi forums to ask Device Tree related questions.",
            "title": "Getting Help"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#examples",
            "text": "For these simple examples I used a CMIO board with peripherals attached via jumper wires.  For each of the examples we assume a CM+CMIO or CM3+CMIO3 board with a clean install of the latest Raspbian Lite version on the CM. See instructions  here .  The examples here require internet connectivity, so a USB hub plus keyboard plus WiFi or Ethernet dongle plugged into the CMIO USB port is recommended.  If you suspect any issues or bugs with Device Tree it is always best to try a  sudo rpi-update  to make sure you are using the latest firmware.   WARNING: if you have edited any of the default .dtb files in  /boot  or  /boot/overlays  these may be overwritten by rpi-update.  Please post any issues, bugs or questions on the Raspberry Pi  Device Tree subforum .",
            "title": "Examples"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#example-1-attaching-an-i2c-rtc-to-bank1-pins",
            "text": "In this simple example we wire an NXP PCF8523 real time clock (RTC) to the CMIO board BANK1 GPIO pins: 3V3, GND, I2C1_SDA on GPIO44 and I2C1_SCL on GPIO45.  Download  minimal-cm-dt-blob.dts  and copy it to the SD card FAT partition, located in  /boot  when the CM has booted.  Edit  minimal-cm-dt-blob.dts  and change the pin states of GPIO44 and 45 to be I2C1 with pull-ups:  sudo nano /boot/minimal-cm-dt-blob.dts  Change lines:  pin@p44 { function = \"input\"; termination = \"pull_down\"; }; // DEFAULT STATE WAS INPUT NO PULL\npin@p45 { function = \"input\"; termination = \"pull_down\"; }; // DEFAULT STATE WAS INPUT NO PULL  to:  pin@p44 { function = \"i2c1\"; termination = \"pull_up\"; }; // SDA1\npin@p45 { function = \"i2c1\"; termination = \"pull_up\"; }; // SCL1  NOTE: we could use this  dt-blob.dts  with no changes The Linux Device Tree will (re)configure these pins during Linux kernel boot when the specific drivers are loaded, so it is up to you whether you modify  dt-blob.dts . I like to configure  dt-blob.dts  to what I expect the final GPIOs to be, as they are then set to their final state as soon as possible during the GPU boot stage, but this is not strictly necessary. You may find that in some cases you do need pins to be configured at GPU boot time, so they are in a specific state when Linux drivers are loaded. For example, a reset line may need to be held in the correct orientation.  Compile  dt-blob.bin :  sudo dtc -I dts -O dtb -o /boot/dt-blob.bin /boot/minimal-cm-dt-blob.dts  Grab  example1-overlay.dts  and put it in  /boot  then compile it:  sudo dtc -@ -I dts -O dtb -o /boot/overlays/example1.dtbo /boot/example1-overlay.dts  Note the '-@' in the  dtc  command line. This is necessary if you are compiling dts files with external references, as overlays tend to be.  Edit  /boot/config.txt  and add the line:  dtoverlay=example1  Now save and reboot.  Once rebooted, you should see an rtc0 entry in /dev. Running:  sudo hwclock  will return with the hardware clock time, and not an error.",
            "title": "Example 1 - attaching an I2C RTC to BANK1 pins"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#example-2-attaching-an-enc28j60-spi-ethernet-controller-on-bank0",
            "text": "In this example we use one of the already available overlays in /boot/overlays to add an ENC28J60 SPI Ethernet controller to BANK0. The Ethernet controller is connected to SPI pins CE0, MISO, MOSI and SCLK (GPIO8-11 respectively), as well as GPIO25 for a falling edge interrupt, and of course GND and 3V3.  In this example we won't change  dt-blob.bin , although of course you can if you wish. We should see that Linux Device Tree correctly sets up the pins.  Edit  /boot/config.txt  and add the line:  dtoverlay=enc28j60  Now save and reboot.  Once rebooted you should see, as before, an rtc0 entry in /dev. Running:  sudo hwclock  will return with the hardware clock time, and not an error.  You should also have Ethernet connectivity:  ping 8.8.8.8  should work.  finally running:  sudo raspi-gpio get  should show that GPIO8-11 have changed to ALT0 (SPI) functions.",
            "title": "Example 2 - Attaching an ENC28J60 SPI Ethernet Controller on BANK0"
        },
        {
            "location": "/hardware/computemodule/cm-peri-sw-guide/index.html#attaching-a-camera-or-cameras",
            "text": "To attach a camera or cameras see the documentation  here",
            "title": "Attaching a camera or cameras"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html",
            "text": "Attaching a Raspberry Pi Camera Module to the Compute Module IO Board\n\n\nThis document is a work in progress and is intended for advanced users.\n\n\nFor the camera to work with the Compute Module 3 (CM3), the firmware needs to be September 21st 2016 or newer (use \nvcgencmd version\n to check).\n\n\n Note that unless explicitly stated otherwise, these instructions will work identically on Compute Module and Compute Module 3 Module+IO board(s). \n\n\nQuickstart\n\n\n\n\nOn the compute module, run \nsudo raspi-config\n and enable the camera.\n\n\nNext, run \nsudo wget http://goo.gl/U4t12b -O /boot/dt-blob.bin\n\n\n\n\nConnect adapter board and camera to CAM1 port.\n\n\n\n\n\n\n\n\nConnect GPIO pins together as shown below.\n\n\n\n\n\n\n\n\n(Optional) To add an additional camera, repeat step 3 with CAM0 and connect the GPIO pins for the second camera.\n\n\n\n\n\n\n\n\nFinally, reboot for the dt-blob.bin file to be read.\n\n\n\n\n\n\nSoftware support\n\n\nRecent raspicam binaries (\nraspivid\n and \nraspistill\n) have the -cs (--camselect) option to specify which camera should be used.\n\n\nFrom other applications, MMAL can be told which camera to use by setting MMAL_PARAMETER_CAMERA_NUM accordingly.\n\n\nMMAL_PARAMETER_INT32_T camera_num = {{MMAL_PARAMETER_CAMERA_NUM, sizeof(camera_num)}, CAMERA_NUMBER};\nstatus = mmal_port_parameter_set(camera->control, &camera_num.hdr);\n\n\n\n\n\nAdvanced\n\n\nThe 15-way 1mm FFC camera connector on the Raspberry Pi model A and B is attached to the CAM1 interface (though it only uses two of the four available lanes).\n\n\nThe Compute Module IO board has a 22-way 0.5mm FFC for each camera port, with CAM0 being a two-lane interface and CAM1 being the full four-lane interface.\n\n\nTo attach a standard Raspberry Pi Camera to the Compute Module IO board, a small adaptor board is available. It adapts the 22W FFC to the Pi 15W FFC.\n\n\nTo make the Raspberry Pi Camera Module work with a standard Raspbian OS, the GPIOs and I2C interface must be wired to the CAM1 connector. This is done by bridging the correct GPIOs from the J6 GPIO connector to the CD1_SDA/SCL and CAM1_IO0/1 pins on the J5 connector using jumper wires. Additionally, a \ndt-blob.bin\n file needs to be provided to override default pin states (the dt-blob.bin file is a file that tells the GPU what pins to use when controlling the camera. For more information on this, see the relevant section in the guide to attaching peripherals to a Compute Module \nhere\n).\n\n\nThe pin numbers below are provided only as an example. LED and SHUTDOWN pins can be shared by both cameras, if required.\n The SDA and SCL pins must be either GPIO0 and GPIO1 or GPIO28 and 29 and must be individual to each camera.\n\n\nSteps to attach a Raspberry Pi Camera (to CAM1)\n\n\n\n\nAttach the 0.5mm 22W FFC flexi (included with the adaptor board) to the CAM1 connector (flex contacts face down).\n\n\nAttach the camera adaptor board to the other end of the 0.5mm flex (flex contacts face down).\n\n\nAttach a Raspberry Pi Camera to the other, larger 15W 1mm FFC on the camera adaptor board (\ncontacts on the Raspberry Pi Camera flex must face up\n).\n\n\nAttach CD1_SDA (J6 pin 37) to GPIO0 (J5 pin 1).\n\n\nAttach CD1_SCL (J6 pin 39) to GPIO1 (J5 pin 3).\n\n\nAttach CAM1_IO1 (J6 pin 41) to GPIO2 (J5 pin 5).\n\n\nAttach CAM1_IO0 (J6 pin 43) to GPIO3 (J5 pin 7).\n\n\n\n\nThe numbers in brackets are conventional, physical pin numbers, numbered from left to right, top to bottom. The numbers on the silkscreen correspond to the Broadcom SoC GPIO numbers.\n\n\nConfiguring default pin states\n\n\nThe GPIOs used by the camera default to input mode on the Compute Module. In order to \noverride the default pin states\n and define the pins used by the camera, we need to create a \ndt-blob.bin\n file from a source dts file with the relevant information for the GPU, and place this on the root of the first FAT partition.\n\n\nSample device tree source files\n are provided at the bottom of this document.\n\n\nThe \npin_config\n section in the \npins_cm { }\n (compute module) or \npins_cm3 { }\n (compute module3) section of the source dts needs the camera's LED and power enable pins set to outputs:\n\n\npin@p2  { function = \"output\"; termination = \"no_pulling\"; };\npin@p3  { function = \"output\"; termination = \"no_pulling\"; };\n\n\n\n\n\nTo tell the firmware which pins to use and how many cameras to look for, add the following to the \npin_defines\n section:\n\n\npin_define@CAMERA_0_LED { type = \"internal\"; number = <2>; };\npin_define@CAMERA_0_SHUTDOWN { type = \"internal\"; number = <3>; };\npin_define@CAMERA_0_UNICAM_PORT { type = \"internal\"; number = <1>; };\npin_define@CAMERA_0_I2C_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_0_SDA_PIN { type = \"internal\"; number = <0>; };\npin_define@CAMERA_0_SCL_PIN { type = \"internal\"; number = <1>; };\n\n\n\n\n\nHow to attach two cameras\n\n\nAttach the second camera to the (CAM0) connector as before.\n\n\nConnect up the I2C and GPIO lines.\n\n\n\n\nAttach CD0_SDA (J6 pin 45) to GPIO28 (J6 pin 1).\n\n\nAttach CD0_SCL (J6 pin 47) to GPIO29 (J6 pin 3).\n\n\nAttach CAM0_IO1 (J6 pin 49) to GPIO30 (J6 pin 5).\n\n\nAttach CAM0_IO0 (J6 pin 51) to GPIO31 (J6 pin 7).\n\n\n\n\nThe Compute Module's \npin_config\n section needs the second camera's LED and power enable pins configured:\n\n\npin@p30 { function = \"output\"; termination = \"no_pulling\"; };\npin@p31 { function = \"output\"; termination = \"no_pulling\"; };\n\n\n\n\n\nIn the Compute Module's \npin_defines\n section of the dts file, change the \nNUM_CAMERAS\n parameter to 2 and add the following:\n\n\npin_define@CAMERA_1_LED { type = \"internal\"; number = <30>; };\npin_define@CAMERA_1_SHUTDOWN { type = \"internal\"; number = <31>; };\npin_define@CAMERA_1_UNICAM_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_1_I2C_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_1_SDA_PIN { type = \"internal\"; number = <28>; };\npin_define@CAMERA_1_SCL_PIN { type = \"internal\"; number = <29>; };\n\n\n\n\n\n\n\nSample device tree source files\n\n\nEnable CAM1 only\n\n\nEnable both cameras",
            "title": "Attaching a Raspberry Pi Camera Module to the Compute Module IO Board"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#attaching-a-raspberry-pi-camera-module-to-the-compute-module-io-board",
            "text": "This document is a work in progress and is intended for advanced users.  For the camera to work with the Compute Module 3 (CM3), the firmware needs to be September 21st 2016 or newer (use  vcgencmd version  to check).   Note that unless explicitly stated otherwise, these instructions will work identically on Compute Module and Compute Module 3 Module+IO board(s).",
            "title": "Attaching a Raspberry Pi Camera Module to the Compute Module IO Board"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#quickstart",
            "text": "On the compute module, run  sudo raspi-config  and enable the camera.  Next, run  sudo wget http://goo.gl/U4t12b -O /boot/dt-blob.bin   Connect adapter board and camera to CAM1 port.     Connect GPIO pins together as shown below.     (Optional) To add an additional camera, repeat step 3 with CAM0 and connect the GPIO pins for the second camera.     Finally, reboot for the dt-blob.bin file to be read.",
            "title": "Quickstart"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#software-support",
            "text": "Recent raspicam binaries ( raspivid  and  raspistill ) have the -cs (--camselect) option to specify which camera should be used.  From other applications, MMAL can be told which camera to use by setting MMAL_PARAMETER_CAMERA_NUM accordingly.  MMAL_PARAMETER_INT32_T camera_num = {{MMAL_PARAMETER_CAMERA_NUM, sizeof(camera_num)}, CAMERA_NUMBER};\nstatus = mmal_port_parameter_set(camera->control, &camera_num.hdr);",
            "title": "Software support"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#advanced",
            "text": "The 15-way 1mm FFC camera connector on the Raspberry Pi model A and B is attached to the CAM1 interface (though it only uses two of the four available lanes).  The Compute Module IO board has a 22-way 0.5mm FFC for each camera port, with CAM0 being a two-lane interface and CAM1 being the full four-lane interface.  To attach a standard Raspberry Pi Camera to the Compute Module IO board, a small adaptor board is available. It adapts the 22W FFC to the Pi 15W FFC.  To make the Raspberry Pi Camera Module work with a standard Raspbian OS, the GPIOs and I2C interface must be wired to the CAM1 connector. This is done by bridging the correct GPIOs from the J6 GPIO connector to the CD1_SDA/SCL and CAM1_IO0/1 pins on the J5 connector using jumper wires. Additionally, a  dt-blob.bin  file needs to be provided to override default pin states (the dt-blob.bin file is a file that tells the GPU what pins to use when controlling the camera. For more information on this, see the relevant section in the guide to attaching peripherals to a Compute Module  here ).  The pin numbers below are provided only as an example. LED and SHUTDOWN pins can be shared by both cameras, if required.  The SDA and SCL pins must be either GPIO0 and GPIO1 or GPIO28 and 29 and must be individual to each camera.",
            "title": "Advanced"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#steps-to-attach-a-raspberry-pi-camera-to-cam1",
            "text": "Attach the 0.5mm 22W FFC flexi (included with the adaptor board) to the CAM1 connector (flex contacts face down).  Attach the camera adaptor board to the other end of the 0.5mm flex (flex contacts face down).  Attach a Raspberry Pi Camera to the other, larger 15W 1mm FFC on the camera adaptor board ( contacts on the Raspberry Pi Camera flex must face up ).  Attach CD1_SDA (J6 pin 37) to GPIO0 (J5 pin 1).  Attach CD1_SCL (J6 pin 39) to GPIO1 (J5 pin 3).  Attach CAM1_IO1 (J6 pin 41) to GPIO2 (J5 pin 5).  Attach CAM1_IO0 (J6 pin 43) to GPIO3 (J5 pin 7).   The numbers in brackets are conventional, physical pin numbers, numbered from left to right, top to bottom. The numbers on the silkscreen correspond to the Broadcom SoC GPIO numbers.",
            "title": "Steps to attach a Raspberry Pi Camera (to CAM1)"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#configuring-default-pin-states",
            "text": "The GPIOs used by the camera default to input mode on the Compute Module. In order to  override the default pin states  and define the pins used by the camera, we need to create a  dt-blob.bin  file from a source dts file with the relevant information for the GPU, and place this on the root of the first FAT partition.  Sample device tree source files  are provided at the bottom of this document.  The  pin_config  section in the  pins_cm { }  (compute module) or  pins_cm3 { }  (compute module3) section of the source dts needs the camera's LED and power enable pins set to outputs:  pin@p2  { function = \"output\"; termination = \"no_pulling\"; };\npin@p3  { function = \"output\"; termination = \"no_pulling\"; };  To tell the firmware which pins to use and how many cameras to look for, add the following to the  pin_defines  section:  pin_define@CAMERA_0_LED { type = \"internal\"; number = <2>; };\npin_define@CAMERA_0_SHUTDOWN { type = \"internal\"; number = <3>; };\npin_define@CAMERA_0_UNICAM_PORT { type = \"internal\"; number = <1>; };\npin_define@CAMERA_0_I2C_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_0_SDA_PIN { type = \"internal\"; number = <0>; };\npin_define@CAMERA_0_SCL_PIN { type = \"internal\"; number = <1>; };",
            "title": "Configuring default pin states"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#how-to-attach-two-cameras",
            "text": "Attach the second camera to the (CAM0) connector as before.  Connect up the I2C and GPIO lines.   Attach CD0_SDA (J6 pin 45) to GPIO28 (J6 pin 1).  Attach CD0_SCL (J6 pin 47) to GPIO29 (J6 pin 3).  Attach CAM0_IO1 (J6 pin 49) to GPIO30 (J6 pin 5).  Attach CAM0_IO0 (J6 pin 51) to GPIO31 (J6 pin 7).   The Compute Module's  pin_config  section needs the second camera's LED and power enable pins configured:  pin@p30 { function = \"output\"; termination = \"no_pulling\"; };\npin@p31 { function = \"output\"; termination = \"no_pulling\"; };  In the Compute Module's  pin_defines  section of the dts file, change the  NUM_CAMERAS  parameter to 2 and add the following:  pin_define@CAMERA_1_LED { type = \"internal\"; number = <30>; };\npin_define@CAMERA_1_SHUTDOWN { type = \"internal\"; number = <31>; };\npin_define@CAMERA_1_UNICAM_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_1_I2C_PORT { type = \"internal\"; number = <0>; };\npin_define@CAMERA_1_SDA_PIN { type = \"internal\"; number = <28>; };\npin_define@CAMERA_1_SCL_PIN { type = \"internal\"; number = <29>; };",
            "title": "How to attach two cameras"
        },
        {
            "location": "/hardware/computemodule/cmio-camera/index.html#sample-device-tree-source-files",
            "text": "Enable CAM1 only  Enable both cameras",
            "title": "Sample device tree source files"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html",
            "text": "Attaching Raspberry Pi Official 7\" Display to the Compute Module IO Board\n\n\nThis document is a work in progress and is intended for advanced users.\n\n\nFor the display to work with the Compute Module, the firmware needs to be from October 23rd 2015 or later (use \nvcgencmd version\n to check). For the display to work with the Compute Module 3, the firmware needs to be from October 2016 or later.\n\n\nQuickstart - Display Only\n\n\n\n\nConnect the display to the DISP1 port on the Compute Module IO board through the 22W to 15W display adaptor.\n\n\n\n\nConnect these pins together with jumper wires:\n\n\nGPIO0 - CD1_SDA\nGPIO1 - CD1_SCL\n\n\n\n\n\n\nOn the Compute Module, run:\n\n\nsudo wget https://goo.gl/iiVxuA -O /boot/dt-blob.bin\n\n\n\n\n\n\nReboot for the \ndt-blob.bin\n file to be read.\n\n\n\n\n\n\nQuickstart - Display and Camera(s)\n\n\nThis will enable \ndisp1\n and \ncam1\n, with the option of enabling \ncam0\n.\n\n\n\n\nConnect the display to the DISP1 port on the Compute Module IO board through the 22W to 15W display adaptor.\n\n\nConnect the Camera Module to the CAM1 port on the Compute Module IO board through the 22W to 15W camera adaptor.\n\n\n(Optional) Connect the Camera Module to the CAM0 port on the Compute Module IO board through the 22W to 15W camera adaptor.\n\n\n\n\nConnect these pins together with jumper wires:\n\n\nGPIO0 - CD1_SDA\nGPIO1 - CD1_SCL\nGPIO4 - CAM1_IO1\nGPIO5 - CAM1_IO0\n\nPlease note that the wiring is slightly different from that on the Camera page, in that you are using GPIO pins 4 and 5 instead of 2 and 3.\n\n\n\n\n\n\nFor \ncam0\n, add links:\n\n\nGPIO28 - CD0_SDA\nGPIO29 - CD0_SCL\nGPIO30 - CAM0_IO1\nGPIO31 - CAM0_IO0\n\n\n\n(Please note this image needs to be updated to show two Camera Modules, or have the extra jumper leads removed)\n\n\n\n\n\n\nOn the Compute Module, for the display and one Camera Module, run:\n\n\nsudo wget https://goo.gl/gaqNrO -O /boot/dt-blob.bin\n  \n\n\n\n\n\n\nFor the display and two Camera Modules, run:\n\n\n```sudo wget https://goo.gl/htHv7m -O /boot/dt-blob.bin```\n\n\n\n\n\n\n\n\n\nReboot for the \ndt-blob.bin\n file to be read.\n\n\n\n(Please note this image needs to be updated to show two Camera Modules, or have the extra jumper leads removed)\n\n\n\n\n\n\nSoftware support\n\n\nThere is no additional configuration required to enable the touchscreen. The touch interface should out work of the box once the screen is successfully detected.\n\n\nSources\n\n\n\n\ndt-blob-disp1-only.dts\n\n\ndt-blob-disp1-cam1.dts\n\n\ndt-blob-disp1-cam2.dts",
            "title": "Attaching Raspberry Pi Official 7\" Display to the Compute Module IO Board"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html#attaching-raspberry-pi-official-7-display-to-the-compute-module-io-board",
            "text": "This document is a work in progress and is intended for advanced users.  For the display to work with the Compute Module, the firmware needs to be from October 23rd 2015 or later (use  vcgencmd version  to check). For the display to work with the Compute Module 3, the firmware needs to be from October 2016 or later.",
            "title": "Attaching Raspberry Pi Official 7\" Display to the Compute Module IO Board"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html#quickstart-display-only",
            "text": "Connect the display to the DISP1 port on the Compute Module IO board through the 22W to 15W display adaptor.   Connect these pins together with jumper wires:  GPIO0 - CD1_SDA\nGPIO1 - CD1_SCL    On the Compute Module, run:  sudo wget https://goo.gl/iiVxuA -O /boot/dt-blob.bin    Reboot for the  dt-blob.bin  file to be read.",
            "title": "Quickstart - Display Only"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html#quickstart-display-and-cameras",
            "text": "This will enable  disp1  and  cam1 , with the option of enabling  cam0 .   Connect the display to the DISP1 port on the Compute Module IO board through the 22W to 15W display adaptor.  Connect the Camera Module to the CAM1 port on the Compute Module IO board through the 22W to 15W camera adaptor.  (Optional) Connect the Camera Module to the CAM0 port on the Compute Module IO board through the 22W to 15W camera adaptor.   Connect these pins together with jumper wires:  GPIO0 - CD1_SDA\nGPIO1 - CD1_SCL\nGPIO4 - CAM1_IO1\nGPIO5 - CAM1_IO0 \nPlease note that the wiring is slightly different from that on the Camera page, in that you are using GPIO pins 4 and 5 instead of 2 and 3.    For  cam0 , add links:  GPIO28 - CD0_SDA\nGPIO29 - CD0_SCL\nGPIO30 - CAM0_IO1\nGPIO31 - CAM0_IO0  \n(Please note this image needs to be updated to show two Camera Modules, or have the extra jumper leads removed)    On the Compute Module, for the display and one Camera Module, run:  sudo wget https://goo.gl/gaqNrO -O /boot/dt-blob.bin       For the display and two Camera Modules, run:  ```sudo wget https://goo.gl/htHv7m -O /boot/dt-blob.bin```    Reboot for the  dt-blob.bin  file to be read.  \n(Please note this image needs to be updated to show two Camera Modules, or have the extra jumper leads removed)",
            "title": "Quickstart - Display and Camera(s)"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html#software-support",
            "text": "There is no additional configuration required to enable the touchscreen. The touch interface should out work of the box once the screen is successfully detected.",
            "title": "Software support"
        },
        {
            "location": "/hardware/computemodule/cmio-display/index.html#sources",
            "text": "dt-blob-disp1-only.dts  dt-blob-disp1-cam1.dts  dt-blob-disp1-cam2.dts",
            "title": "Sources"
        },
        {
            "location": "/hardware/computemodule/datasheet/index.html",
            "text": "Compute Module Datasheet (covers all Compute Module variants)\n\n\n\n\nDatasheet",
            "title": "Compute Module Datasheet (covers all Compute Module variants)"
        },
        {
            "location": "/hardware/computemodule/datasheet/index.html#compute-module-datasheet-covers-all-compute-module-variants",
            "text": "Datasheet",
            "title": "Compute Module Datasheet (covers all Compute Module variants)"
        },
        {
            "location": "/hardware/computemodule/designfiles/index.html",
            "text": "Compute Module IO board and camera/display adapter board design data\n\n\nDesign data for the Compute Module IO board (CMIO)\n\n\n\n\nCMIO Rev 1.2\n\n\nCMIO Rev 3.0\n\n\n\n\nDesign data for the Compute Module camera/display adapter board (CMCDA)\n\n\n\n\nCMCDA Rev 1.1",
            "title": "Compute Module IO board and camera/display adapter board design data"
        },
        {
            "location": "/hardware/computemodule/designfiles/index.html#compute-module-io-board-and-cameradisplay-adapter-board-design-data",
            "text": "Design data for the Compute Module IO board (CMIO)   CMIO Rev 1.2  CMIO Rev 3.0   Design data for the Compute Module camera/display adapter board (CMCDA)   CMCDA Rev 1.1",
            "title": "Compute Module IO board and camera/display adapter board design data"
        },
        {
            "location": "/hardware/computemodule/schematics/index.html",
            "text": "Compute Module and related schematics\n\n\nSchematics for the Compute Module\n\n\n\n\nCM Rev 1.1\n\n\nCM3 and CM3L Rev 1.0\n\n\n\n\nSchematics for the Compute Module IO board (CMIO). \n\n\n\n\nCMIO Rev 1.2 (Supports CM1 only)\n\n\nCMIO Rev 3.0 (Supports CM1, CM3 and CM3L)\n\n\n\n\nSchematics for the Compute Module camera/display adapter board (CMCDA)\n\n\n\n\nCMCDA Rev 1.1\n\n\n\n\nSchematic for an under-voltage detection circuit, as used in most models of Raspberry Pi\n\n\n\n\nUnder-voltage detect",
            "title": "Compute Module and related schematics"
        },
        {
            "location": "/hardware/computemodule/schematics/index.html#compute-module-and-related-schematics",
            "text": "Schematics for the Compute Module   CM Rev 1.1  CM3 and CM3L Rev 1.0   Schematics for the Compute Module IO board (CMIO).    CMIO Rev 1.2 (Supports CM1 only)  CMIO Rev 3.0 (Supports CM1, CM3 and CM3L)   Schematics for the Compute Module camera/display adapter board (CMCDA)   CMCDA Rev 1.1   Schematic for an under-voltage detection circuit, as used in most models of Raspberry Pi   Under-voltage detect",
            "title": "Compute Module and related schematics"
        },
        {
            "location": "/hardware/display/README/index.html",
            "text": "Raspberry Pi Display\n\n\nIntroduction\n\n\nThe Raspberry Pi display is an LCD display which connects to the Raspberry Pi through the DSI connector. In some situations, it allows for the use of both the HDMI and LCD displays at the same time (this requires software support).\n\n\nBoard Support\n\n\nThe DSI display is designed to work with Raspberry Pi models that have mounting holes in a HAT footprint. Model A/B boards are supported, but require additional mounting hardware to fit the HAT-dimensioned stand-offs on the display PCB.\n\n\nAttaching to Model A/B boards\n\n\nThe DSI connector on the Model A/B boards does not have the I2C connections required to talk to the touchscreen controller and DSI controller. You can work around this by using the additional set of jumper cables provided with the display kit to wire up the I2C bus on the GPIO pins to the display controller board.\n\n\nUsing the jumper cables, connect SCL/SDA on the GPIO header to the horizontal pins marked SCL/SDA on the display board. We also recommend that you power the Model A/B via the GPIO pins using the jumper cables.\n\n\nFor the GPIO header pinout, see \nthis diagram\n.\n\n\nDSI display autodetection is disabled by default on these boards. To enable detection, add the following line to \n/boot/config.txt\n:\n\n\nignore_lcd=0\n\n\nPower the setup via the \nPWR IN\n micro-USB connector on the display board. Do not power the setup via the Pi's micro-USB port: the input polyfuse's maximum current rating will be exceeded as the display consumes approximately 400mA.\n\n\nNB: With the display connected to the GPIO I2C pins, the GPU will assume control of the respective I2C bus. The host operating system should not access this I2C bus, as simultaneous use of the bus by both the GPU and Linux will result in sporadic crashes.\n\n\nScreen Orientation\n\n\nLCD displays have an optimum viewing angle, and depending on how the screen is mounted it may be necessary to change the orientation of the display to give the best results. By default, the Raspberry Pi display and Raspberry Pi are set up to work best when viewed from slightly above, for example on a desktop. If viewing from below, you can physically rotate the display, and then tell the system software to compensate by running the screen upside down.\n\n\nTo flip the display, add, anywhere in the file \n\\boot\\config.txt\n, the following line:\n\n\nlcd_rotate=2\n\n\nThis will vertically flip the LCD and the touch screen, compensating for the physical orientation of the display.\n\n\nTroubleshooting\n\n\nRead our troubleshooting steps, tips, and tricks here: \nRaspberry Pi Display Troubleshooting\n.\n\n\nSpecifications\n\n\n\n\n800 x 480 RGB LCD display\n\n\n24-bit colour\n\n\nIndustrial quality: 140-degree viewing angle horizontal, 130-degree viewing angle vertical\n\n\n10-point multi-touch touchscreen\n\n\nPWM backlight control and power control over I2C interface\n\n\nMetal-framed back with mounting points for Raspberry Pi display conversion board and Raspberry Pi\n\n\nBacklight lifetime: 20000 hours\n\n\nOperating temperature: -20 to +70 degrees centigrade\n\n\nStorage temperature: -30 to +80 degrees centigrade\n\n\nContrast ratio: 500\n\n\nAverage brightness: 250 cd/m\n2\n\n\nViewing angle (degrees):\n\n\nTop - 50\n\n\nBottom - 70\n\n\nLeft - 70\n\n\nRight - 70\n\n\n\n\nModule mechanical specification\n\n\n\n\nOuter dimensions: 192.96 x 112.76mm\n\n\nViewable area: 154.08 x 85.92mm\n\n\nDownload mechanical drawing (PDF, 592kb)\n\n\nAdditional drawing including radius and thickness of glass",
            "title": "Raspberry Pi Display"
        },
        {
            "location": "/hardware/display/README/index.html#raspberry-pi-display",
            "text": "",
            "title": "Raspberry Pi Display"
        },
        {
            "location": "/hardware/display/README/index.html#introduction",
            "text": "The Raspberry Pi display is an LCD display which connects to the Raspberry Pi through the DSI connector. In some situations, it allows for the use of both the HDMI and LCD displays at the same time (this requires software support).",
            "title": "Introduction"
        },
        {
            "location": "/hardware/display/README/index.html#board-support",
            "text": "The DSI display is designed to work with Raspberry Pi models that have mounting holes in a HAT footprint. Model A/B boards are supported, but require additional mounting hardware to fit the HAT-dimensioned stand-offs on the display PCB.",
            "title": "Board Support"
        },
        {
            "location": "/hardware/display/README/index.html#attaching-to-model-ab-boards",
            "text": "The DSI connector on the Model A/B boards does not have the I2C connections required to talk to the touchscreen controller and DSI controller. You can work around this by using the additional set of jumper cables provided with the display kit to wire up the I2C bus on the GPIO pins to the display controller board.  Using the jumper cables, connect SCL/SDA on the GPIO header to the horizontal pins marked SCL/SDA on the display board. We also recommend that you power the Model A/B via the GPIO pins using the jumper cables.  For the GPIO header pinout, see  this diagram .  DSI display autodetection is disabled by default on these boards. To enable detection, add the following line to  /boot/config.txt :  ignore_lcd=0  Power the setup via the  PWR IN  micro-USB connector on the display board. Do not power the setup via the Pi's micro-USB port: the input polyfuse's maximum current rating will be exceeded as the display consumes approximately 400mA.  NB: With the display connected to the GPIO I2C pins, the GPU will assume control of the respective I2C bus. The host operating system should not access this I2C bus, as simultaneous use of the bus by both the GPU and Linux will result in sporadic crashes.",
            "title": "Attaching to Model A/B boards"
        },
        {
            "location": "/hardware/display/README/index.html#screen-orientation",
            "text": "LCD displays have an optimum viewing angle, and depending on how the screen is mounted it may be necessary to change the orientation of the display to give the best results. By default, the Raspberry Pi display and Raspberry Pi are set up to work best when viewed from slightly above, for example on a desktop. If viewing from below, you can physically rotate the display, and then tell the system software to compensate by running the screen upside down.  To flip the display, add, anywhere in the file  \\boot\\config.txt , the following line:  lcd_rotate=2  This will vertically flip the LCD and the touch screen, compensating for the physical orientation of the display.",
            "title": "Screen Orientation"
        },
        {
            "location": "/hardware/display/README/index.html#troubleshooting",
            "text": "Read our troubleshooting steps, tips, and tricks here:  Raspberry Pi Display Troubleshooting .",
            "title": "Troubleshooting"
        },
        {
            "location": "/hardware/display/README/index.html#specifications",
            "text": "800 x 480 RGB LCD display  24-bit colour  Industrial quality: 140-degree viewing angle horizontal, 130-degree viewing angle vertical  10-point multi-touch touchscreen  PWM backlight control and power control over I2C interface  Metal-framed back with mounting points for Raspberry Pi display conversion board and Raspberry Pi  Backlight lifetime: 20000 hours  Operating temperature: -20 to +70 degrees centigrade  Storage temperature: -30 to +80 degrees centigrade  Contrast ratio: 500  Average brightness: 250 cd/m 2  Viewing angle (degrees):  Top - 50  Bottom - 70  Left - 70  Right - 70",
            "title": "Specifications"
        },
        {
            "location": "/hardware/display/README/index.html#module-mechanical-specification",
            "text": "Outer dimensions: 192.96 x 112.76mm  Viewable area: 154.08 x 85.92mm  Download mechanical drawing (PDF, 592kb)  Additional drawing including radius and thickness of glass",
            "title": "Module mechanical specification"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html",
            "text": "Raspberry Pi Display Troubleshooting\n\n\nBefore You Start\n\n\nHave you got a good power supply?\n\n\nHaving intermittent problems, or seeing a little rainbow square in the top right corner? It is likely that you need a better power supply.\n\n\nWe recommend our official 2.5A adapter because we know it works, but any good 2.5A supply should work.\n\n\nHave you updated Raspbian?\n\n\nIf not, many problems will be solved by making sure your software is up-to date.\n\n\nYou can undo any previous use of \nrpi-update\n and get your Pi back to the latest stable software by connecting\nto a network and running:\n\n\nsudo apt-get update\nsudo apt-get install --reinstall libraspberrypi0 libraspberrypi-\n{\nbin,dev,doc\n}\n raspberrypi-bootloader\nsudo reboot\n\n\n\n\n\nFrequent Problems\n\n\nMy touchscreen doesn't work, or works intermittently\n\n\n\n\nMake sure you've updated Raspbian (see above for steps)\n\n\nCheck the smaller ribbon cable is seated properly\n\n\n\n\nIf you want to make sure your Pi has detected your touchscreen, try running:\n\n\ndmesg \n|\n grep -i ft5406\n\n\n\n\n\nYou should see a couple of lines that look like this:\n\n\n[ 5.224267] rpi-ft5406 rpi_ft5406: Probing device\n[ 5.225960] input: FT5406 memory based driver as /devices/virtual/input/input3\n\n\n\n\n\nA detected touchscreen will also cause the \nfbheight\n and \nfbwidth\n parameters in \n/proc/cmdline\n to equal 480 and 800 respectively (the resolution of the screen). You can verify this by running:\n\n\ncat /proc/cmdline | grep bcm2708_fb\n\n\n\n\n\nMy screen is upside-down!\n\n\nDepending on your display stand, you might find that the LCD display defaults to being upside-down. You can fix this by rotating it with \n/boot/config.txt\n.\n\n\nsudo nano /boot/config.txt\n\n\n\n\n\nThen add:\n\n\nlcd_rotate\n=\n2\n\n\n\n\n\n\nHit \nCTRL+X\n and \ny\n to save. And finally:\n\n\nsudo reboot\n\n\n\n\n\nMy display fades out to weird patterns when I shutdown/reboot my Pi\n\n\nDon't panic! This is perfectly normal.\n\n\nMy display is black\n\n\n\n\nMake sure you've updated Raspbian (see above for steps)\n\n\nCheck the ribbon cable between your Pi and the LCD is properly seated\n\n\nMake sure you have a SD card properly inserted into your Pi\n\n\n\n\nMy display is white\n\n\n\n\nCheck the larger ribbon cable between the display and driver board is properly seated\n\n\n\n\nRaspbian says my screen is 752x448. Surely that's wrong?\n\n\nYes, the screen should be 800x480. This is a result of overscan being enabled.\n\n\nDisable it by running raspi-config:\n\n\nsudo raspi-config\n\n\n\n\n\nAnd then navigating to \nAdvanced Options\n > \nOverscan\n and picking \nDisable\n. \n\n\nMy touchscreen isn't aligned correctly: my taps are slightly out\n\n\nThis is probably also a side-effect of overscan being enabled, try the solution above.\n\n\nMy screen isn't working with my old Model B or Model A Pi\n\n\nThe Model A or B Pi need a couple of extra connections, and an extra line of config. Please see section \"Attaching to Model A/B boards\" of \nthe main display page\n.\n\n\nSome windows are cut off at the bottom of the screen so I can't use them\n\n\nIf some windows in X are cut off at the side/bottom of the screen, this is unfortunately a side-effect of developers assuming a minimum screen resolution of 1024x768 pixels.\n\n\nYou can usually reveal hidden buttons and fields by;\n\n\n\n\nright clicking on the edge or top of the window,\n\n\npicking \"move\"\n\n\nusing the up arrow key to nudge the window up off the top of the screen\n\n\n\n\nIf you don't have a mouse, see the right click fix below.\n\n\nTips & Tricks\n\n\nHow do I use multiple monitors?\n\n\nAt the moment you can't use HDMI and the LCD together in the X desktop, but you can send the output of certain applications to one screen or the other.\n\n\nOmxplayer is one example. It has been modified to enable secondary display output.\n\n\nTo start displaying a video onto the LCD display (assuming it is the default display) just type:\n\n\nomxplayer video.mkv\n\n\n\n\n\nTo start a second video onto the HDMI type:\n\n\nomxplayer --display\n=\n5\n video.mkv\n\n\n\n\n\nPlease note: you may need to increase the amount of memory allocated to the GPU to 128MB if the videos are 1080P. Adjust the gpu_mem value in config.txt for this. The Raspberry Pi headline figures are 1080P30 decode, so if you are using two 1080P clips it may not play correctly depending on the complexity of the videos.\n\n\nDisplay numbers are:\n\n\n\n\nLCD: 4\n\n\nTV/HDMI: 5\n\n\nAuto select non-default display: 6\n\n\n\n\nHow do I enable right click?\n\n\nYou can emulate a right click with a setting change. Just:\n\n\nsudo nano /etc/X11/xorg.conf\n\n\n\n\n\nPaste in:\n\n\nSection \"InputClass\"\n   Identifier \"calibration\"\n   Driver \"evdev\"\n   MatchProduct \"FT5406 memory based driver\"\n\n   Option \"EmulateThirdButton\" \"1\"\n   Option \"EmulateThirdButtonTimeout\" \"750\"\n   Option \"EmulateThirdButtonMoveThreshold\" \"30\"\nEndSection\n\n\n\n\n\nHit \nCTRL+X\n and \ny\n to save. Then:\n\n\nsudo reboot\n\n\n\n\n\nOnce enabled, right click works by pressing and holding the touchscreen and will be activated after a short delay.\n\n\nHow do I get an on-screen keyboard?\n\n\nFlorence Virtual Keyboard\n\n\nInstall with:\n\n\nsudo apt-get install florence\n\n\n\n\n\nMatchbox Virtual Keyboard\n\n\nInstall like so:\n\n\nsudo apt-get install matchbox-keyboard\n\n\n\n\n\nAnd then find in \nAccessories\n > \nKeyboard\n.",
            "title": "Raspberry Pi Display Troubleshooting"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#raspberry-pi-display-troubleshooting",
            "text": "",
            "title": "Raspberry Pi Display Troubleshooting"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#before-you-start",
            "text": "",
            "title": "Before You Start"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#have-you-got-a-good-power-supply",
            "text": "Having intermittent problems, or seeing a little rainbow square in the top right corner? It is likely that you need a better power supply.  We recommend our official 2.5A adapter because we know it works, but any good 2.5A supply should work.",
            "title": "Have you got a good power supply?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#have-you-updated-raspbian",
            "text": "If not, many problems will be solved by making sure your software is up-to date.  You can undo any previous use of  rpi-update  and get your Pi back to the latest stable software by connecting\nto a network and running:  sudo apt-get update\nsudo apt-get install --reinstall libraspberrypi0 libraspberrypi- { bin,dev,doc }  raspberrypi-bootloader\nsudo reboot",
            "title": "Have you updated Raspbian?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#frequent-problems",
            "text": "",
            "title": "Frequent Problems"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-touchscreen-doesnt-work-or-works-intermittently",
            "text": "Make sure you've updated Raspbian (see above for steps)  Check the smaller ribbon cable is seated properly   If you want to make sure your Pi has detected your touchscreen, try running:  dmesg  |  grep -i ft5406  You should see a couple of lines that look like this:  [ 5.224267] rpi-ft5406 rpi_ft5406: Probing device\n[ 5.225960] input: FT5406 memory based driver as /devices/virtual/input/input3  A detected touchscreen will also cause the  fbheight  and  fbwidth  parameters in  /proc/cmdline  to equal 480 and 800 respectively (the resolution of the screen). You can verify this by running:  cat /proc/cmdline | grep bcm2708_fb",
            "title": "My touchscreen doesn't work, or works intermittently"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-screen-is-upside-down",
            "text": "Depending on your display stand, you might find that the LCD display defaults to being upside-down. You can fix this by rotating it with  /boot/config.txt .  sudo nano /boot/config.txt  Then add:  lcd_rotate = 2   Hit  CTRL+X  and  y  to save. And finally:  sudo reboot",
            "title": "My screen is upside-down!"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-display-fades-out-to-weird-patterns-when-i-shutdownreboot-my-pi",
            "text": "Don't panic! This is perfectly normal.",
            "title": "My display fades out to weird patterns when I shutdown/reboot my Pi"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-display-is-black",
            "text": "Make sure you've updated Raspbian (see above for steps)  Check the ribbon cable between your Pi and the LCD is properly seated  Make sure you have a SD card properly inserted into your Pi",
            "title": "My display is black"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-display-is-white",
            "text": "Check the larger ribbon cable between the display and driver board is properly seated",
            "title": "My display is white"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#raspbian-says-my-screen-is-752x448-surely-thats-wrong",
            "text": "Yes, the screen should be 800x480. This is a result of overscan being enabled.  Disable it by running raspi-config:  sudo raspi-config  And then navigating to  Advanced Options  >  Overscan  and picking  Disable .",
            "title": "Raspbian says my screen is 752x448. Surely that's wrong?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-touchscreen-isnt-aligned-correctly-my-taps-are-slightly-out",
            "text": "This is probably also a side-effect of overscan being enabled, try the solution above.",
            "title": "My touchscreen isn't aligned correctly: my taps are slightly out"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#my-screen-isnt-working-with-my-old-model-b-or-model-a-pi",
            "text": "The Model A or B Pi need a couple of extra connections, and an extra line of config. Please see section \"Attaching to Model A/B boards\" of  the main display page .",
            "title": "My screen isn't working with my old Model B or Model A Pi"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#some-windows-are-cut-off-at-the-bottom-of-the-screen-so-i-cant-use-them",
            "text": "If some windows in X are cut off at the side/bottom of the screen, this is unfortunately a side-effect of developers assuming a minimum screen resolution of 1024x768 pixels.  You can usually reveal hidden buttons and fields by;   right clicking on the edge or top of the window,  picking \"move\"  using the up arrow key to nudge the window up off the top of the screen   If you don't have a mouse, see the right click fix below.",
            "title": "Some windows are cut off at the bottom of the screen so I can't use them"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#tips-tricks",
            "text": "",
            "title": "Tips &amp; Tricks"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#how-do-i-use-multiple-monitors",
            "text": "At the moment you can't use HDMI and the LCD together in the X desktop, but you can send the output of certain applications to one screen or the other.  Omxplayer is one example. It has been modified to enable secondary display output.  To start displaying a video onto the LCD display (assuming it is the default display) just type:  omxplayer video.mkv  To start a second video onto the HDMI type:  omxplayer --display = 5  video.mkv  Please note: you may need to increase the amount of memory allocated to the GPU to 128MB if the videos are 1080P. Adjust the gpu_mem value in config.txt for this. The Raspberry Pi headline figures are 1080P30 decode, so if you are using two 1080P clips it may not play correctly depending on the complexity of the videos.  Display numbers are:   LCD: 4  TV/HDMI: 5  Auto select non-default display: 6",
            "title": "How do I use multiple monitors?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#how-do-i-enable-right-click",
            "text": "You can emulate a right click with a setting change. Just:  sudo nano /etc/X11/xorg.conf  Paste in:  Section \"InputClass\"\n   Identifier \"calibration\"\n   Driver \"evdev\"\n   MatchProduct \"FT5406 memory based driver\"\n\n   Option \"EmulateThirdButton\" \"1\"\n   Option \"EmulateThirdButtonTimeout\" \"750\"\n   Option \"EmulateThirdButtonMoveThreshold\" \"30\"\nEndSection  Hit  CTRL+X  and  y  to save. Then:  sudo reboot  Once enabled, right click works by pressing and holding the touchscreen and will be activated after a short delay.",
            "title": "How do I enable right click?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#how-do-i-get-an-on-screen-keyboard",
            "text": "",
            "title": "How do I get an on-screen keyboard?"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#florence-virtual-keyboard",
            "text": "Install with:  sudo apt-get install florence",
            "title": "Florence Virtual Keyboard"
        },
        {
            "location": "/hardware/display/troubleshooting/index.html#matchbox-virtual-keyboard",
            "text": "Install like so:  sudo apt-get install matchbox-keyboard  And then find in  Accessories  >  Keyboard .",
            "title": "Matchbox Virtual Keyboard"
        },
        {
            "location": "/hardware/industrial/README/index.html",
            "text": "Industrial use of the Raspberry Pi\n\n\nThe Raspberry Pi is often used as part of another product. This documentation describes some extra facilities available to use other capabilities of the Pi.\n\n\nCustomer OTP settings\n\n\nThere are a number of OTP values that can be used. To see a list of all the OTP values, you can use:\n\n\npi@raspberrypi:~ $ vcgencmd otp_dump\n\n\n\n\n\nSome interesting lines from this dump are:\n\n\n\n\n28 - Serial number\n\n\n29 - Ones complement of serial number\n\n\n30 - Revision number\n\n\n\n\nAlso, from 36 to 43 (inclusive), there are eight rows of 32 bits available for the customer\n\n\nTo program these bits, you will need to use the vcmailbox. This is a Linux driver interface to the firmware which will handle the programming of the rows. To do this, please refer to the documentation \nhere\n, and the vcmailbox example application \nhere\n.\n\n\nThe vcmailbox application can be used directly from the command line on a Raspberry Pi Raspbian build. An example usage would be:\n\n\npi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00010004 8 8 0 0\n0x00000020 0x80000000 0x00010004 0x00000008 0x800000008 0xnnnnnnnn 0x00000000 0x00000000\n\n\n\n\n\nThe above uses the \nmailbox property interface\n \nGET_BOARD_SERIAL\n with a request size of 8 bytes and response size of 8 bytes (sending two integers for the request 0, 0). The response to this will be two integers (0x00000020 and 0x80000000) followed by the tag code, the request length, the response length (with the 31st bit set to indicate that it is a response) then the 64 bit serial number (where the MS 32bits are always 0).\n\n\nTo set the customer OTP values you will need to use the \nSET_CUSTOMER_OTP\n (0x38021) tag as follows:\n\n\npi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 [8 + number * 4] [8 + number * 4] [start_num] [number] [value] [value] [value] ...\n\n\n\n\n\n\n\nstart_num\n = the first row to program from 0-7\n\n\nnumber\n = number of rows to program\n\n\nvalue\n = each value to program\n\n\n\n\nSo, to program OTP customer rows 4, 5, and 6 to 0x11111111, 0x22222222, 0x33333333 respectively, you would use:\n\n\npi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 20 20 4 3 0x11111111 0x22222222 0x33333333\n\n\n\n\n\nThis will then program rows 40, 41, and 42.\n\n\nTo read the values back, you can use:\n\n\npi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00030021 20 20 4 3 0 0 0\n0x0000002c 0x80000000 0x00030021 0x00000014 0x80000014 0x00000000 0x00000003 0x11111111 0x22222222 0x33333333\n\n\n\n\n\nIf you'd like to integrate this functionality into your own code, you should be able to achieve this by using the vcmailbox.c code as an example.\n\n\nLocking the OTP changes\n\n\nIt is possible to lock the OTP changes to avoid them being edited again. This can be done using a special argument with the OTP write mailbox:\n\n\npi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 8 8 0xffffffff 0xaffe0000\n\n\n\n\n\nOnce locked, none of the customer OTP values can be accessed.",
            "title": "Industrial use of the Raspberry Pi"
        },
        {
            "location": "/hardware/industrial/README/index.html#industrial-use-of-the-raspberry-pi",
            "text": "The Raspberry Pi is often used as part of another product. This documentation describes some extra facilities available to use other capabilities of the Pi.",
            "title": "Industrial use of the Raspberry Pi"
        },
        {
            "location": "/hardware/industrial/README/index.html#customer-otp-settings",
            "text": "There are a number of OTP values that can be used. To see a list of all the OTP values, you can use:  pi@raspberrypi:~ $ vcgencmd otp_dump  Some interesting lines from this dump are:   28 - Serial number  29 - Ones complement of serial number  30 - Revision number   Also, from 36 to 43 (inclusive), there are eight rows of 32 bits available for the customer  To program these bits, you will need to use the vcmailbox. This is a Linux driver interface to the firmware which will handle the programming of the rows. To do this, please refer to the documentation  here , and the vcmailbox example application  here .  The vcmailbox application can be used directly from the command line on a Raspberry Pi Raspbian build. An example usage would be:  pi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00010004 8 8 0 0\n0x00000020 0x80000000 0x00010004 0x00000008 0x800000008 0xnnnnnnnn 0x00000000 0x00000000  The above uses the  mailbox property interface   GET_BOARD_SERIAL  with a request size of 8 bytes and response size of 8 bytes (sending two integers for the request 0, 0). The response to this will be two integers (0x00000020 and 0x80000000) followed by the tag code, the request length, the response length (with the 31st bit set to indicate that it is a response) then the 64 bit serial number (where the MS 32bits are always 0).  To set the customer OTP values you will need to use the  SET_CUSTOMER_OTP  (0x38021) tag as follows:  pi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 [8 + number * 4] [8 + number * 4] [start_num] [number] [value] [value] [value] ...   start_num  = the first row to program from 0-7  number  = number of rows to program  value  = each value to program   So, to program OTP customer rows 4, 5, and 6 to 0x11111111, 0x22222222, 0x33333333 respectively, you would use:  pi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 20 20 4 3 0x11111111 0x22222222 0x33333333  This will then program rows 40, 41, and 42.  To read the values back, you can use:  pi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00030021 20 20 4 3 0 0 0\n0x0000002c 0x80000000 0x00030021 0x00000014 0x80000014 0x00000000 0x00000003 0x11111111 0x22222222 0x33333333  If you'd like to integrate this functionality into your own code, you should be able to achieve this by using the vcmailbox.c code as an example.",
            "title": "Customer OTP settings"
        },
        {
            "location": "/hardware/industrial/README/index.html#locking-the-otp-changes",
            "text": "It is possible to lock the OTP changes to avoid them being edited again. This can be done using a special argument with the OTP write mailbox:  pi@raspberrypi:~ $ /opt/vc/bin/vcmailbox 0x00038021 8 8 0xffffffff 0xaffe0000  Once locked, none of the customer OTP values can be accessed.",
            "title": "Locking the OTP changes"
        },
        {
            "location": "/hardware/raspberrypi/README/index.html",
            "text": "Raspberry Pi Hardware\n\n\nThe hardware in the Raspberry Pi\n\n\n\n\nSchematics\n\n\nSchematics for the Raspberry Pi\n\n\n\n\n\n\nBCM2835\n\n\nThe Broadcom processor used in Raspberry Pi 1 and Zero\n\n\n\n\n\n\nBCM2836\n\n\nThe Broadcom processor used in Raspberry Pi 2\n\n\n\n\n\n\nBCM2837\n\n\nThe Broadcom processor used in Raspberry Pi 3 (and later Raspberry Pi 2)\n\n\n\n\n\n\nBootmodes\n\n\nA description of the BCM2835/6/7 bootmodes available \n\n\n\n\n\n\nMechanical Drawings\n\n\nMechanical drawings of the Raspberry Pi\n\n\n\n\n\n\nPower\n\n\nPowering the Raspberry Pi\n\n\n\n\n\n\nUSB\n\n\nUSB on the Raspberry Pi\n\n\n\n\n\n\nGPIO\n\n\nGeneral Purpose Input/Output pins on the Raspberry Pi\n\n\n\n\n\n\nSPI\n\n\nSPI on the Raspberry Pi\n\n\n\n\n\n\nDPI (Parallel/RGB Display)\n\n\nDPI on the Raspberry Pi\n\n\n\n\n\n\nPeripheral Addresses\n\n\nHow to access peripheral addresses using the bcm_host helpers\n\n\n\n\n\n\nStandard Conformity Documentation\n\n\nConformance documentation for the various standards bodies\n\n\n\n\n\n\nRevision codes\n\n\nRaspberry Pi revision code reference",
            "title": "Raspberry Pi Hardware"
        },
        {
            "location": "/hardware/raspberrypi/README/index.html#raspberry-pi-hardware",
            "text": "The hardware in the Raspberry Pi   Schematics  Schematics for the Raspberry Pi    BCM2835  The Broadcom processor used in Raspberry Pi 1 and Zero    BCM2836  The Broadcom processor used in Raspberry Pi 2    BCM2837  The Broadcom processor used in Raspberry Pi 3 (and later Raspberry Pi 2)    Bootmodes  A description of the BCM2835/6/7 bootmodes available     Mechanical Drawings  Mechanical drawings of the Raspberry Pi    Power  Powering the Raspberry Pi    USB  USB on the Raspberry Pi    GPIO  General Purpose Input/Output pins on the Raspberry Pi    SPI  SPI on the Raspberry Pi    DPI (Parallel/RGB Display)  DPI on the Raspberry Pi    Peripheral Addresses  How to access peripheral addresses using the bcm_host helpers    Standard Conformity Documentation  Conformance documentation for the various standards bodies    Revision codes  Raspberry Pi revision code reference",
            "title": "Raspberry Pi Hardware"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html",
            "text": "Compliance\n\n\nRaspberry Pi models conform to various standards. The available Documents of Conformance are linked in the shortcut table below, and in more detail further down the page. Note that not all standards that apply are listed here. \n\n\n\n\n\n\n\n\nModel\n\n\nEU Declaration\n\n\nFCC Declaration\n\n\nOthers\n\n\n\n\n\n\n\n\n\n\nA+\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\nB+\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\n2B\n\n\nDeclaration\n\n\nDeclaration\n\n\n\n\n\n\n\n\n3B\n\n\nDeclaration\n\n\nDSS\n,\nDTS\n\n\nSee below for more regions.\n\n\n\n\n\n\nZero\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\nZero W\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\nCM3/CM3 Lite\n\n\nDeclaration\n\n\nDeclaration\n\n\n\n\n\n\n\n\nDisplay\n\n\nDeclaration\n\n\nDeclaration\n\n\n\n\n\n\n\n\nCamera v1\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\nCamera v2\n\n\nDeclaration\n\n\nDeclaration\n\n\n\n\n\n\n\n\nSense HAT\n\n\nDeclaration\n\n\n\n\n\n\n\n\n\n\n\n\nRaspberry Pi Model A+\n\n\nThe Raspberry Pi Model A+ device has undergone extensive compliance testing and meets the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi Model B+\n\n\nThe Raspberry Pi Model B+ device has undergone extensive compliance testing and meets the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi 2 Model B\n\n\nAll Raspberry Pi 2 Model B devices have undergone extensive compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\n\n\nUSA\n\n\n\n\nANSI C63.4 \n\n\nFCC 47 CFR Part 15, Subpart B, Class B Digital Device.\n\n\n\n\nFCC Declaration of Conformity\n \n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi Model 3\n\n\nAll Raspberry Pi Model 3 devices have undergone extensive compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\nHealth and Safety (Art.3(1)(a))\n\n\nEN60950-1:2006 /A11:2009 /A1:2010 /A12:2011 /A2:2013\n\n\nEN62311:2008 Electronic and electrical equipment related to human exposure restrictions for electromagnetic fields (0Hz-300Ghz)\n\n\n\n\n\n\nEMC (Art 3(1)(b))\n\n\nEN55032:21012; EN55024:2010 (with reference to EN301489-1v1.9.2  & EN301489-17v2.2.1)\n\n\n\n\n\n\nSPECTRUM (Art 3(2))\n\n\nEN300 328 v2.1.1 covering wide band transmission systems and data transmission equipment operating in the 2.4GHz ISM band.\n\n\n\n\n\n\n\n\nFCC Declaration of Conformity (DSS)\n  \n\n\nFCC Declaration of Conformity (DTS)\n  \n\n\nEU Declaration of Conformity\n\n\nModel 3, other regions\n\n\nAustralia/New Zealand\n\n\nAustralia/New Zealand (LOA)\n\n\nCanada\n\n\nChina 1\n\n\nChina 2\n\n\nHong Kong\n\n\nIndia\n\n\nJapan\n\n\nRussia\n\n\nSerbia\n\n\nSouth Africa\n\n\nSouth Korea\n\n\nTaiwan\n  \n\n\nRaspberry Pi Zero\n\n\nAll Raspberry Pi Model Zero devices have undergone extensive compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi Zero W\n\n\nAll Raspberry Pi Model Zero W devices have undergone extensive compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\nHealth and Safety (Art.3(1)(a))\n\n\nEN60950-1:2006 /A11:2009 /A1:2010 /A12:2011 /A2:2013\n\n\nEN62311:2008 Electronic and electrical equipment related to human exposure restrictions for electromagnetic fields (0Hz-300Ghz)\n\n\n\n\n\n\nEMC (Art 3(1)(b))\n\n\nEN55032:21012; EN55024:2010 (with reference to EN301489-1v1.9.2  & EN301489-17v2.2.1)\n\n\n\n\n\n\nSPECTRUM (Art 3(2))\n\n\nEN300 328 v2.1.1 covering wide band transmission systems and data transmission equipment operating in the 2.4GHz ISM band.\n\n\n\n\n\n\n\n\nEU Declaration of Conformity\n\n\nCompute Module 3 and Compute Module 3 Lite\n\n\nAll Raspberry Pi Compute Module 3 devices and the IO board have undergone extensive compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\nEN55032:2012 Class B\n\n\n\n\n\n\nUSA\n\n\n\n\nANSI C63.4 \n\n\nFCC 47 CFR Part 15, Subpart B, Class B Digital Device.\n\n\n\n\nFCC Declaration of Conformity\n \n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi Camera, PiNoIR camera, Pi Camera 2, PiNoIR Camera 2\n\n\nThe Raspberry Pi Camera Modules have undergone compliance testing and meet the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\n\n\nUSA\n\n\n\n\nANSI C63.4 \n\n\nFCC 47 CFR Part 15, Subpart B, Class A Digital Device.\n\n\n\n\nEU Declaration of Conformity Camera\n\n\nEU Declaration of Conformity Camera 2\n\n\nFCC Declaration of Conformity Camera 2\n\n\nRaspberry Pi Display\n\n\nThe Raspberry Pi Touchscreen Display has undergone compliance testing and meets the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\nUSA\n\n\nANSI C63.4 \n\n\nFCC 47 CFR Part 15, Subpart B, Class B Digital Device.\n\n\n\n\nFCC Declaration of Conformity\n \n\n\nEU Declaration of Conformity\n\n\nRaspberry Pi Sense HAT\n\n\nThe Raspberry Pi Sense HAT has undergone compliance testing and meets the following standards:\n\n\n\n\nEU\n\n\nElectromagnetic Compatibility Directive (EMC) 2014/30/EU,\n\n\nRestriction of Hazardous Substances (RoHS) Directive 2011/65/EU\n\n\n\n\nEU Declaration of Conformity",
            "title": "Compliance"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#compliance",
            "text": "Raspberry Pi models conform to various standards. The available Documents of Conformance are linked in the shortcut table below, and in more detail further down the page. Note that not all standards that apply are listed here.      Model  EU Declaration  FCC Declaration  Others      A+  Declaration      B+  Declaration      2B  Declaration  Declaration     3B  Declaration  DSS , DTS  See below for more regions.    Zero  Declaration      Zero W  Declaration      CM3/CM3 Lite  Declaration  Declaration     Display  Declaration  Declaration     Camera v1  Declaration      Camera v2  Declaration  Declaration     Sense HAT  Declaration",
            "title": "Compliance"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-model-a",
            "text": "The Raspberry Pi Model A+ device has undergone extensive compliance testing and meets the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU   EU Declaration of Conformity",
            "title": "Raspberry Pi Model A+"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-model-b",
            "text": "The Raspberry Pi Model B+ device has undergone extensive compliance testing and meets the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU   EU Declaration of Conformity",
            "title": "Raspberry Pi Model B+"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-2-model-b",
            "text": "All Raspberry Pi 2 Model B devices have undergone extensive compliance testing and meet the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,   Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU    USA   ANSI C63.4   FCC 47 CFR Part 15, Subpart B, Class B Digital Device.   FCC Declaration of Conformity    EU Declaration of Conformity",
            "title": "Raspberry Pi 2 Model B"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-model-3",
            "text": "All Raspberry Pi Model 3 devices have undergone extensive compliance testing and meet the following standards:   EU  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU  Health and Safety (Art.3(1)(a))  EN60950-1:2006 /A11:2009 /A1:2010 /A12:2011 /A2:2013  EN62311:2008 Electronic and electrical equipment related to human exposure restrictions for electromagnetic fields (0Hz-300Ghz)    EMC (Art 3(1)(b))  EN55032:21012; EN55024:2010 (with reference to EN301489-1v1.9.2  & EN301489-17v2.2.1)    SPECTRUM (Art 3(2))  EN300 328 v2.1.1 covering wide band transmission systems and data transmission equipment operating in the 2.4GHz ISM band.     FCC Declaration of Conformity (DSS)     FCC Declaration of Conformity (DTS)     EU Declaration of Conformity",
            "title": "Raspberry Pi Model 3"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#model-3-other-regions",
            "text": "Australia/New Zealand  Australia/New Zealand (LOA)  Canada  China 1  China 2  Hong Kong  India  Japan  Russia  Serbia  South Africa  South Korea  Taiwan",
            "title": "Model 3, other regions"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-zero",
            "text": "All Raspberry Pi Model Zero devices have undergone extensive compliance testing and meet the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU   EU Declaration of Conformity",
            "title": "Raspberry Pi Zero"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-zero-w",
            "text": "All Raspberry Pi Model Zero W devices have undergone extensive compliance testing and meet the following standards:   EU  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU  Health and Safety (Art.3(1)(a))  EN60950-1:2006 /A11:2009 /A1:2010 /A12:2011 /A2:2013  EN62311:2008 Electronic and electrical equipment related to human exposure restrictions for electromagnetic fields (0Hz-300Ghz)    EMC (Art 3(1)(b))  EN55032:21012; EN55024:2010 (with reference to EN301489-1v1.9.2  & EN301489-17v2.2.1)    SPECTRUM (Art 3(2))  EN300 328 v2.1.1 covering wide band transmission systems and data transmission equipment operating in the 2.4GHz ISM band.     EU Declaration of Conformity",
            "title": "Raspberry Pi Zero W"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#compute-module-3-and-compute-module-3-lite",
            "text": "All Raspberry Pi Compute Module 3 devices and the IO board have undergone extensive compliance testing and meet the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU   EN55032:2012 Class B    USA   ANSI C63.4   FCC 47 CFR Part 15, Subpart B, Class B Digital Device.   FCC Declaration of Conformity    EU Declaration of Conformity",
            "title": "Compute Module 3 and Compute Module 3 Lite"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-camera-pinoir-camera-pi-camera-2-pinoir-camera-2",
            "text": "The Raspberry Pi Camera Modules have undergone compliance testing and meet the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,   Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU    USA   ANSI C63.4   FCC 47 CFR Part 15, Subpart B, Class A Digital Device.   EU Declaration of Conformity Camera  EU Declaration of Conformity Camera 2  FCC Declaration of Conformity Camera 2",
            "title": "Raspberry Pi Camera, PiNoIR camera, Pi Camera 2, PiNoIR Camera 2"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-display",
            "text": "The Raspberry Pi Touchscreen Display has undergone compliance testing and meets the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU  USA  ANSI C63.4   FCC 47 CFR Part 15, Subpart B, Class B Digital Device.   FCC Declaration of Conformity    EU Declaration of Conformity",
            "title": "Raspberry Pi Display"
        },
        {
            "location": "/hardware/raspberrypi/conformity/index.html#raspberry-pi-sense-hat",
            "text": "The Raspberry Pi Sense HAT has undergone compliance testing and meets the following standards:   EU  Electromagnetic Compatibility Directive (EMC) 2014/30/EU,  Restriction of Hazardous Substances (RoHS) Directive 2011/65/EU   EU Declaration of Conformity",
            "title": "Raspberry Pi Sense HAT"
        },
        {
            "location": "/hardware/raspberrypi/peripheral_addresses/index.html",
            "text": "Peripheral Addresses\n\n\nIf there is no kernel driver available, and a program needs to access a peripheral address directly with mmap, it needs to know where in the virtual memory map the peripheral bus segment has been placed. This varies according to which model of Raspberry Pi is being used, so there are three helper function available to provide platform independence. \nNote\n: please use these functions rather than hardcoded values, as this will ensure future compatibility.\n\n\nunsigned bcm_host_get_peripheral_address()\n\n\nThis returns the ARM-side physical address where peripherals are mapped. This is 0x20000000 on the Pi Zero, Pi Zero W, and the first generation of the Raspberry Pi and Compute Module, and 0x3f000000 on the Pi 2, Pi 3 and Compute Module 3.\n\n\nunsigned bcm_host_get_peripheral_size()\n\n\nThis returns the size of the peripheral's space, which is 0x01000000 for all models.\n\n\nunsigned bcm_host_get_sdram_address()\n\n\nThis returns the bus address of the SDRAM. This is 0x40000000 on the Pi Zero, Pi Zero W, and the first generation of the Raspberry Pi and Compute Module (GPU L2 cached), and 0xC0000000 on the Pi 2, Pi 3 and Compute Module 3 (uncached).",
            "title": "Peripheral Addresses"
        },
        {
            "location": "/hardware/raspberrypi/peripheral_addresses/index.html#peripheral-addresses",
            "text": "If there is no kernel driver available, and a program needs to access a peripheral address directly with mmap, it needs to know where in the virtual memory map the peripheral bus segment has been placed. This varies according to which model of Raspberry Pi is being used, so there are three helper function available to provide platform independence.  Note : please use these functions rather than hardcoded values, as this will ensure future compatibility.  unsigned bcm_host_get_peripheral_address()  This returns the ARM-side physical address where peripherals are mapped. This is 0x20000000 on the Pi Zero, Pi Zero W, and the first generation of the Raspberry Pi and Compute Module, and 0x3f000000 on the Pi 2, Pi 3 and Compute Module 3.  unsigned bcm_host_get_peripheral_size()  This returns the size of the peripheral's space, which is 0x01000000 for all models.  unsigned bcm_host_get_sdram_address()  This returns the bus address of the SDRAM. This is 0x40000000 on the Pi Zero, Pi Zero W, and the first generation of the Raspberry Pi and Compute Module (GPU L2 cached), and 0xC0000000 on the Pi 2, Pi 3 and Compute Module 3 (uncached).",
            "title": "Peripheral Addresses"
        },
        {
            "location": "/hardware/raspberrypi/bcm2835/README/index.html",
            "text": "BCM2835\n\n\nThis is the Broadcom chip used in the Raspberry Pi Model A, B, B+, the Compute Module, and the Raspberry Pi Zero.\n\n\nPlease refer to:\n\n\n\n\nPeripheral specification\n\n\nNote:\n This document contains a number of errors. A list of currently known errata and some additional information can be found \nhere\n.\n\n\nGPU documentation\n and \nopen-source driver\n\n\nARM1176 processor\n\n\nARM1176JZF-S\n\n\n\n\nAlso see the Raspberry Pi 2 Model B's chip, \nBCM2836\n.",
            "title": "BCM2835"
        },
        {
            "location": "/hardware/raspberrypi/bcm2835/README/index.html#bcm2835",
            "text": "This is the Broadcom chip used in the Raspberry Pi Model A, B, B+, the Compute Module, and the Raspberry Pi Zero.  Please refer to:   Peripheral specification  Note:  This document contains a number of errors. A list of currently known errata and some additional information can be found  here .  GPU documentation  and  open-source driver  ARM1176 processor  ARM1176JZF-S   Also see the Raspberry Pi 2 Model B's chip,  BCM2836 .",
            "title": "BCM2835"
        },
        {
            "location": "/hardware/raspberrypi/bcm2836/README/index.html",
            "text": "BCM2836\n\n\nThe Broadcom chip used in the Raspberry Pi 2 Model B\n\n\nThe underlying architecture in BCM2836 is identical to BCM2835. The only significant difference is the removal of the ARM1176JZF-S processor and replacement with a quad-core Cortex-A7 cluster.\n\n\nPlease refer to:\n\n\n\n\nBCM2836 ARM-local peripherals\n\n\nCortex-A7 MPcore Processor Reference Manual\n\n\n\n\nAlso see the chip used in the Raspberry Pi Model A, B, B+, the Compute Module, and the Raspberry Pi Zero, \nBCM2835",
            "title": "BCM2836"
        },
        {
            "location": "/hardware/raspberrypi/bcm2836/README/index.html#bcm2836",
            "text": "The Broadcom chip used in the Raspberry Pi 2 Model B  The underlying architecture in BCM2836 is identical to BCM2835. The only significant difference is the removal of the ARM1176JZF-S processor and replacement with a quad-core Cortex-A7 cluster.  Please refer to:   BCM2836 ARM-local peripherals  Cortex-A7 MPcore Processor Reference Manual   Also see the chip used in the Raspberry Pi Model A, B, B+, the Compute Module, and the Raspberry Pi Zero,  BCM2835",
            "title": "BCM2836"
        },
        {
            "location": "/hardware/raspberrypi/bcm2837/README/index.html",
            "text": "BCM2837\n\n\nThis is the Broadcom chip used in the Raspberry Pi 3, and in later models of the Raspberry Pi 2. The underlying architecture of the BCM2837 is identical to the BCM2836. The only significant difference is the replacement of the ARMv7 quad core cluster with a quad-core ARM Cortex A53 (ARMv8) cluster.\n\n\nThe ARM cores run at 1.2GHz, making the device about 50% faster than the Raspberry Pi 2. The VideoCore IV runs at 400MHz.\n\n\nAlso see the Raspberry Pi 2's chip \nBCM2836\n and the Raspberry Pi 1's chip \nBCM2835\n.",
            "title": "BCM2837"
        },
        {
            "location": "/hardware/raspberrypi/bcm2837/README/index.html#bcm2837",
            "text": "This is the Broadcom chip used in the Raspberry Pi 3, and in later models of the Raspberry Pi 2. The underlying architecture of the BCM2837 is identical to the BCM2836. The only significant difference is the replacement of the ARMv7 quad core cluster with a quad-core ARM Cortex A53 (ARMv8) cluster.  The ARM cores run at 1.2GHz, making the device about 50% faster than the Raspberry Pi 2. The VideoCore IV runs at 400MHz.  Also see the Raspberry Pi 2's chip  BCM2836  and the Raspberry Pi 1's chip  BCM2835 .",
            "title": "BCM2837"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/README/index.html",
            "text": "Raspberry Pi boot modes\n\n\nIntroduction\n\n\nThe Raspberry Pi has a number of different stages of booting. This document is meant to help explain how the boot modes work, and which ones are supported for Linux booting.\n\n\n\n\nBootflow\n: Boot sequence description\n\n\nSD card\n: SD card boot description\n\n\nUSB\n: USB boot description\n\n\nDevice boot\n: Booting as a mass storage device\n\n\nHost boot\n: Booting as a USB host\n\n\nMass storage boot\n: Boot from Mass Storage Device (MSD)\n\n\nNetwork boot\n: Boot from ethernet\n\n\n\n\n\n\n\n\nSpecial bootcode.bin-only boot mode\n\n\nFor the original Raspberry Pi and the Raspberry Pi 2 (based on the BCM2835 and BCM2836 devices), and in situations where the Pi 3 fails to boot, there is a new method of booting from one of the new boot modes (MSD or ethernet).\n\n\nJust format an SD card as FAT32 and copy on the latest \nbootcode.bin\n. \n\n\nThis will then enable the new bootmodes with some bug fixes for the failing Pi 3 cases.\n\n\nIf you have a problem with a mass storage device still not working even with this bootcode.bin, then please add a new file 'timeout' to the SD card. This should extend the time it waits for the mass storage device to initialise to six seconds.",
            "title": "Raspberry Pi boot modes"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/README/index.html#raspberry-pi-boot-modes",
            "text": "",
            "title": "Raspberry Pi boot modes"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/README/index.html#introduction",
            "text": "The Raspberry Pi has a number of different stages of booting. This document is meant to help explain how the boot modes work, and which ones are supported for Linux booting.   Bootflow : Boot sequence description  SD card : SD card boot description  USB : USB boot description  Device boot : Booting as a mass storage device  Host boot : Booting as a USB host  Mass storage boot : Boot from Mass Storage Device (MSD)  Network boot : Boot from ethernet",
            "title": "Introduction"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/README/index.html#special-bootcodebin-only-boot-mode",
            "text": "For the original Raspberry Pi and the Raspberry Pi 2 (based on the BCM2835 and BCM2836 devices), and in situations where the Pi 3 fails to boot, there is a new method of booting from one of the new boot modes (MSD or ethernet).  Just format an SD card as FAT32 and copy on the latest  bootcode.bin .   This will then enable the new bootmodes with some bug fixes for the failing Pi 3 cases.  If you have a problem with a mass storage device still not working even with this bootcode.bin, then please add a new file 'timeout' to the SD card. This should extend the time it waits for the mass storage device to initialise to six seconds.",
            "title": "Special bootcode.bin-only boot mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/bootflow/index.html",
            "text": "Boot flow\n\n\nThe flow of boot begins with reading the OTP to decide on the valid boot modes enabled. By default, this is SD card boot followed by USB device boot. Subsequently, the boot ROM checks to see if the GPIO boot mode OTP bits have been programmed \u2014 one to enable GPIO boot mode and one to select the bank of GPIOs it uses to disable boot modes (low = GPIOs 22-26, high = GPIOs 39-43). This makes it possible to use a hardware switch to choose between different boot modes if there is more than one available.\n\n\nThe GPIO boot mode OTP bits can be programmed by adding \nprogram_gpio_bootmode=n\n to \nconfig.txt\n, where n is \n1\n to select the low bank (22-26) or \n2\n to select the high bank (39-43). Once added, boot the device, then power-cycle it (rebooting is not sufficient). You should expect it to no longer boot (all boot modes will be disabled by default). Apply a pull-up to the required pin to enable the required boot mode. After programming, the \nconfig.txt\n setting can be removed.\n\n\nN.B.:\n1. It is important to remember that, \nonce set, OTP bits can never be unset\n, so think carefully before enabling this facility because it effectively makes 5 GPIOs unusable for other purposes. Also note that the bit assignments make it possible to switch from the low bank (22-26) to the high bank (39-43), \nbut not back again\n, and that selecting the high bank is likely to produce a non-bootable Pi, unless you're using a Compute Module (any version).\n2. \nDo not use \nprogram_gpio_bootmode\n unless your firmware is dated 20 Oct 2017 or later (\nvcgencmd version\n). Doing so will make it impossible to select the low bank of boot mode GPIOs.\n\n\nNext the boot ROM checks each of the boot sources for a file called bootcode.bin; if it is successful it will load the code into the local 128K cache and jump to it. The overall boot mode process is as follows:\n\n\n\n\n2837 boots\n\n\nReads boot ROM enabled boot modes from OTP\n\n\nUses program_gpio_bootmode to disable some modes by reading GPIOs 22-26 or 39-43 to see if the default values do not equal the default pull to '0'. If it is low, it will disable that boot mode for each of SD1, SD2, NAND, SPI, USB. If the value read is a '1', then that boot mode is enabled (note this cannot enable boot modes that have not already been enabled in the OTP). The default pull resistance is around 50K ohm, so a smaller pull up of 5K should suffice to enable the boot mode but still allow the GPIO to be operational without consuming too much power.\n\n\nIf enabled: check primary SD for bootcode.bin on GPIO 48-53\n\n\nSuccess - Boot\n\n\nFail - timeout (five seconds)\n\n\nIf enabled: check secondary SD\n\n\nSuccess - Boot\n\n\nFail - timeout (five seconds)\n\n\nIf enabled: check NAND\n\n\nIf enabled: check SPI\n\n\nIf enabled: check USB\n\n\nIf OTG pin == 0 \n\n\nEnable USB, wait for valid USB 2.0 devices (two seconds)\n\n\nDevice found:\n\n\nIf device type == hub\n\n\nRecurse for each port\n\n\nIf device type == (mass storage or LAN951x)\n\n\nStore in list of devices\n\n\n\n\n\n\nRecurse through each MSD\n\n\nIf bootcode.bin found boot\n\n\nRecurse through each LAN951x\n\n\nDHCP / TFTP boot\n\n\n\n\n\n\nelse (Device mode boot)\n\n\nEnable device mode and wait for host PC to enumerate\n\n\nWe reply to PC with VID: 0a5c PID: 0x2763 (Pi 1 or Pi 2) or 0x2764 (Pi 3)\n\n\n\n\n\n\n\n\nNOTES: \n\n\n\n\nIf there is no SD card inserted, the SD boot mode takes five seconds to fail. To reduce this and fall back to USB more quickly, you can either insert an SD card with nothing on it or use the GPIO bootmode OTP setting described above to only enable USB.\n\n\nThe default pull for the GPIOs is defined on page 102 of the \nARM Peripherals datasheet\n. If the value at boot time does not equal the default pull, then that boot mode is enabled.\n\n\nUSB enumeration is a means of enabling power to the downstream devices on a hub, then waiting for the device to pull the D+ and D- lines to indicate if it is either USB 1 or USB 2. This can take time: on some devices it can take up to three seconds for a hard disk drive to spin up and start the enumeration process. Because this is the only way of detecting that the hardware is attached, we have to wait for a minimum amount of time (two seconds). If the device fails to respond after this maximum timeout, it is possible to increase the timeout to five seconds using \nprogram_usb_timeout=1\n in \nconfig.txt\n.\n\n\nMSD takes precedence over Ethernet boot.\n\n\nIt is no longer necessary for the first partition to be the FAT partition, as the MSD boot will continue to search for a FAT partition beyond the first one.\n\n\nThe boot ROM also now supports GUID partitioning and has been tested with hard drives partitioned using Mac, Windows, and Linux.\n\n\nThe LAN951x is detected using the Vendor ID 0x0424 and Product ID 0xec00, this is different to the standalone LAN9500 device which has a product ID of 0x9500 or 0x9e00.  To use the standalone LAN9500 an I2C EEPROM would need to be added to change these ID's to match the LAN9514\n\n\n\n\nThe primary SD card boot mode is, as standard, set to be GPIOs 49-53. It is possible to boot from the secondary SD card on a second set of pins, i.e. to add a secondary SD card to the GPIO pins. However, we have not yet enabled this ability.\n\n\nNAND boot and SPI boot modes do work, although they do not yet have full GPU support.\n\n\nThe USB device boot mode is enabled by default at the time of manufacture, but the USB host boot mode is only enabled with \nprogram_usb_boot_mode=1\n. Once enabled, the processor will use the value of the OTGID pin on the processor to decide between the two modes. On a Raspberry Pi Model B, the OTGID pin is driven to '0' and therefore will only boot via host mode once enabled (it is not possible to boot through device mode because the LAN9515 device is in the way).\n\n\nThe USB will boot as a USB device on the Pi Zero or Compute Module if the OTGID pin is left floating (when plugged into a PC for example), so you can 'squirt' the bootcode.bin into the device. The code for doing this is \nusbboot\n.",
            "title": "Boot flow"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/bootflow/index.html#boot-flow",
            "text": "The flow of boot begins with reading the OTP to decide on the valid boot modes enabled. By default, this is SD card boot followed by USB device boot. Subsequently, the boot ROM checks to see if the GPIO boot mode OTP bits have been programmed \u2014 one to enable GPIO boot mode and one to select the bank of GPIOs it uses to disable boot modes (low = GPIOs 22-26, high = GPIOs 39-43). This makes it possible to use a hardware switch to choose between different boot modes if there is more than one available.  The GPIO boot mode OTP bits can be programmed by adding  program_gpio_bootmode=n  to  config.txt , where n is  1  to select the low bank (22-26) or  2  to select the high bank (39-43). Once added, boot the device, then power-cycle it (rebooting is not sufficient). You should expect it to no longer boot (all boot modes will be disabled by default). Apply a pull-up to the required pin to enable the required boot mode. After programming, the  config.txt  setting can be removed.  N.B.:\n1. It is important to remember that,  once set, OTP bits can never be unset , so think carefully before enabling this facility because it effectively makes 5 GPIOs unusable for other purposes. Also note that the bit assignments make it possible to switch from the low bank (22-26) to the high bank (39-43),  but not back again , and that selecting the high bank is likely to produce a non-bootable Pi, unless you're using a Compute Module (any version).\n2.  Do not use  program_gpio_bootmode  unless your firmware is dated 20 Oct 2017 or later ( vcgencmd version ). Doing so will make it impossible to select the low bank of boot mode GPIOs.  Next the boot ROM checks each of the boot sources for a file called bootcode.bin; if it is successful it will load the code into the local 128K cache and jump to it. The overall boot mode process is as follows:   2837 boots  Reads boot ROM enabled boot modes from OTP  Uses program_gpio_bootmode to disable some modes by reading GPIOs 22-26 or 39-43 to see if the default values do not equal the default pull to '0'. If it is low, it will disable that boot mode for each of SD1, SD2, NAND, SPI, USB. If the value read is a '1', then that boot mode is enabled (note this cannot enable boot modes that have not already been enabled in the OTP). The default pull resistance is around 50K ohm, so a smaller pull up of 5K should suffice to enable the boot mode but still allow the GPIO to be operational without consuming too much power.  If enabled: check primary SD for bootcode.bin on GPIO 48-53  Success - Boot  Fail - timeout (five seconds)  If enabled: check secondary SD  Success - Boot  Fail - timeout (five seconds)  If enabled: check NAND  If enabled: check SPI  If enabled: check USB  If OTG pin == 0   Enable USB, wait for valid USB 2.0 devices (two seconds)  Device found:  If device type == hub  Recurse for each port  If device type == (mass storage or LAN951x)  Store in list of devices    Recurse through each MSD  If bootcode.bin found boot  Recurse through each LAN951x  DHCP / TFTP boot    else (Device mode boot)  Enable device mode and wait for host PC to enumerate  We reply to PC with VID: 0a5c PID: 0x2763 (Pi 1 or Pi 2) or 0x2764 (Pi 3)     NOTES:    If there is no SD card inserted, the SD boot mode takes five seconds to fail. To reduce this and fall back to USB more quickly, you can either insert an SD card with nothing on it or use the GPIO bootmode OTP setting described above to only enable USB.  The default pull for the GPIOs is defined on page 102 of the  ARM Peripherals datasheet . If the value at boot time does not equal the default pull, then that boot mode is enabled.  USB enumeration is a means of enabling power to the downstream devices on a hub, then waiting for the device to pull the D+ and D- lines to indicate if it is either USB 1 or USB 2. This can take time: on some devices it can take up to three seconds for a hard disk drive to spin up and start the enumeration process. Because this is the only way of detecting that the hardware is attached, we have to wait for a minimum amount of time (two seconds). If the device fails to respond after this maximum timeout, it is possible to increase the timeout to five seconds using  program_usb_timeout=1  in  config.txt .  MSD takes precedence over Ethernet boot.  It is no longer necessary for the first partition to be the FAT partition, as the MSD boot will continue to search for a FAT partition beyond the first one.  The boot ROM also now supports GUID partitioning and has been tested with hard drives partitioned using Mac, Windows, and Linux.  The LAN951x is detected using the Vendor ID 0x0424 and Product ID 0xec00, this is different to the standalone LAN9500 device which has a product ID of 0x9500 or 0x9e00.  To use the standalone LAN9500 an I2C EEPROM would need to be added to change these ID's to match the LAN9514   The primary SD card boot mode is, as standard, set to be GPIOs 49-53. It is possible to boot from the secondary SD card on a second set of pins, i.e. to add a secondary SD card to the GPIO pins. However, we have not yet enabled this ability.  NAND boot and SPI boot modes do work, although they do not yet have full GPU support.  The USB device boot mode is enabled by default at the time of manufacture, but the USB host boot mode is only enabled with  program_usb_boot_mode=1 . Once enabled, the processor will use the value of the OTGID pin on the processor to decide between the two modes. On a Raspberry Pi Model B, the OTGID pin is driven to '0' and therefore will only boot via host mode once enabled (it is not possible to boot through device mode because the LAN9515 device is in the way).  The USB will boot as a USB device on the Pi Zero or Compute Module if the OTGID pin is left floating (when plugged into a PC for example), so you can 'squirt' the bootcode.bin into the device. The code for doing this is  usbboot .",
            "title": "Boot flow"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/device/index.html",
            "text": "Device boot\n\n\nThe following devices can boot through the special device boot mode:\n\n\n\n\nPi CM\n\n\nPi CM3\n\n\nPi Zero\n\n\nPi Zero W\n\n\n\n\nWhen this boot mode is activated (usually after a failure to boot from the SD card), it switches to a USB device and awaits a USB reset from the host. Example code showing how the host needs to talk to the Pi can be found \nhere\n.\n\n\nThe host first sends a structure to the device down control endpoint 0. This contains the size and signature for the boot (security is not enabled so no signature is required). Secondly, code is transmitted down endpoint 1 (bootcode.bin).  Finally, the device will reply with a success code of:\n\n\n\n\n0    - Success\n\n\n0x80 - Failed",
            "title": "Device boot"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/device/index.html#device-boot",
            "text": "The following devices can boot through the special device boot mode:   Pi CM  Pi CM3  Pi Zero  Pi Zero W   When this boot mode is activated (usually after a failure to boot from the SD card), it switches to a USB device and awaits a USB reset from the host. Example code showing how the host needs to talk to the Pi can be found  here .  The host first sends a structure to the device down control endpoint 0. This contains the size and signature for the boot (security is not enabled so no signature is required). Secondly, code is transmitted down endpoint 1 (bootcode.bin).  Finally, the device will reply with a success code of:   0    - Success  0x80 - Failed",
            "title": "Device boot"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/host/index.html",
            "text": "USB Host boot mode\n\n\nThe USB host boot mode follows this sequence:\n\n\n\n\nEnable the USB port and wait for D+ line to be pulled high indicating a USB 2.0 device (we only support USB2.0)\n\n\nIf the device is a hub:\n\n\nEnable power to all downstream ports of the hub\n\n\nFor each port, loop for a maximum of two seconds (or five seconds if \nprogram_usb_timeout=1\n has been set)\n\n\nRelease from reset and wait for D+ to be driven high to indicate that a device is connected\n\n\nIf a device is detected:\n\n\nSend \"Get Device Descriptor\"\n\n\nIf VID == SMSC && PID == 9500\n\n\nAdd device to Ethernet device list\n\n\nIf class interface == mass storage class\n\n\nAdd device to MSD device list\n\n\n\n\n\n\n\n\n\n\nElse\n\n\nEnumerate single device\n\n\nGo through MSD device list\n\n\nBoot from MSD\n\n\nGo through Ethernet device list\n\n\nBoot from Ethernet",
            "title": "USB Host boot mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/host/index.html#usb-host-boot-mode",
            "text": "The USB host boot mode follows this sequence:   Enable the USB port and wait for D+ line to be pulled high indicating a USB 2.0 device (we only support USB2.0)  If the device is a hub:  Enable power to all downstream ports of the hub  For each port, loop for a maximum of two seconds (or five seconds if  program_usb_timeout=1  has been set)  Release from reset and wait for D+ to be driven high to indicate that a device is connected  If a device is detected:  Send \"Get Device Descriptor\"  If VID == SMSC && PID == 9500  Add device to Ethernet device list  If class interface == mass storage class  Add device to MSD device list      Else  Enumerate single device  Go through MSD device list  Boot from MSD  Go through Ethernet device list  Boot from Ethernet",
            "title": "USB Host boot mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/msd/index.html",
            "text": "How to boot from a USB Mass Storage Device on a Raspberry Pi 3\n\n\nThis tutorial explains how to boot your Raspberry Pi 3 from a USB mass storage device such as a flash drive or USB hard disk. Be warned that this feature is experimental and does not work with all USB mass storage devices. See \nthis blog post\n from Gordon Hollingworth for an explanation of why some USB mass storage devices don't work, as well as some background information.\n\n\nProgram USB Boot Mode\n\n\nBefore a Raspberry Pi 3 will boot from a mass storage device, it needs to be booted from an SD card with a config option to enable USB boot mode. This will set a bit in the OTP (One Time Programmable) memory in the Raspberry Pi SoC that will enable booting from a USB mass storage device. Once this bit has been set, the SD card is no longer required. Note that any change you make to the OTP is permanent and cannot be undone.\n\n\nYou can use any SD card running Raspbian or Raspbian Lite to program the OTP bit. If you don't have such an SD card then you can install Raspbian or Raspbian Lite in the normal way - see \ninstalling images\n.\n\n\nFirst, prepare the \n/boot\n directory with up to date boot files:\n\n\n$ sudo apt-get update \n&&\n sudo apt-get upgrade\n\n\n\n\n\nThe above step is not required if you use the 2017-04-10 release of Raspbian / Raspbian Lite or later.\n\n\nThen enable USB boot mode with this code:\n\n\necho\n \nprogram_usb_boot_mode\n=\n1\n \n|\n sudo tee -a /boot/config.txt\n\n\n\n\n\nThis adds \nprogram_usb_boot_mode=1\n to the end of \n/boot/config.txt\n. Reboot the Raspberry Pi with \nsudo reboot\n, then check that the OTP has been programmed with:\n\n\n$ vcgencmd otp_dump \n|\n grep \n17\n:\n\n17\n:3020000a\n\n\n\n\n\nEnsure the output \n0x3020000a\n is shown. If it is not, then the OTP bit has not been successfully programmed.\n\n\nIf you wish, you can remove the \nprogram_usb_boot_mode\n line from config.txt, so that if you put the SD card in another Raspberry Pi, it won't program USB boot mode. Make sure there is no blank line at the end of config.txt. You can edit config.txt using the nano editor using the command \nsudo nano /boot/config.txt\n, for example.\n\n\nPrepare the USB mass storage device\n\n\nStarting with the 2017-04-10 release of Raspbian you can install a working Raspbian system to a USB mass storage device by copying the operating system image directly onto your USB device, in the same way that you would for an SD card. To perform this step, follow the instructions \nhere\n, remembering to select the drive that corresponds to your USB mass storage device.\n\n\nOnce you have finished imaging your USB mass storage device, remove it from your computer and insert it into your Raspberry Pi 3.\n\n\nBoot your Raspberry Pi 3 from the USB mass storage device\n\n\nAttach the USB mass storage device to your Raspberry Pi 3 and power it up. After between five and ten seconds the Raspberry Pi 3 should begin booting, and display the rainbow splash screen on an attached screen.",
            "title": "How to boot from a USB Mass Storage Device on a Raspberry Pi 3"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/msd/index.html#how-to-boot-from-a-usb-mass-storage-device-on-a-raspberry-pi-3",
            "text": "This tutorial explains how to boot your Raspberry Pi 3 from a USB mass storage device such as a flash drive or USB hard disk. Be warned that this feature is experimental and does not work with all USB mass storage devices. See  this blog post  from Gordon Hollingworth for an explanation of why some USB mass storage devices don't work, as well as some background information.",
            "title": "How to boot from a USB Mass Storage Device on a Raspberry Pi 3"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/msd/index.html#program-usb-boot-mode",
            "text": "Before a Raspberry Pi 3 will boot from a mass storage device, it needs to be booted from an SD card with a config option to enable USB boot mode. This will set a bit in the OTP (One Time Programmable) memory in the Raspberry Pi SoC that will enable booting from a USB mass storage device. Once this bit has been set, the SD card is no longer required. Note that any change you make to the OTP is permanent and cannot be undone.  You can use any SD card running Raspbian or Raspbian Lite to program the OTP bit. If you don't have such an SD card then you can install Raspbian or Raspbian Lite in the normal way - see  installing images .  First, prepare the  /boot  directory with up to date boot files:  $ sudo apt-get update  &&  sudo apt-get upgrade  The above step is not required if you use the 2017-04-10 release of Raspbian / Raspbian Lite or later.  Then enable USB boot mode with this code:  echo   program_usb_boot_mode = 1   |  sudo tee -a /boot/config.txt  This adds  program_usb_boot_mode=1  to the end of  /boot/config.txt . Reboot the Raspberry Pi with  sudo reboot , then check that the OTP has been programmed with:  $ vcgencmd otp_dump  |  grep  17 : 17 :3020000a  Ensure the output  0x3020000a  is shown. If it is not, then the OTP bit has not been successfully programmed.  If you wish, you can remove the  program_usb_boot_mode  line from config.txt, so that if you put the SD card in another Raspberry Pi, it won't program USB boot mode. Make sure there is no blank line at the end of config.txt. You can edit config.txt using the nano editor using the command  sudo nano /boot/config.txt , for example.",
            "title": "Program USB Boot Mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/msd/index.html#prepare-the-usb-mass-storage-device",
            "text": "Starting with the 2017-04-10 release of Raspbian you can install a working Raspbian system to a USB mass storage device by copying the operating system image directly onto your USB device, in the same way that you would for an SD card. To perform this step, follow the instructions  here , remembering to select the drive that corresponds to your USB mass storage device.  Once you have finished imaging your USB mass storage device, remove it from your computer and insert it into your Raspberry Pi 3.",
            "title": "Prepare the USB mass storage device"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/msd/index.html#boot-your-raspberry-pi-3-from-the-usb-mass-storage-device",
            "text": "Attach the USB mass storage device to your Raspberry Pi 3 and power it up. After between five and ten seconds the Raspberry Pi 3 should begin booting, and display the rainbow splash screen on an attached screen.",
            "title": "Boot your Raspberry Pi 3 from the USB mass storage device"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net/index.html",
            "text": "Network booting\n\n\nThis section describes how network booting works. There is also a \ntutorial\n available on setting up a working bootable system. Network booting works only for the wired adapter. Booting over wireless LAN is not supported.\n\n\nTo network boot, the boot ROM does the following:\n\n\n\n\nInitialise LAN9500\n\n\nSend DHCP request\n\n\nReceive DHCP reply\n\n\n(optional) Receive DHCP proxy reply\n\n\nARP to tftpboot server\n\n\nARP reply includes tftpboot server ethernet address\n\n\nTFTP RRQ 'bootcode.bin'\n\n\nFile not found: Server replies with TFTP error response with textual error message\n\n\nFile exists: Server will reply with the first block (512 bytes) of data for the file with a block number in the header\n\n\nPi replies with TFTP ACK packet containing the block number, and repeats until the last block which is not 512 bytes\n\n\n\n\n\n\nTFTP RRQ 'bootsig.bin'\n\n\nThis will normally result in an error \nfile not found\n. This is to be expected, and TFTP boot servers should be able to handle it.\n\n\n\n\nFrom this point the \nbootcode.bin\n code continues to load the system. The first file it will try to access is [\nserial_number\n]/start.elf. If this does not result in a error then any other files to be read will be pre-pended with the \nserial_number\n. This is useful because it enables you to create separate directories with separate start.elf / kernels for your Pis\nTo get the serial number for the device you can either try this boot mode and see what file is accessed using tcpdump / wireshark, or you can run a standard Raspbian SD card and \ncat /proc/cpuinfo\n.\n\n\nIf you put all your files into the root of your tftp directory then all following files will be accessed from there.\n\n\nDebugging the NFS boot mode\n\n\nThe first thing to check is that the OTP bit is correctly programmed. To do this, you need to add \nprogram_usb_boot_mode=1\n to config.txt and reboot (with a standard SD card that boots correctly into Raspbian). Once you've done this, you should be able to do:\n\n\n$ vcgencmd otp_dump \n|\n grep \n17\n:\n\n17\n:3020000a\n\n\n\n\n\nIf row 17 contains that value then the OTP is correctly programmed. You should now be able to remove the SD card, plug in Ethernet,\nand then the Ethernet LEDs should light up around 5 seconds after the Pi powers up.\n\n\nTo capture the ethernet packets on the server, use tcpdump on the tftpboot server (or DHCP server if they are different). You will need to capture the packets there otherwise you will not be able to see packets that get sent directly because network switches are not hubs!\n\n\nsudo tcpdump -i eth0 -w dump.pcap\n\n\n\n\n\nThis will write everything from eth0 to a file dump.pcap you can then post process it or upload it to cloudshark.com for communication\n\n\nDHCP Request / Reply\n\n\nAs a minimum you should see a DHCP request and reply which looks like the following:\n\n\n6\n:\n44\n:\n38.717115\n \nIP\n \n(\ntos\n \n0x0\n,\n \nttl\n \n128\n,\n \nid\n \n0\n,\n \noffset\n \n0\n,\n \nflags\n \n[\nnone\n],\n \nproto\n \nUDP\n \n(\n17\n),\n \nlength\n \n348\n)\n\n    \n0.0.0.0.68\n \n>\n \n255.255.255.255.67\n:\n \n[\nno\n \ncksum\n]\n \nBOOTP\n/\nDHCP\n,\n \nRequest\n \nfrom\n \nb8\n:\n27\n:\neb\n:\n28\n:\nf6\n:\n6\nd\n,\n \nlength\n \n320\n,\n \nxid\n \n0x26f30339\n,\n \nFlags\n \n[\nnone\n]\n \n(\n0x0000\n)\n\n      \nClient\n-\nEthernet\n-\nAddress\n \nb8\n:\n27\n:\neb\n:\n28\n:\nf6\n:\n6\nd\n\n      \nVendor\n-\nrfc1048\n \nExtensions\n\n        \nMagic\n \nCookie\n \n0x63825363\n\n        \nDHCP\n-\nMessage\n \nOption\n \n53\n,\n \nlength\n \n1\n:\n \nDiscover\n\n        \nParameter\n-\nRequest\n \nOption\n \n55\n,\n \nlength\n \n12\n:\n \n          \nVendor\n-\nOption\n,\n \nVendor\n-\nClass\n,\n \nBF\n,\n \nOption\n \n128\n\n          \nOption\n \n129\n,\n \nOption\n \n130\n,\n \nOption\n \n131\n,\n \nOption\n \n132\n\n          \nOption\n \n133\n,\n \nOption\n \n134\n,\n \nOption\n \n135\n,\n \nTFTP\n\n        \nARCH\n \nOption\n \n93\n,\n \nlength\n \n2\n:\n \n0\n\n        \nNDI\n \nOption\n \n94\n,\n \nlength\n \n3\n:\n \n1.2.1\n\n        \nGUID\n \nOption\n \n97\n,\n \nlength\n \n17\n:\n \n0.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68\n\n        \nVendor\n-\nClass\n \nOption\n \n60\n,\n \nlength\n \n32\n:\n \n\"PXEClient:Arch:00000:UNDI:002001\"\n\n        \nEND\n \nOption\n \n255\n,\n \nlength\n \n0\n\n\n16\n:\n44\n:\n41.224619\n \nIP\n \n(\ntos\n \n0x0\n,\n \nttl\n \n64\n,\n \nid\n \n57713\n,\n \noffset\n \n0\n,\n \nflags\n \n[\nnone\n],\n \nproto\n \nUDP\n \n(\n17\n),\n \nlength\n \n372\n)\n\n    \n192.168.1.1.67\n \n>\n \n192.168.1.139.68\n:\n \n[\nudp\n \nsum\n \nok\n]\n \nBOOTP\n/\nDHCP\n,\n \nReply\n,\n \nlength\n \n344\n,\n \nxid\n \n0x26f30339\n,\n \nFlags\n \n[\nnone\n]\n \n(\n0x0000\n)\n\n      \nYour\n-\nIP\n \n192.168.1.139\n\n      \nServer\n-\nIP\n \n192.168.1.1\n\n      \nClient\n-\nEthernet\n-\nAddress\n \nb8\n:\n27\n:\neb\n:\n28\n:\nf6\n:\n6\nd\n\n      \nVendor\n-\nrfc1048\n \nExtensions\n\n        \nMagic\n \nCookie\n \n0x63825363\n\n        \nDHCP\n-\nMessage\n \nOption\n \n53\n,\n \nlength\n \n1\n:\n \nOffer\n\n        \nServer\n-\nID\n \nOption\n \n54\n,\n \nlength\n \n4\n:\n \n192.168.1.1\n\n        \nLease\n-\nTime\n \nOption\n \n51\n,\n \nlength\n \n4\n:\n \n43200\n\n        \nRN\n \nOption\n \n58\n,\n \nlength\n \n4\n:\n \n21600\n\n        \nRB\n \nOption\n \n59\n,\n \nlength\n \n4\n:\n \n37800\n\n        \nSubnet\n-\nMask\n \nOption\n \n1\n,\n \nlength\n \n4\n:\n \n255.255.255.0\n\n        \nBR\n \nOption\n \n28\n,\n \nlength\n \n4\n:\n \n192.168.1.255\n\n        \nVendor\n-\nClass\n \nOption\n \n60\n,\n \nlength\n \n9\n:\n \n\"PXEClient\"\n\n        \nGUID\n \nOption\n \n97\n,\n \nlength\n \n17\n:\n \n0.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68\n\n        \nVendor\n-\nOption\n \nOption\n \n43\n,\n \nlength\n \n32\n:\n \n6.1.3.10.4.0.80.88.69.9.20.0.0.17.82.97.115.112.98.101.114.114.121.32.80.105.32.66.111.111.116.255\n\n        \nEND\n \nOption\n \n255\n,\n \nlength\n \n0\n\n\n\n\n\n\nThe important part of the reply is the Vendor-Option Option 43. This needs to contain the string \"Raspberry Pi Boot\", although, due\nto a bug in the boot ROM, you may need to add three spaces to the end of the string.\n\n\nTFTP file read\n\n\nYou will know whether the Vendor Option is correctly specified: if it is, you'll see a subsequent TFTP RRQ packet being sent. RRQs can be replied to by either the first block of data or an error saying file not found. In a couple of cases they even receive the first packet and then the transmission is aborted by the Pi (this happens when checking whether a file exists). The example below is just three packets: the original read request, the first data block (which is always 516 bytes containing a header and 512 bytes of data, although the last block is always less than 512 bytes and may be zero length), and the third packet (the ACK which contains a frame number to match the frame number in the data block).\n\n\n16\n:\n44\n:\n41.224964\n \nIP\n \n(\ntos\n \n0x0\n,\n \nttl\n \n128\n,\n \nid\n \n0\n,\n \noffset\n \n0\n,\n \nflags\n \n[\nnone\n],\n \nproto\n \nUDP\n \n(\n17\n),\n \nlength\n \n49\n)\n\n    \n192.168.1.139.49152\n \n>\n \n192.168.1.1.69\n:\n \n[\nno\n \ncksum\n]\n  \n21\n \nRRQ\n \n\"bootcode.bin\"\n \noctet\n \n\n16\n:\n44\n:\n41.227223\n \nIP\n \n(\ntos\n \n0x0\n,\n \nttl\n \n64\n,\n \nid\n \n57714\n,\n \noffset\n \n0\n,\n \nflags\n \n[\nnone\n],\n \nproto\n \nUDP\n \n(\n17\n),\n \nlength\n \n544\n)\n\n    \n192.168.1.1.55985\n \n>\n \n192.168.1.139.49152\n:\n \n[\nudp\n \nsum\n \nok\n]\n \nUDP\n,\n \nlength\n \n516\n\n\n16\n:\n44\n:\n41.227418\n \nIP\n \n(\ntos\n \n0x0\n,\n \nttl\n \n128\n,\n \nid\n \n0\n,\n \noffset\n \n0\n,\n \nflags\n \n[\nnone\n],\n \nproto\n \nUDP\n \n(\n17\n),\n \nlength\n \n32\n)\n\n    \n192.168.1.139.49152\n \n>\n \n192.168.1.1.55985\n:\n \n[\nno\n \ncksum\n]\n \nUDP\n,\n \nlength\n \n4\n\n\n\n\n\n\nSee Also:\n* \nNetwork boot tutorial",
            "title": "Network booting"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net/index.html#network-booting",
            "text": "This section describes how network booting works. There is also a  tutorial  available on setting up a working bootable system. Network booting works only for the wired adapter. Booting over wireless LAN is not supported.  To network boot, the boot ROM does the following:   Initialise LAN9500  Send DHCP request  Receive DHCP reply  (optional) Receive DHCP proxy reply  ARP to tftpboot server  ARP reply includes tftpboot server ethernet address  TFTP RRQ 'bootcode.bin'  File not found: Server replies with TFTP error response with textual error message  File exists: Server will reply with the first block (512 bytes) of data for the file with a block number in the header  Pi replies with TFTP ACK packet containing the block number, and repeats until the last block which is not 512 bytes    TFTP RRQ 'bootsig.bin'  This will normally result in an error  file not found . This is to be expected, and TFTP boot servers should be able to handle it.   From this point the  bootcode.bin  code continues to load the system. The first file it will try to access is [ serial_number ]/start.elf. If this does not result in a error then any other files to be read will be pre-pended with the  serial_number . This is useful because it enables you to create separate directories with separate start.elf / kernels for your Pis\nTo get the serial number for the device you can either try this boot mode and see what file is accessed using tcpdump / wireshark, or you can run a standard Raspbian SD card and  cat /proc/cpuinfo .  If you put all your files into the root of your tftp directory then all following files will be accessed from there.",
            "title": "Network booting"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net/index.html#debugging-the-nfs-boot-mode",
            "text": "The first thing to check is that the OTP bit is correctly programmed. To do this, you need to add  program_usb_boot_mode=1  to config.txt and reboot (with a standard SD card that boots correctly into Raspbian). Once you've done this, you should be able to do:  $ vcgencmd otp_dump  |  grep  17 : 17 :3020000a  If row 17 contains that value then the OTP is correctly programmed. You should now be able to remove the SD card, plug in Ethernet,\nand then the Ethernet LEDs should light up around 5 seconds after the Pi powers up.  To capture the ethernet packets on the server, use tcpdump on the tftpboot server (or DHCP server if they are different). You will need to capture the packets there otherwise you will not be able to see packets that get sent directly because network switches are not hubs!  sudo tcpdump -i eth0 -w dump.pcap  This will write everything from eth0 to a file dump.pcap you can then post process it or upload it to cloudshark.com for communication",
            "title": "Debugging the NFS boot mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net/index.html#dhcp-request-reply",
            "text": "As a minimum you should see a DHCP request and reply which looks like the following:  6 : 44 : 38.717115   IP   ( tos   0x0 ,   ttl   128 ,   id   0 ,   offset   0 ,   flags   [ none ],   proto   UDP   ( 17 ),   length   348 ) \n     0.0.0.0.68   >   255.255.255.255.67 :   [ no   cksum ]   BOOTP / DHCP ,   Request   from   b8 : 27 : eb : 28 : f6 : 6 d ,   length   320 ,   xid   0x26f30339 ,   Flags   [ none ]   ( 0x0000 ) \n       Client - Ethernet - Address   b8 : 27 : eb : 28 : f6 : 6 d \n       Vendor - rfc1048   Extensions \n         Magic   Cookie   0x63825363 \n         DHCP - Message   Option   53 ,   length   1 :   Discover \n         Parameter - Request   Option   55 ,   length   12 :  \n           Vendor - Option ,   Vendor - Class ,   BF ,   Option   128 \n           Option   129 ,   Option   130 ,   Option   131 ,   Option   132 \n           Option   133 ,   Option   134 ,   Option   135 ,   TFTP \n         ARCH   Option   93 ,   length   2 :   0 \n         NDI   Option   94 ,   length   3 :   1.2.1 \n         GUID   Option   97 ,   length   17 :   0.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68 \n         Vendor - Class   Option   60 ,   length   32 :   \"PXEClient:Arch:00000:UNDI:002001\" \n         END   Option   255 ,   length   0  16 : 44 : 41.224619   IP   ( tos   0x0 ,   ttl   64 ,   id   57713 ,   offset   0 ,   flags   [ none ],   proto   UDP   ( 17 ),   length   372 ) \n     192.168.1.1.67   >   192.168.1.139.68 :   [ udp   sum   ok ]   BOOTP / DHCP ,   Reply ,   length   344 ,   xid   0x26f30339 ,   Flags   [ none ]   ( 0x0000 ) \n       Your - IP   192.168.1.139 \n       Server - IP   192.168.1.1 \n       Client - Ethernet - Address   b8 : 27 : eb : 28 : f6 : 6 d \n       Vendor - rfc1048   Extensions \n         Magic   Cookie   0x63825363 \n         DHCP - Message   Option   53 ,   length   1 :   Offer \n         Server - ID   Option   54 ,   length   4 :   192.168.1.1 \n         Lease - Time   Option   51 ,   length   4 :   43200 \n         RN   Option   58 ,   length   4 :   21600 \n         RB   Option   59 ,   length   4 :   37800 \n         Subnet - Mask   Option   1 ,   length   4 :   255.255.255.0 \n         BR   Option   28 ,   length   4 :   192.168.1.255 \n         Vendor - Class   Option   60 ,   length   9 :   \"PXEClient\" \n         GUID   Option   97 ,   length   17 :   0.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68.68 \n         Vendor - Option   Option   43 ,   length   32 :   6.1.3.10.4.0.80.88.69.9.20.0.0.17.82.97.115.112.98.101.114.114.121.32.80.105.32.66.111.111.116.255 \n         END   Option   255 ,   length   0   The important part of the reply is the Vendor-Option Option 43. This needs to contain the string \"Raspberry Pi Boot\", although, due\nto a bug in the boot ROM, you may need to add three spaces to the end of the string.",
            "title": "DHCP Request / Reply"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net/index.html#tftp-file-read",
            "text": "You will know whether the Vendor Option is correctly specified: if it is, you'll see a subsequent TFTP RRQ packet being sent. RRQs can be replied to by either the first block of data or an error saying file not found. In a couple of cases they even receive the first packet and then the transmission is aborted by the Pi (this happens when checking whether a file exists). The example below is just three packets: the original read request, the first data block (which is always 516 bytes containing a header and 512 bytes of data, although the last block is always less than 512 bytes and may be zero length), and the third packet (the ACK which contains a frame number to match the frame number in the data block).  16 : 44 : 41.224964   IP   ( tos   0x0 ,   ttl   128 ,   id   0 ,   offset   0 ,   flags   [ none ],   proto   UDP   ( 17 ),   length   49 ) \n     192.168.1.139.49152   >   192.168.1.1.69 :   [ no   cksum ]    21   RRQ   \"bootcode.bin\"   octet   16 : 44 : 41.227223   IP   ( tos   0x0 ,   ttl   64 ,   id   57714 ,   offset   0 ,   flags   [ none ],   proto   UDP   ( 17 ),   length   544 ) \n     192.168.1.1.55985   >   192.168.1.139.49152 :   [ udp   sum   ok ]   UDP ,   length   516  16 : 44 : 41.227418   IP   ( tos   0x0 ,   ttl   128 ,   id   0 ,   offset   0 ,   flags   [ none ],   proto   UDP   ( 17 ),   length   32 ) \n     192.168.1.139.49152   >   192.168.1.1.55985 :   [ no   cksum ]   UDP ,   length   4   See Also:\n*  Network boot tutorial",
            "title": "TFTP file read"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html",
            "text": "Network Boot Your Raspberry Pi\n\n\nThis tutorial is written to explain how to set up a simple DHCP/TFTP server which will allow you to boot a Raspberry Pi 3 from the network. The tutorial assumes that you have an existing home network, and that you want to use a Raspberry Pi for the \nserver\n. You will need a second Raspberry Pi 3 as a \nclient\n to be booted. Only one SD card is needed because the client will be booted from the server after the initial client configuration.\n\n\nClient configuration\n\n\nBefore a Raspberry Pi will network boot, it needs to be booted from an SD card with a config option to enable USB boot mode. This will set a bit in the OTP (One Time Programmable) memory in the Raspberry Pi SoC that enables network booting. Once this is done, the SD card is no longer required. \n\n\nInstall Raspbian Lite (or Raspbian with PIXEL) on the SD card in the normal way \nSee here\n. \n\n\nProgram USB Boot Mode\n\n\nFirst, prepare the \n/boot\n directory with the latest boot files:\n\n\nsudo apt-get update \n&&\n sudo apt-get upgrade\n\n\n\n\n\nNow, enable USB boot mode with the following command:\n\n\necho\n \nprogram_usb_boot_mode\n=\n1\n \n|\n sudo tee -a /boot/config.txt\n\n\n\n\n\nThis adds \nprogram_usb_boot_mode=1\n to the end of \n/boot/config.txt\n. Reboot the Raspberry Pi with \nsudo reboot\n. Once the client Raspberry Pi has rebooted, check that the OTP has been programmed with:\n\n\n$ vcgencmd otp_dump \n|\n grep \n17\n:\n\n17\n:3020000a\n\n\n\n\n\nEnsure the output \n0x3020000a\n is correct.\n\n\nThe client configuration is almost done. The final thing to do is to remove the \nprogram_usb_boot_mode\n line from config.txt (make sure there is no blank line at the end). You can do this with \nsudo nano /boot/config.txt\n, for example. Finally, shut the client Raspberry Pi down with \nsudo poweroff\n.\n\n\nServer configuration\n\n\nPlug the SD card into the server Raspberry Pi. Boot the server. Before you do anything else, make sure you have run \nsudo raspi-config\n and expanded the root filesystem to take up the entire SD card.\n\n\nThe client Raspberry Pi will need a root filesystem to boot off, so before we do anything else on the server, we're going to make a full copy of its filesystem and put it in a directory called /nfs/client1.\n\n\nsudo mkdir -p /nfs/client1\nsudo apt-get install rsync\nsudo rsync -xa --progress --exclude /nfs / /nfs/client1\n\n\n\n\n\nRegenerate SSH host keys on the client filesystem by chrooting into it:\n\n\ncd\n /nfs/client1\nsudo mount --bind /dev dev\nsudo mount --bind /sys sys\nsudo mount --bind /proc proc\nsudo chroot .\nrm /etc/ssh/ssh_host_*\ndpkg-reconfigure openssh-server\n\nexit\n\nsudo umount dev\nsudo umount sys\nsudo umount proc\n\n\n\n\n\nFind the settings of your local network. You need to find the address of your router (or gateway), which can be done with:\n\n\nip route \n|\n grep default \n|\n awk \n'{print $3}'\n\n\n\n\n\n\nThen run:\n\n\nip -4 addr show dev eth0 \n|\n grep inet\n\n\n\n\n\nwhich should give an output like:\n\n\ninet 10.42.0.211/24 brd 10.42.0.255 scope global eth0\n\n\n\n\n\nThe first address is the IP address of your server Raspberry Pi on the network, and the part after the slash is the network size. It is highly likely that yours will be a \n/24\n. Also note the \nbrd\n (broadcast) address of the network. Note down the output of the previous command, which will contain the IP address of the Raspberry Pi and the broadcast address of the network.\n\n\nFinally, note down the address of your DNS server, which is the same address as your gateway. You can find this with:\n\n\ncat /etc/resolv.conf\n\n\n\n\n\nConfigure a static network address on your server Raspberry Pi by with \nsudo nano /etc/network/interfaces\n (where you replace nano with an editor of your choice). Change the line, \niface eth0 inet manual\n so that the address is the first address from the command before last, the netmask address as \n255.255.255.0\n and the gateway address as the number received from the last command. \n\n\nauto eth0\niface eth0 inet static \n        address 10.42.0.211\n        netmask 255.255.255.0\n        gateway 10.42.0.1\n\n\n\n\n\nDisable the DHCP client daemon and switch to standard Debian networking:\n\n\nsudo systemctl disable dhcpcd\nsudo systemctl \nenable\n networking\n\n\n\n\n\nReboot for the changes to take effect:\n\n\nsudo reboot\n\n\n\n\n\nAt this point, you won't have working DNS, so you'll need to add the server you noted down before to \n/etc/resolv.conf\n. Do this by using the following command, where the IP address is that of the gateway address you found before.\n\n\necho\n \n\"nameserver 10.42.0.1\"\n \n|\n sudo tee -a /etc/resolv.conf\n\n\n\n\n\nMake the file immutable (because otherwise dnsmasq will interfere) with the following command:\n\n\nsudo chattr +i /etc/resolv.conf\n\n\n\n\n\nInstall software we need:\n\n\nsudo apt-get update\nsudo apt-get install dnsmasq tcpdump\n\n\n\n\n\nStop dnsmasq breaking DNS resolving:\n\n\nsudo rm /etc/resolvconf/update.d/dnsmasq\nsudo reboot\n\n\n\n\n\nNow start tcpdump so you can search for DHCP packets from the client Raspberry Pi:\n\n\nsudo tcpdump -i eth0 port bootpc\n\n\n\n\n\nConnect the client Raspberry Pi to your network and power it on. Check that the LEDs illuminate on the client after around 10 seconds, then you should get a packet from the client \"DHCP/BOOTP, Request from ...\"\n\n\nIP 0.0.0.0.bootpc > 255.255.255.255.bootps: BOOTP/DHCP, Request from b8:27:eb...\n\n\n\n\n\nNow we need to modify the dnsmasq configuration to enable DHCP to reply to the device. Press \nCTRL+C\n on the keyboard to exit the tcpdump program, then type the following:\n\n\necho\n \n|\n sudo tee /etc/dnsmasq.conf\nsudo nano /etc/dnsmasq.conf\n\n\n\n\n\nThen replace the contents of dnsmasq.conf with:\n\n\nport=0\ndhcp-range=10.42.0.255,proxy\nlog-dhcp\nenable-tftp\ntftp-root=/tftpboot\npxe-service=0,\"Raspberry Pi Boot\"\n\n\n\n\n\nWhere the first address of the \ndhcp-range\n line is, use the broadcast address you noted down earlier.\n\n\nNow create a /tftpboot directory:\n\n\nsudo mkdir /tftpboot\nsudo chmod \n777\n /tftpboot\nsudo systemctl \nenable\n dnsmasq.service\nsudo systemctl restart dnsmasq.service\n\n\n\n\n\nNow monitor the dnsmasq log:\n\n\ntail -F /var/log/daemon.log\n\n\n\n\n\nYou should see something like this:\n\n\nraspberrypi dnsmasq-tftp[1903]: file /tftpboot/bootcode.bin not found\n\n\n\n\n\nNext, you will need to copy \nbootcode.bin\n and \nstart.elf\n into the /tftpboot directory. You should be able to do this by copying the files from /boot, since these are the right ones. We need a kernel, so we might as well copy the entire boot directory.\n\n\nFirst, use \nCtrl+C\n to exit the monitoring state. Then type the following: \n\n\ncp -r /boot/* /tftpboot\n\n\n\n\n\nRestart dnsmasq for good measure:\n\n\nsudo systemctl restart dnsmasq\n\n\n\n\n\nSet up NFS root\n\n\nThis should now allow your Raspberry Pi to boot through until it tries to load a root filesystem (which it doesn't have). All we have to do to get this working is to export the \n/nfs/client1\n filesystem we created earlier.\n\n\nsudo apt-get install nfs-kernel-server\n\necho\n \n\"/nfs/client1 *(rw,sync,no_subtree_check,no_root_squash)\"\n \n|\n sudo tee -a /etc/exports\nsudo systemctl \nenable\n rpcbind\nsudo systemctl restart rpcbind\nsudo systemctl \nenable\n nfs-kernel-server\nsudo systemctl restart nfs-kernel-server\n\n\n\n\n\nEdit /tftpboot/cmdline.txt and from \nroot=\n onwards, and replace it with:\n\n\nroot=/dev/nfs nfsroot=10.42.0.211:/nfs/client1,vers=3 rw ip=dhcp rootwait elevator=deadline\n\n\n\n\n\nYou should substitute the IP address here with the IP address you have noted down.\n\n\nFinally, edit /nfs/client1/etc/fstab and remove the /dev/mmcblkp1 and p2 lines (only proc should be left).\n\n\nGood luck! If it doesn't boot on the first attempt, keep trying. It can take a minute or so for the Raspberry Pi to boot, so be patient.",
            "title": "Network Boot Your Raspberry Pi"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html#network-boot-your-raspberry-pi",
            "text": "This tutorial is written to explain how to set up a simple DHCP/TFTP server which will allow you to boot a Raspberry Pi 3 from the network. The tutorial assumes that you have an existing home network, and that you want to use a Raspberry Pi for the  server . You will need a second Raspberry Pi 3 as a  client  to be booted. Only one SD card is needed because the client will be booted from the server after the initial client configuration.",
            "title": "Network Boot Your Raspberry Pi"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html#client-configuration",
            "text": "Before a Raspberry Pi will network boot, it needs to be booted from an SD card with a config option to enable USB boot mode. This will set a bit in the OTP (One Time Programmable) memory in the Raspberry Pi SoC that enables network booting. Once this is done, the SD card is no longer required.   Install Raspbian Lite (or Raspbian with PIXEL) on the SD card in the normal way  See here .",
            "title": "Client configuration"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html#program-usb-boot-mode",
            "text": "First, prepare the  /boot  directory with the latest boot files:  sudo apt-get update  &&  sudo apt-get upgrade  Now, enable USB boot mode with the following command:  echo   program_usb_boot_mode = 1   |  sudo tee -a /boot/config.txt  This adds  program_usb_boot_mode=1  to the end of  /boot/config.txt . Reboot the Raspberry Pi with  sudo reboot . Once the client Raspberry Pi has rebooted, check that the OTP has been programmed with:  $ vcgencmd otp_dump  |  grep  17 : 17 :3020000a  Ensure the output  0x3020000a  is correct.  The client configuration is almost done. The final thing to do is to remove the  program_usb_boot_mode  line from config.txt (make sure there is no blank line at the end). You can do this with  sudo nano /boot/config.txt , for example. Finally, shut the client Raspberry Pi down with  sudo poweroff .",
            "title": "Program USB Boot Mode"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html#server-configuration",
            "text": "Plug the SD card into the server Raspberry Pi. Boot the server. Before you do anything else, make sure you have run  sudo raspi-config  and expanded the root filesystem to take up the entire SD card.  The client Raspberry Pi will need a root filesystem to boot off, so before we do anything else on the server, we're going to make a full copy of its filesystem and put it in a directory called /nfs/client1.  sudo mkdir -p /nfs/client1\nsudo apt-get install rsync\nsudo rsync -xa --progress --exclude /nfs / /nfs/client1  Regenerate SSH host keys on the client filesystem by chrooting into it:  cd  /nfs/client1\nsudo mount --bind /dev dev\nsudo mount --bind /sys sys\nsudo mount --bind /proc proc\nsudo chroot .\nrm /etc/ssh/ssh_host_*\ndpkg-reconfigure openssh-server exit \nsudo umount dev\nsudo umount sys\nsudo umount proc  Find the settings of your local network. You need to find the address of your router (or gateway), which can be done with:  ip route  |  grep default  |  awk  '{print $3}'   Then run:  ip -4 addr show dev eth0  |  grep inet  which should give an output like:  inet 10.42.0.211/24 brd 10.42.0.255 scope global eth0  The first address is the IP address of your server Raspberry Pi on the network, and the part after the slash is the network size. It is highly likely that yours will be a  /24 . Also note the  brd  (broadcast) address of the network. Note down the output of the previous command, which will contain the IP address of the Raspberry Pi and the broadcast address of the network.  Finally, note down the address of your DNS server, which is the same address as your gateway. You can find this with:  cat /etc/resolv.conf  Configure a static network address on your server Raspberry Pi by with  sudo nano /etc/network/interfaces  (where you replace nano with an editor of your choice). Change the line,  iface eth0 inet manual  so that the address is the first address from the command before last, the netmask address as  255.255.255.0  and the gateway address as the number received from the last command.   auto eth0\niface eth0 inet static \n        address 10.42.0.211\n        netmask 255.255.255.0\n        gateway 10.42.0.1  Disable the DHCP client daemon and switch to standard Debian networking:  sudo systemctl disable dhcpcd\nsudo systemctl  enable  networking  Reboot for the changes to take effect:  sudo reboot  At this point, you won't have working DNS, so you'll need to add the server you noted down before to  /etc/resolv.conf . Do this by using the following command, where the IP address is that of the gateway address you found before.  echo   \"nameserver 10.42.0.1\"   |  sudo tee -a /etc/resolv.conf  Make the file immutable (because otherwise dnsmasq will interfere) with the following command:  sudo chattr +i /etc/resolv.conf  Install software we need:  sudo apt-get update\nsudo apt-get install dnsmasq tcpdump  Stop dnsmasq breaking DNS resolving:  sudo rm /etc/resolvconf/update.d/dnsmasq\nsudo reboot  Now start tcpdump so you can search for DHCP packets from the client Raspberry Pi:  sudo tcpdump -i eth0 port bootpc  Connect the client Raspberry Pi to your network and power it on. Check that the LEDs illuminate on the client after around 10 seconds, then you should get a packet from the client \"DHCP/BOOTP, Request from ...\"  IP 0.0.0.0.bootpc > 255.255.255.255.bootps: BOOTP/DHCP, Request from b8:27:eb...  Now we need to modify the dnsmasq configuration to enable DHCP to reply to the device. Press  CTRL+C  on the keyboard to exit the tcpdump program, then type the following:  echo   |  sudo tee /etc/dnsmasq.conf\nsudo nano /etc/dnsmasq.conf  Then replace the contents of dnsmasq.conf with:  port=0\ndhcp-range=10.42.0.255,proxy\nlog-dhcp\nenable-tftp\ntftp-root=/tftpboot\npxe-service=0,\"Raspberry Pi Boot\"  Where the first address of the  dhcp-range  line is, use the broadcast address you noted down earlier.  Now create a /tftpboot directory:  sudo mkdir /tftpboot\nsudo chmod  777  /tftpboot\nsudo systemctl  enable  dnsmasq.service\nsudo systemctl restart dnsmasq.service  Now monitor the dnsmasq log:  tail -F /var/log/daemon.log  You should see something like this:  raspberrypi dnsmasq-tftp[1903]: file /tftpboot/bootcode.bin not found  Next, you will need to copy  bootcode.bin  and  start.elf  into the /tftpboot directory. You should be able to do this by copying the files from /boot, since these are the right ones. We need a kernel, so we might as well copy the entire boot directory.  First, use  Ctrl+C  to exit the monitoring state. Then type the following:   cp -r /boot/* /tftpboot  Restart dnsmasq for good measure:  sudo systemctl restart dnsmasq",
            "title": "Server configuration"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial/index.html#set-up-nfs-root",
            "text": "This should now allow your Raspberry Pi to boot through until it tries to load a root filesystem (which it doesn't have). All we have to do to get this working is to export the  /nfs/client1  filesystem we created earlier.  sudo apt-get install nfs-kernel-server echo   \"/nfs/client1 *(rw,sync,no_subtree_check,no_root_squash)\"   |  sudo tee -a /etc/exports\nsudo systemctl  enable  rpcbind\nsudo systemctl restart rpcbind\nsudo systemctl  enable  nfs-kernel-server\nsudo systemctl restart nfs-kernel-server  Edit /tftpboot/cmdline.txt and from  root=  onwards, and replace it with:  root=/dev/nfs nfsroot=10.42.0.211:/nfs/client1,vers=3 rw ip=dhcp rootwait elevator=deadline  You should substitute the IP address here with the IP address you have noted down.  Finally, edit /nfs/client1/etc/fstab and remove the /dev/mmcblkp1 and p2 lines (only proc should be left).  Good luck! If it doesn't boot on the first attempt, keep trying. It can take a minute or so for the Raspberry Pi to boot, so be patient.",
            "title": "Set up NFS root"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html",
            "text": "Network boot using a Windows Server\n\n\nThis is a summary of the steps needed to set up a Windows Server to act as the DHCP/TFTP server \nso that a Raspberry Pi 3 can boot over the network.\n\n\nWe use the Windows DHCP services, Windows Deployment Services to act as a TFTP server and the Windows \nNFS services to supply the file system for the booted image. My particular server is a HP Proliant \nMicroserver running Windows 2008 R2.\n\n\nDisclaimer\n\n\nThese steps may omit detail as I was working this out as I went along and I don't have another Windows 2008 Server \nwith which to start again.  I'm also no networking or WDS expert so feel free to correct this.\n\n\nA lot of this document was written after the fact so there may be the odd step that I've missed out.  Hopefully it is enough to get an experienced Windows Administrator heading in the right direction.\n\n\nDHCP settings\n\n\nThis is an area that could be improved.  I have my Windows 2008 Server set up as DHCP server for my network, \nhowever for the Raspberry Pi to boot from the network it needs to receive a specific BOOTP option back from the DHCP Server.\nThis is '043 Vendor Specific Info'.  I used the DHCP MMC plugin to add the this option to my DHCP scope.  The data for this option I set to :\n\n\n2B 20 06 01 03 0A 04 00 50 58 45 14 00 00 11 52 61 73 70 62 65 72 72 79 20 50 69 20 42 6F 6F 74 FF\n\n\nI determined this string by running a trace of a successful boot when using a Pi as a DHCP server.  I've noticed that WireShark complains about \nthe structure of this option so I may have not get it set perfectly but it was enough for the Pi to recognise the DHCP server as one\nfrom which it could try to network boot.\n\n\nOne thing that troubled me is that this Vendor option will be sent to all of the DHCP clients and not just Pis.  I think that\nthis can be resolved by defining of Vendor Classes on the server and recognising the client as a Pi but I have not had time to fully explore this.\n\n\nWindows Deployment Service\n\n\nWindows Deployment Services is the server role that supports TFTP.  For Windows clients it support a rich set of functionality \nbut we only need its TFTP services.  You are may have to add the WDS role to your server.\n\n\nWDS creates a REMINST share where the TFTP files will be located.  I used Windows explore to navigate to \\servername\\REMINST\nand then copied on the boot directory (including sub-directories) for the Pi into that location (including the updated bootcode.bin and start.elf).\n\n\nAs with DHCP I'm not sure how adding the Pi contents to the WDS folders may impact normal Windows operation of WDS as\nI don't use that on my network.\n\n\nWindows NFS services\n\n\nThe steps above should allow the Pi to at least boot but won't have the rest of the file system.\nWe now need add the Services for NFS role to our server.  Once they are installed we can create NFS shares that the Pi can use.\n\n\nI created a folder to contain the Pi's file system and then right-click the folder and choose properties and go to the \n'NFS Sharing' tab and click on the button 'Manage NFS Sharing'.  I called the share 'PiRoot' and chose the 'No server authentication [Auth_Sys]', 'Enable unmapped user access', 'Allow unmapped User Unix access' options.\nI believe these allow user permissions and ownerships to work in the best way.\n\n\nI then booted up a normal Pi and copied the whole file system across to the newly created PiRoot share on the Windows server.\n\n\ncmdline.txt\n\n\nLastly I modified the cmdline.txt to point to the PiRoot NFS folder\n\n\nroot=/dev/nfs rootfstype=nfs nfsroot=192.168.10.200:/PiRoot/ rw ip=dhcp rootwait",
            "title": "Network boot using a Windows Server"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#network-boot-using-a-windows-server",
            "text": "This is a summary of the steps needed to set up a Windows Server to act as the DHCP/TFTP server \nso that a Raspberry Pi 3 can boot over the network.  We use the Windows DHCP services, Windows Deployment Services to act as a TFTP server and the Windows \nNFS services to supply the file system for the booted image. My particular server is a HP Proliant \nMicroserver running Windows 2008 R2.",
            "title": "Network boot using a Windows Server"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#disclaimer",
            "text": "These steps may omit detail as I was working this out as I went along and I don't have another Windows 2008 Server \nwith which to start again.  I'm also no networking or WDS expert so feel free to correct this.  A lot of this document was written after the fact so there may be the odd step that I've missed out.  Hopefully it is enough to get an experienced Windows Administrator heading in the right direction.",
            "title": "Disclaimer"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#dhcp-settings",
            "text": "This is an area that could be improved.  I have my Windows 2008 Server set up as DHCP server for my network, \nhowever for the Raspberry Pi to boot from the network it needs to receive a specific BOOTP option back from the DHCP Server.\nThis is '043 Vendor Specific Info'.  I used the DHCP MMC plugin to add the this option to my DHCP scope.  The data for this option I set to :  2B 20 06 01 03 0A 04 00 50 58 45 14 00 00 11 52 61 73 70 62 65 72 72 79 20 50 69 20 42 6F 6F 74 FF  I determined this string by running a trace of a successful boot when using a Pi as a DHCP server.  I've noticed that WireShark complains about \nthe structure of this option so I may have not get it set perfectly but it was enough for the Pi to recognise the DHCP server as one\nfrom which it could try to network boot.  One thing that troubled me is that this Vendor option will be sent to all of the DHCP clients and not just Pis.  I think that\nthis can be resolved by defining of Vendor Classes on the server and recognising the client as a Pi but I have not had time to fully explore this.",
            "title": "DHCP settings"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#windows-deployment-service",
            "text": "Windows Deployment Services is the server role that supports TFTP.  For Windows clients it support a rich set of functionality \nbut we only need its TFTP services.  You are may have to add the WDS role to your server.  WDS creates a REMINST share where the TFTP files will be located.  I used Windows explore to navigate to \\servername\\REMINST\nand then copied on the boot directory (including sub-directories) for the Pi into that location (including the updated bootcode.bin and start.elf).  As with DHCP I'm not sure how adding the Pi contents to the WDS folders may impact normal Windows operation of WDS as\nI don't use that on my network.",
            "title": "Windows Deployment Service"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#windows-nfs-services",
            "text": "The steps above should allow the Pi to at least boot but won't have the rest of the file system.\nWe now need add the Services for NFS role to our server.  Once they are installed we can create NFS shares that the Pi can use.  I created a folder to contain the Pi's file system and then right-click the folder and choose properties and go to the \n'NFS Sharing' tab and click on the button 'Manage NFS Sharing'.  I called the share 'PiRoot' and chose the 'No server authentication [Auth_Sys]', 'Enable unmapped user access', 'Allow unmapped User Unix access' options.\nI believe these allow user permissions and ownerships to work in the best way.  I then booted up a normal Pi and copied the whole file system across to the newly created PiRoot share on the Windows server.",
            "title": "Windows NFS services"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/net_tutorial_windows/index.html#cmdlinetxt",
            "text": "Lastly I modified the cmdline.txt to point to the PiRoot NFS folder  root=/dev/nfs rootfstype=nfs nfsroot=192.168.10.200:/PiRoot/ rw ip=dhcp rootwait",
            "title": "cmdline.txt"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/netboot_server_easy/index.html",
            "text": "pxetools\n\n\nWe have created a Python script that is used internally to quickly set up Pi's that will network boot. It takes a serial number, which you can find in \ncat /proc/cpuinfo\n, an owner name and the name of the Pi. It then creates a root filesystem for that Pi from a Raspbian image. There is also a --list option which will print out the IP address of the Pi, and a --remove option. The following instructions describe how to set up the environment required by the script starting from a fresh Raspbian lite image. It might be a good idea to mount a hard disk or flash drive on /nfs so that your SD card isn't providing filesystems to multiple Pi's. This is left as an exercise for the reader.\n\n\nsudo raspi-config\n# Pick expand filesystem option\n# Finish\n# Reboot\n\nsudo apt-get update; sudo apt-get -y upgrade\nsudo apt-get install -y rpi-update\nsudo BRANCH=next rpi-update\nsudo reboot\n\nwget https://raw.githubusercontent.com/raspberrypi/documentation/master/hardware/raspberrypi/bootmodes/pxetools/prepare_pxetools\nbash prepare_pxetools\n\n\n\n\n\nWhen prompted about saving iptables rules, say no.\n\n\nprepare_pxetools should prepare everything you need to use pxetools.\n\n\nWe found that we needed to restart the nfs server after using pxetools for the first time. Do this with:\n\n\nsudo systemctl restart nfs-kernel-server\n\n\n\n\n\nThen plug in your Pi and it should boot!",
            "title": "Netboot server easy"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/netboot_server_easy/index.html#pxetools",
            "text": "We have created a Python script that is used internally to quickly set up Pi's that will network boot. It takes a serial number, which you can find in  cat /proc/cpuinfo , an owner name and the name of the Pi. It then creates a root filesystem for that Pi from a Raspbian image. There is also a --list option which will print out the IP address of the Pi, and a --remove option. The following instructions describe how to set up the environment required by the script starting from a fresh Raspbian lite image. It might be a good idea to mount a hard disk or flash drive on /nfs so that your SD card isn't providing filesystems to multiple Pi's. This is left as an exercise for the reader.  sudo raspi-config\n# Pick expand filesystem option\n# Finish\n# Reboot\n\nsudo apt-get update; sudo apt-get -y upgrade\nsudo apt-get install -y rpi-update\nsudo BRANCH=next rpi-update\nsudo reboot\n\nwget https://raw.githubusercontent.com/raspberrypi/documentation/master/hardware/raspberrypi/bootmodes/pxetools/prepare_pxetools\nbash prepare_pxetools  When prompted about saving iptables rules, say no.  prepare_pxetools should prepare everything you need to use pxetools.  We found that we needed to restart the nfs server after using pxetools for the first time. Do this with:  sudo systemctl restart nfs-kernel-server  Then plug in your Pi and it should boot!",
            "title": "pxetools"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/sdcard/index.html",
            "text": "SD Card boot",
            "title": "SD Card boot"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/sdcard/index.html#sd-card-boot",
            "text": "",
            "title": "SD Card boot"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/usb/index.html",
            "text": "USB boot modes\n\n\nThere are two separate boot modes for USB: the device and the host boot modes. The choice between the two modes is made at boot time by reading the OTP bits. There are two bits to control USB boot: the first enables device boot and is enabled by default on all Raspberry Pi devices. The second bit enables USB host boot; if this bit is also set then the processor reads the OTGID pin to decide whether to boot as a host (driven to zero as on the Raspberry Pi Model B) or as a device (left floating). The Pi Zero has access to this pin through the OTGID pin on the USB connector, and the compute module has access to this pin on the edge connector.\n\n\n\n\nUSB host boot\n\n\nUSB device boot",
            "title": "USB boot modes"
        },
        {
            "location": "/hardware/raspberrypi/bootmodes/usb/index.html#usb-boot-modes",
            "text": "There are two separate boot modes for USB: the device and the host boot modes. The choice between the two modes is made at boot time by reading the OTP bits. There are two bits to control USB boot: the first enables device boot and is enabled by default on all Raspberry Pi devices. The second bit enables USB host boot; if this bit is also set then the processor reads the OTGID pin to decide whether to boot as a host (driven to zero as on the Raspberry Pi Model B) or as a device (left floating). The Pi Zero has access to this pin through the OTGID pin on the USB connector, and the compute module has access to this pin on the edge connector.   USB host boot  USB device boot",
            "title": "USB boot modes"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html",
            "text": "DPI (Parallel Display Interface)\n\n\nAn up-to-24-bit parallel RGB interface is available on all Raspberry Pi boards with the 40 way header (A+, B+, Pi2, Pi3, Zero) and Compute Module. This interface allows parallel RGB displays to be attached to the Raspberry Pi GPIO either in RGB24 (8 bits for red, green and blue) or RGB666 (6 bits per colour) or RGB565 (5 bits red, 6 green, and 5 blue).\n\n\nThis interface is controlled by the GPU firmware and can be programmed by a user via special config.txt parameters and by enabling the correct Linux Device Tree overlay.\n\n\nGPIO Pins\n\n\nOne of the alternate functions selectable on bank 0 of the Raspberry Pi GPIO is DPI (Display Parallel Interface) which is a simple clocked parallel interface (up to 8 bits of R, G and B; clock, enable, hsync, and vsync). This interface is available as alternate function 2 (ALT2) on GPIO bank 0:\n\n\n\n\nNote that there are various ways that the colour values can be presented on the DPI output pins in either 565, 666, or 24-bit modes (see the following table and the \noutput_format\n part of the \ndpi_output_format\n parameter below):\n\n\n\n\nDisable other GPIO peripherals\n\n\nNote that all other peripheral overlays that use conflicting GPIO pins must be disabled. In config.txt, take care to comment out or invert any dtparams that enable I2C or SPI:\n\n\ndtparam=i2c_arm=off\ndtparam=spi=off\n\n\n\n\n\nControlling Output Format\n\n\nThe output format (clock, colour format, sync polarity, enable) can be controlled with a magic number (unsigned integer or hex value prefixed with 0x) passed to the \ndpi_output_format\n parameter in config.txt created from the following fields:\n\n\noutput_format          = (dpi_output_format >>  0) & 0xf;\nrgb_order              = (dpi_output_format >>  4) & 0xf;\n\noutput_enable_mode     = (dpi_output_format >>  8) & 0x1;\ninvert_pixel_clock     = (dpi_output_format >>  9) & 0x1;\n\nhsync_disable          = (dpi_output_format >> 12) & 0x1;\nvsync_disable          = (dpi_output_format >> 13) & 0x1;\noutput_enable_disable  = (dpi_output_format >> 14) & 0x1;\n\nhsync_polarity         = (dpi_output_format >> 16) & 0x1;\nvsync_polarity         = (dpi_output_format >> 17) & 0x1;\noutput_enable_polarity = (dpi_output_format >> 18) & 0x1;\n\nhsync_phase            = (dpi_output_format >> 20) & 0x1;\nvsync_phase            = (dpi_output_format >> 21) & 0x1;\noutput_enable_phase    = (dpi_output_format >> 22) & 0x1;\n\noutput_format:\n   1: DPI_OUTPUT_FORMAT_9BIT_666\n   2: DPI_OUTPUT_FORMAT_16BIT_565_CFG1\n   3: DPI_OUTPUT_FORMAT_16BIT_565_CFG2\n   4: DPI_OUTPUT_FORMAT_16BIT_565_CFG3\n   5: DPI_OUTPUT_FORMAT_18BIT_666_CFG1\n   6: DPI_OUTPUT_FORMAT_18BIT_666_CFG2\n   7: DPI_OUTPUT_FORMAT_24BIT_888\n\nrgb_order:\n   1: DPI_RGB_ORDER_RGB\n   2: DPI_RGB_ORDER_BGR\n   3: DPI_RGB_ORDER_GRB\n   4: DPI_RGB_ORDER_BRG\n\noutput_enable_mode:\n   0: DPI_OUTPUT_ENABLE_MODE_DATA_VALID\n   1: DPI_OUTPUT_ENABLE_MODE_COMBINED_SYNCS\n\ninvert_pixel_clock:\n   0: RGB Data changes on rising edge and is stable at falling edge\n   1: RGB Data changes on falling edge and is stable at rising edge.\n\nhsync/vsync/output_enable_polarity:\n   0: default for HDMI mode\n   1: inverted\n\nhsync/vsync/oe phases:\n   0: DPI_PHASE_POSEDGE\n   1: DPI_PHASE_NEGEDGE\n\n\n\n\n\nNB the single bit fields all act as an \"invert default behaviour\".\n\n\nControlling Timings / Resolutions\n\n\nThe \ndpi_group\n and \ndpi_mode\n config.txt parameters are used to set either predetermined modes (DMT or CEA modes as used by HDMI) or a user can generate custom modes.\n\n\nTo generate a custom HDMI mode start \nhere\n.\n\n\nIf you set up a custom HDMI mode, then in config.txt use:\n\n\ndpi_group=2\ndpi_mode=87\n\n\n\n\n\nThis will use the custom HDMI timings for DPI.\n\n\nThe other option is to use the hdmi_timings config.txt parameter to set the HDMI (DPI) timings directly. You still need the \ndpi_group=2\n and \ndpi_mode=87\n parameters in config.txt \n\n\nThe hdmi_timings parameters are specified as a space-delimited set of parameters:\n\n\nhdmi_timings=<h_active_pixels> <h_sync_polarity> <h_front_porch> <h_sync_pulse> <h_back_porch> <v_active_lines> <v_sync_polarity> <v_front_porch> <v_sync_pulse> <v_back_porch> <v_sync_offset_a> <v_sync_offset_b> <pixel_rep> <frame_rate> <interlaced> <pixel_freq> <aspect_ratio>\n\n<h_active_pixels> = horizontal pixels (width)\n<h_sync_polarity> = invert hsync polarity\n<h_front_porch>   = horizontal forward padding from DE acitve edge\n<h_sync_pulse>    = hsync pulse width in pixel clocks\n<h_back_porch>    = vertical back padding from DE active edge\n<v_active_lines>  = vertical pixels height (lines)\n<v_sync_polarity> = invert vsync polarity\n<v_front_porch>   = vertical forward padding from DE active edge\n<v_sync_pulse>    = vsync pulse width in pixel clocks\n<v_back_porch>    = vertical back padding from DE active edge\n<v_sync_offset_a> = leave at zero\n<v_sync_offset_b> = leave at zero\n<pixel_rep>       = leave at zero\n<frame_rate>      = screen refresh rate in Hz\n<interlaced>      = leave at zero\n<pixel_freq>      = clock frequency (width*height*framerate)\n<aspect_ratio>    = *\n\n* The aspect ratio can be set to one of 8 values (choose closest for your screen):\n\nHDMI_ASPECT_4_3 = 1\nHDMI_ASPECT_14_9 = 2\nHDMI_ASPECT_16_9 = 3\nHDMI_ASPECT_5_4 = 4\nHDMI_ASPECT_16_10 = 5\nHDMI_ASPECT_15_9 = 6\nHDMI_ASPECT_21_9 = 7\nHDMI_ASPECT_64_27 = 8\n\n\n\n\n\nOverlays\n\n\nA Linux Device Tree overlay is used to switch the GPIO pins into the correct mode (alt function 2). As previously mentioned, the GPU is responsible for driving the DPI display. Hence there is no Linux driver; the overlay simply sets the GPIO alt functions correctly.\n\n\nA 'full fat' DPI overlay (dpi24.dtb) is provided which sets all 28 GPIOs to ALT2 mode, providing the full 24 bits of colour bus as well as the h and v-sync, enable and pixel clock. Note this uses \nall\n of the bank 0 GPIO pins.\n\n\nA second overlay (vga666.dtb) is provided for driving VGA monitor signals in 666 mode which don't need the clock and DE pins (GPIO 0 and 1) and only require GPIOs 4-21 for colour (using mode 5).\n\n\nThese overlays are fairly trivial and a user can edit them to create a custom overlay to enable just the pins required for their specific use case. For example, if one was using a DPI display using vsync, hsync, pclk, and de but in RGB565 mode (mode 2), then the dpi24.dtb overlay could be edited so that GPIOs 20-27 were not switched to DPI mode and hence could be used for other purposes.\n\n\nExample config.txt settings\n\n\nGert VGA666 adaptor\n\n\nThis setup is for the \nGert VGA adaptor\n\n\nNote that the instructions provided in the documentation in the above GitHub link are somewhat out of date, please use the settings below.\n\n\ndtoverlay=vga666\nenable_dpi_lcd=1\ndisplay_default_lcd=1\ndpi_group=2\ndpi_mode=82\n\n\n\n\n\n800x480 LCD panel\n\n\nNote: this was tested with \nAdafruit's DPI add-on board and 800x480 LCD panel\n\n\ndtoverlay=dpi24\noverscan_left=0\noverscan_right=0\noverscan_top=0\noverscan_bottom=0\nframebuffer_width=800\nframebuffer_height=480\nenable_dpi_lcd=1\ndisplay_default_lcd=1\ndpi_group=2\ndpi_mode=87\ndpi_output_format=0x6f005\nhdmi_timings=800 0 40 48 88 480 0 13 3 32 0 0 0 60 0 32000000 6",
            "title": "DPI (Parallel Display Interface)"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#dpi-parallel-display-interface",
            "text": "An up-to-24-bit parallel RGB interface is available on all Raspberry Pi boards with the 40 way header (A+, B+, Pi2, Pi3, Zero) and Compute Module. This interface allows parallel RGB displays to be attached to the Raspberry Pi GPIO either in RGB24 (8 bits for red, green and blue) or RGB666 (6 bits per colour) or RGB565 (5 bits red, 6 green, and 5 blue).  This interface is controlled by the GPU firmware and can be programmed by a user via special config.txt parameters and by enabling the correct Linux Device Tree overlay.",
            "title": "DPI (Parallel Display Interface)"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#gpio-pins",
            "text": "One of the alternate functions selectable on bank 0 of the Raspberry Pi GPIO is DPI (Display Parallel Interface) which is a simple clocked parallel interface (up to 8 bits of R, G and B; clock, enable, hsync, and vsync). This interface is available as alternate function 2 (ALT2) on GPIO bank 0:   Note that there are various ways that the colour values can be presented on the DPI output pins in either 565, 666, or 24-bit modes (see the following table and the  output_format  part of the  dpi_output_format  parameter below):",
            "title": "GPIO Pins"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#disable-other-gpio-peripherals",
            "text": "Note that all other peripheral overlays that use conflicting GPIO pins must be disabled. In config.txt, take care to comment out or invert any dtparams that enable I2C or SPI:  dtparam=i2c_arm=off\ndtparam=spi=off",
            "title": "Disable other GPIO peripherals"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#controlling-output-format",
            "text": "The output format (clock, colour format, sync polarity, enable) can be controlled with a magic number (unsigned integer or hex value prefixed with 0x) passed to the  dpi_output_format  parameter in config.txt created from the following fields:  output_format          = (dpi_output_format >>  0) & 0xf;\nrgb_order              = (dpi_output_format >>  4) & 0xf;\n\noutput_enable_mode     = (dpi_output_format >>  8) & 0x1;\ninvert_pixel_clock     = (dpi_output_format >>  9) & 0x1;\n\nhsync_disable          = (dpi_output_format >> 12) & 0x1;\nvsync_disable          = (dpi_output_format >> 13) & 0x1;\noutput_enable_disable  = (dpi_output_format >> 14) & 0x1;\n\nhsync_polarity         = (dpi_output_format >> 16) & 0x1;\nvsync_polarity         = (dpi_output_format >> 17) & 0x1;\noutput_enable_polarity = (dpi_output_format >> 18) & 0x1;\n\nhsync_phase            = (dpi_output_format >> 20) & 0x1;\nvsync_phase            = (dpi_output_format >> 21) & 0x1;\noutput_enable_phase    = (dpi_output_format >> 22) & 0x1;\n\noutput_format:\n   1: DPI_OUTPUT_FORMAT_9BIT_666\n   2: DPI_OUTPUT_FORMAT_16BIT_565_CFG1\n   3: DPI_OUTPUT_FORMAT_16BIT_565_CFG2\n   4: DPI_OUTPUT_FORMAT_16BIT_565_CFG3\n   5: DPI_OUTPUT_FORMAT_18BIT_666_CFG1\n   6: DPI_OUTPUT_FORMAT_18BIT_666_CFG2\n   7: DPI_OUTPUT_FORMAT_24BIT_888\n\nrgb_order:\n   1: DPI_RGB_ORDER_RGB\n   2: DPI_RGB_ORDER_BGR\n   3: DPI_RGB_ORDER_GRB\n   4: DPI_RGB_ORDER_BRG\n\noutput_enable_mode:\n   0: DPI_OUTPUT_ENABLE_MODE_DATA_VALID\n   1: DPI_OUTPUT_ENABLE_MODE_COMBINED_SYNCS\n\ninvert_pixel_clock:\n   0: RGB Data changes on rising edge and is stable at falling edge\n   1: RGB Data changes on falling edge and is stable at rising edge.\n\nhsync/vsync/output_enable_polarity:\n   0: default for HDMI mode\n   1: inverted\n\nhsync/vsync/oe phases:\n   0: DPI_PHASE_POSEDGE\n   1: DPI_PHASE_NEGEDGE  NB the single bit fields all act as an \"invert default behaviour\".",
            "title": "Controlling Output Format"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#controlling-timings-resolutions",
            "text": "The  dpi_group  and  dpi_mode  config.txt parameters are used to set either predetermined modes (DMT or CEA modes as used by HDMI) or a user can generate custom modes.  To generate a custom HDMI mode start  here .  If you set up a custom HDMI mode, then in config.txt use:  dpi_group=2\ndpi_mode=87  This will use the custom HDMI timings for DPI.  The other option is to use the hdmi_timings config.txt parameter to set the HDMI (DPI) timings directly. You still need the  dpi_group=2  and  dpi_mode=87  parameters in config.txt   The hdmi_timings parameters are specified as a space-delimited set of parameters:  hdmi_timings=<h_active_pixels> <h_sync_polarity> <h_front_porch> <h_sync_pulse> <h_back_porch> <v_active_lines> <v_sync_polarity> <v_front_porch> <v_sync_pulse> <v_back_porch> <v_sync_offset_a> <v_sync_offset_b> <pixel_rep> <frame_rate> <interlaced> <pixel_freq> <aspect_ratio>\n\n<h_active_pixels> = horizontal pixels (width)\n<h_sync_polarity> = invert hsync polarity\n<h_front_porch>   = horizontal forward padding from DE acitve edge\n<h_sync_pulse>    = hsync pulse width in pixel clocks\n<h_back_porch>    = vertical back padding from DE active edge\n<v_active_lines>  = vertical pixels height (lines)\n<v_sync_polarity> = invert vsync polarity\n<v_front_porch>   = vertical forward padding from DE active edge\n<v_sync_pulse>    = vsync pulse width in pixel clocks\n<v_back_porch>    = vertical back padding from DE active edge\n<v_sync_offset_a> = leave at zero\n<v_sync_offset_b> = leave at zero\n<pixel_rep>       = leave at zero\n<frame_rate>      = screen refresh rate in Hz\n<interlaced>      = leave at zero\n<pixel_freq>      = clock frequency (width*height*framerate)\n<aspect_ratio>    = *\n\n* The aspect ratio can be set to one of 8 values (choose closest for your screen):\n\nHDMI_ASPECT_4_3 = 1\nHDMI_ASPECT_14_9 = 2\nHDMI_ASPECT_16_9 = 3\nHDMI_ASPECT_5_4 = 4\nHDMI_ASPECT_16_10 = 5\nHDMI_ASPECT_15_9 = 6\nHDMI_ASPECT_21_9 = 7\nHDMI_ASPECT_64_27 = 8",
            "title": "Controlling Timings / Resolutions"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#overlays",
            "text": "A Linux Device Tree overlay is used to switch the GPIO pins into the correct mode (alt function 2). As previously mentioned, the GPU is responsible for driving the DPI display. Hence there is no Linux driver; the overlay simply sets the GPIO alt functions correctly.  A 'full fat' DPI overlay (dpi24.dtb) is provided which sets all 28 GPIOs to ALT2 mode, providing the full 24 bits of colour bus as well as the h and v-sync, enable and pixel clock. Note this uses  all  of the bank 0 GPIO pins.  A second overlay (vga666.dtb) is provided for driving VGA monitor signals in 666 mode which don't need the clock and DE pins (GPIO 0 and 1) and only require GPIOs 4-21 for colour (using mode 5).  These overlays are fairly trivial and a user can edit them to create a custom overlay to enable just the pins required for their specific use case. For example, if one was using a DPI display using vsync, hsync, pclk, and de but in RGB565 mode (mode 2), then the dpi24.dtb overlay could be edited so that GPIOs 20-27 were not switched to DPI mode and hence could be used for other purposes.",
            "title": "Overlays"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#example-configtxt-settings",
            "text": "",
            "title": "Example config.txt settings"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#gert-vga666-adaptor",
            "text": "This setup is for the  Gert VGA adaptor  Note that the instructions provided in the documentation in the above GitHub link are somewhat out of date, please use the settings below.  dtoverlay=vga666\nenable_dpi_lcd=1\ndisplay_default_lcd=1\ndpi_group=2\ndpi_mode=82",
            "title": "Gert VGA666 adaptor"
        },
        {
            "location": "/hardware/raspberrypi/dpi/README/index.html#800x480-lcd-panel",
            "text": "Note: this was tested with  Adafruit's DPI add-on board and 800x480 LCD panel  dtoverlay=dpi24\noverscan_left=0\noverscan_right=0\noverscan_top=0\noverscan_bottom=0\nframebuffer_width=800\nframebuffer_height=480\nenable_dpi_lcd=1\ndisplay_default_lcd=1\ndpi_group=2\ndpi_mode=87\ndpi_output_format=0x6f005\nhdmi_timings=800 0 40 48 88 480 0 13 3 32 0 0 0 60 0 32000000 6",
            "title": "800x480 LCD panel"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html",
            "text": "GPIO\n\n\nGeneral Purpose Input/Output pins on the Raspberry Pi\n\n\nOverview\n\n\nThis page expands on the technical features of the GPIO pins available on BCM2835 in general. For usage examples, see \nGPIO Usage for A+ and newer\n or \nGPIO Usage for models A and B\n. When reading this page, reference should be made to the BCM2835 ARM Peripherals \nDatasheet\n, section 6.\n\n\nGPIO pins can be configured as either general-purpose input, general-purpose output or as one of up to 6 special alternate settings, the functions of which are pin-dependent.\n\n\nThere are 3 GPIO banks on BCM2835.\n\n\nEach of the 3 banks has its own VDD input pin. On Raspberry Pi, all GPIO banks are supplied from 3.3V. \nConnection of a GPIO to a voltage higher than 3.3V will likely destroy the GPIO block within the SoC.\n\n\nA selection of pins from Bank 0 is available on the P1 header on Raspberry Pi.\n\n\nGPIO Pads\n\n\nThe GPIO connections on the BCM2835 package are sometimes referred to in the peripherals datasheet as \"pads\" - a semiconductor design term meaning \"chip connection to outside world\".\n\n\nThe pads are configurable CMOS push-pull output drivers/input buffers. Register-based control settings are available for\n\n\n\n\nInternal pull-up / pull-down enable/disable\n\n\nOutput \ndrive strength\n\n\nInput Schmitt-trigger filtering\n\n\n\n\nPower-On States\n\n\nAll GPIOs revert to general-purpose inputs on power-on reset. The default pull states are also applied, which are detailed in the alternate function table in the ARM peripherals datasheet. Most GPIOs have a default pull applied.\n\n\nInterrupts\n\n\nEach GPIO pin, when configured as a general-purpose input, can be configured as an interrupt source to the ARM. Several interrupt generation sources are configurable:\n\n\n\n\nLevel-sensitive (high/low)\n\n\nRising/falling edge\n\n\nAsynchronous rising/falling edge\n\n\n\n\nLevel interrupts maintain the interrupt status until the level has been cleared by system software (e.g. by servicing the attached peripheral generating the interrupt).\n\n\nThe normal rising/falling edge detection has a small amount of synchronisation built into the detection. At the system clock frequency, the pin is sampled with the criteria for generation of an interrupt being a stable transition within a 3-cycle window, i.e. a record of \"1 0 0\" or \"0 1 1\". Asynchronous detection bypasses this synchronisation to enable the detection of very narrow events.\n\n\nAlternative Functions\n\n\nAlmost all of the GPIO pins have alternative functions. Peripheral blocks internal to BCM2835 can be selected to appear on one or more of a set of GPIO pins, for example the I2C busses can be configured to at least 3 separate locations. Pad control, such as drive strength or Schmitt filtering, still applies when the pin is configured as an alternate function.",
            "title": "GPIO"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#gpio",
            "text": "General Purpose Input/Output pins on the Raspberry Pi",
            "title": "GPIO"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#overview",
            "text": "This page expands on the technical features of the GPIO pins available on BCM2835 in general. For usage examples, see  GPIO Usage for A+ and newer  or  GPIO Usage for models A and B . When reading this page, reference should be made to the BCM2835 ARM Peripherals  Datasheet , section 6.  GPIO pins can be configured as either general-purpose input, general-purpose output or as one of up to 6 special alternate settings, the functions of which are pin-dependent.  There are 3 GPIO banks on BCM2835.  Each of the 3 banks has its own VDD input pin. On Raspberry Pi, all GPIO banks are supplied from 3.3V.  Connection of a GPIO to a voltage higher than 3.3V will likely destroy the GPIO block within the SoC.  A selection of pins from Bank 0 is available on the P1 header on Raspberry Pi.",
            "title": "Overview"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#gpio-pads",
            "text": "The GPIO connections on the BCM2835 package are sometimes referred to in the peripherals datasheet as \"pads\" - a semiconductor design term meaning \"chip connection to outside world\".  The pads are configurable CMOS push-pull output drivers/input buffers. Register-based control settings are available for   Internal pull-up / pull-down enable/disable  Output  drive strength  Input Schmitt-trigger filtering",
            "title": "GPIO Pads"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#power-on-states",
            "text": "All GPIOs revert to general-purpose inputs on power-on reset. The default pull states are also applied, which are detailed in the alternate function table in the ARM peripherals datasheet. Most GPIOs have a default pull applied.",
            "title": "Power-On States"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#interrupts",
            "text": "Each GPIO pin, when configured as a general-purpose input, can be configured as an interrupt source to the ARM. Several interrupt generation sources are configurable:   Level-sensitive (high/low)  Rising/falling edge  Asynchronous rising/falling edge   Level interrupts maintain the interrupt status until the level has been cleared by system software (e.g. by servicing the attached peripheral generating the interrupt).  The normal rising/falling edge detection has a small amount of synchronisation built into the detection. At the system clock frequency, the pin is sampled with the criteria for generation of an interrupt being a stable transition within a 3-cycle window, i.e. a record of \"1 0 0\" or \"0 1 1\". Asynchronous detection bypasses this synchronisation to enable the detection of very narrow events.",
            "title": "Interrupts"
        },
        {
            "location": "/hardware/raspberrypi/gpio/README/index.html#alternative-functions",
            "text": "Almost all of the GPIO pins have alternative functions. Peripheral blocks internal to BCM2835 can be selected to appear on one or more of a set of GPIO pins, for example the I2C busses can be configured to at least 3 separate locations. Pad control, such as drive strength or Schmitt filtering, still applies when the pin is configured as an alternate function.",
            "title": "Alternative Functions"
        },
        {
            "location": "/hardware/raspberrypi/mechanical/README/index.html",
            "text": "Mechanical Drawings\n\n\nRaspberry Pi 3\n\n\n\n\nPDF\n\n\nDXF\n\n\n\n\nRaspberry Pi Model B+\n\n\n\n\nPDF\n\n\nDXF\n\n\n\n\nRaspberry Pi Zero (v1.2)\n\n\n\n\nPDF",
            "title": "Mechanical Drawings"
        },
        {
            "location": "/hardware/raspberrypi/mechanical/README/index.html#mechanical-drawings",
            "text": "",
            "title": "Mechanical Drawings"
        },
        {
            "location": "/hardware/raspberrypi/mechanical/README/index.html#raspberry-pi-3",
            "text": "PDF  DXF",
            "title": "Raspberry Pi 3"
        },
        {
            "location": "/hardware/raspberrypi/mechanical/README/index.html#raspberry-pi-model-b",
            "text": "PDF  DXF",
            "title": "Raspberry Pi Model B+"
        },
        {
            "location": "/hardware/raspberrypi/mechanical/README/index.html#raspberry-pi-zero-v12",
            "text": "PDF",
            "title": "Raspberry Pi Zero (v1.2)"
        },
        {
            "location": "/hardware/raspberrypi/power/README/index.html",
            "text": "Power Supply\n\n\nThe Raspberry Pi 3 is powered by a +5.1V micro USB supply. Exactly how much current (mA) the Raspberry Pi requires is dependent on what you connect to it. We have found that purchasing a 2.5A power supply from a reputable retailer will provide you with ample power to run your Raspberry Pi. You can purchase the \nofficial Raspberry Pi Power Supply\n from our website, and you can learn more about the differing power requirements of the various models of the Raspberry Pi on our \nFAQ page\n. \n\n\nTypically, the model B uses between 700-1000mA depending on what peripherals are connected; the model A can use as little as 500mA with no peripherals attached. The maximum power the Raspberry Pi can use is 1 Amp. If you need to connect a USB device that will take the power requirements above 1 Amp, then you must connect it to an externally-powered USB hub.\n\n\nThe power requirements of the Raspberry Pi increase as you make use of the various interfaces on the Raspberry Pi. The GPIO pins can draw 50mA safely, distributed across all the pins; an individual GPIO pin can only safely draw 16mA. The HDMI port uses 50mA, the camera module requires 250mA, and keyboards and mice can take as little as 100mA or over 1000mA! Check the power rating of the devices you plan to connect to the Pi and purchase a power supply accordingly.\n\n\nBackpowering\n\n\nBackpowering occurs when USB hubs do not provide a diode to stop the hub from powering against the host computer. Other hubs will provide as much power as you want out each port. Please also be aware that some hubs will backfeed the Raspberry Pi. This means that the hubs will power the Raspberry Pi through its USB cable input cable, without the need for a separate micro-USB power cable, and bypass the voltage protection. If you are using a hub that backfeeds to the Raspberry Pi and the hub experiences a power surge, your Raspberry Pi could potentially be damaged.",
            "title": "Power Supply"
        },
        {
            "location": "/hardware/raspberrypi/power/README/index.html#power-supply",
            "text": "The Raspberry Pi 3 is powered by a +5.1V micro USB supply. Exactly how much current (mA) the Raspberry Pi requires is dependent on what you connect to it. We have found that purchasing a 2.5A power supply from a reputable retailer will provide you with ample power to run your Raspberry Pi. You can purchase the  official Raspberry Pi Power Supply  from our website, and you can learn more about the differing power requirements of the various models of the Raspberry Pi on our  FAQ page .   Typically, the model B uses between 700-1000mA depending on what peripherals are connected; the model A can use as little as 500mA with no peripherals attached. The maximum power the Raspberry Pi can use is 1 Amp. If you need to connect a USB device that will take the power requirements above 1 Amp, then you must connect it to an externally-powered USB hub.  The power requirements of the Raspberry Pi increase as you make use of the various interfaces on the Raspberry Pi. The GPIO pins can draw 50mA safely, distributed across all the pins; an individual GPIO pin can only safely draw 16mA. The HDMI port uses 50mA, the camera module requires 250mA, and keyboards and mice can take as little as 100mA or over 1000mA! Check the power rating of the devices you plan to connect to the Pi and purchase a power supply accordingly.",
            "title": "Power Supply"
        },
        {
            "location": "/hardware/raspberrypi/power/README/index.html#backpowering",
            "text": "Backpowering occurs when USB hubs do not provide a diode to stop the hub from powering against the host computer. Other hubs will provide as much power as you want out each port. Please also be aware that some hubs will backfeed the Raspberry Pi. This means that the hubs will power the Raspberry Pi through its USB cable input cable, without the need for a separate micro-USB power cable, and bypass the voltage protection. If you are using a hub that backfeeds to the Raspberry Pi and the hub experiences a power surge, your Raspberry Pi could potentially be damaged.",
            "title": "Backpowering"
        },
        {
            "location": "/hardware/raspberrypi/revision-codes/README/index.html",
            "text": "Raspberry Pi revision codes\n\n\nEach distinct Raspberry Pi model revision has a unique revision code. You can look up a Raspberry Pi's revision code by running:\n\n\ncat /proc/cpuinfo\n\n\n\n\n\nThe last three lines show the hardware type, the revision code, and the Pi's unique serial number. For example:\n\n\nHardware\n    \n:\n \nBCM2835\n\n\nRevision\n    \n:\n \na02082\n\n\nSerial\n      \n:\n \n00000000765\nfc593\n\n\n\n\n\n\nNote: As of the 4.9 kernel, all Pis report \nBCM2835\n, even those with BCM2836 and BCM2837 processors. You should not use this string to detect the processor.\n\n\nOld-style revision codes\n\n\nThe first set of Raspberry Pi revisions were given sequential hex revision codes from \n0002\n to \n0015\n:\n\n\n\n\n\n\n\n\nCode\n\n\nModel\n\n\nRevision\n\n\nRAM\n\n\nManufacturer\n\n\n\n\n\n\n\n\n\n\n0002\n\n\nB\n\n\n1.0\n\n\n256 MB\n\n\nEgoman\n\n\n\n\n\n\n0003\n\n\nB\n\n\n1.0\n\n\n256 MB\n\n\nEgoman\n\n\n\n\n\n\n0004\n\n\nB\n\n\n2.0\n\n\n256 MB\n\n\nSony UK\n\n\n\n\n\n\n0005\n\n\nB\n\n\n2.0\n\n\n256 MB\n\n\nQisda\n\n\n\n\n\n\n0006\n\n\nB\n\n\n2.0\n\n\n256 MB\n\n\nEgoman\n\n\n\n\n\n\n0007\n\n\nA\n\n\n2.0\n\n\n256 MB\n\n\nEgoman\n\n\n\n\n\n\n0008\n\n\nA\n\n\n2.0\n\n\n256 MB\n\n\nSony UK\n\n\n\n\n\n\n0009\n\n\nA\n\n\n2.0\n\n\n256 MB\n\n\nQisda\n\n\n\n\n\n\n000d\n\n\nB\n\n\n2.0\n\n\n512 MB\n\n\nEgoman\n\n\n\n\n\n\n000e\n\n\nB\n\n\n2.0\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n000f\n\n\nB\n\n\n2.0\n\n\n512 MB\n\n\nEgoman\n\n\n\n\n\n\n0010\n\n\nB+\n\n\n1.0\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n0011\n\n\nCM1\n\n\n1.0\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n0012\n\n\nA+\n\n\n1.1\n\n\n256 MB\n\n\nSony UK\n\n\n\n\n\n\n0013\n\n\nB+\n\n\n1.2\n\n\n512 MB\n\n\nEmbest\n\n\n\n\n\n\n0014\n\n\nCM1\n\n\n1.0\n\n\n512 MB\n\n\nEmbest\n\n\n\n\n\n\n0015\n\n\nA+\n\n\n1.1\n\n\n256 MB / 512 MB\n\n\nEmbest\n\n\n\n\n\n\n\n\nNew-style revision codes\n\n\nWith the launch of the Raspberry Pi 2, new-style revision codes were introduced. Rather than being sequential, each bit of the hex code represents a piece of information about the revision:\n\n\nuuuuuuuuFMMMCCCCPPPPTTTTTTTTRRRR\n\n\n\n\n\n\n\n\n\n\n\nPart\n\n\nRepresents\n\n\nOptions\n\n\n\n\n\n\n\n\n\n\nuuuuuuuu\n\n\nUnused\n\n\nUnused\n\n\n\n\n\n\nF\n\n\nNew flag\n\n\n1: new-style revision\n\n\n\n\n\n\n\n\n\n\n0: old-style revision\n\n\n\n\n\n\nMMM\n\n\nMemory size\n\n\n0: 256 MB\n\n\n\n\n\n\n\n\n\n\n1: 512 MB\n\n\n\n\n\n\n\n\n\n\n2: 1 GB\n\n\n\n\n\n\nCCCC\n\n\nManufacturer\n\n\n0: Sony UK\n\n\n\n\n\n\n\n\n\n\n1: Egoman\n\n\n\n\n\n\n\n\n\n\n2: Embest\n\n\n\n\n\n\n\n\n\n\n3: Sony Japan\n\n\n\n\n\n\nPPPP\n\n\nProcessor\n\n\n0: BCM2835\n\n\n\n\n\n\n\n\n\n\n1: BCM2836\n\n\n\n\n\n\n\n\n\n\n2: BCM2837\n\n\n\n\n\n\nTTTTTTTT\n\n\nType\n\n\n0: A\n\n\n\n\n\n\n\n\n\n\n1: B\n\n\n\n\n\n\n\n\n\n\n2: A+\n\n\n\n\n\n\n\n\n\n\n3: B+\n\n\n\n\n\n\n\n\n\n\n4: 2B\n\n\n\n\n\n\n\n\n\n\n5: Alpha (early prototype)\n\n\n\n\n\n\n\n\n\n\n6: CM1\n\n\n\n\n\n\n\n\n\n\n8: 3B\n\n\n\n\n\n\n\n\n\n\n9: Zero\n\n\n\n\n\n\n\n\n\n\na: CM3\n\n\n\n\n\n\n\n\n\n\nc: Zero W\n\n\n\n\n\n\nRRRR\n\n\nRevision\n\n\n0, 1, 2, etc.\n\n\n\n\n\n\n\n\nNew-style revision codes in use:\n\n\n\n\n\n\n\n\nCode\n\n\nModel\n\n\nRevision\n\n\nRAM\n\n\nManufacturer\n\n\n\n\n\n\n\n\n\n\n900021\n\n\nA+\n\n\n1.1\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n900032\n\n\nB+\n\n\n1.2\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n900092\n\n\nZero\n\n\n1.2\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n900093\n\n\nZero\n\n\n1.3\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n9000c1\n\n\nZero W\n\n\n1.1\n\n\n512 MB\n\n\nSony UK\n\n\n\n\n\n\n920093\n\n\nZero\n\n\n1.3\n\n\n512 MB\n\n\nEmbest\n\n\n\n\n\n\na01040\n\n\n2B\n\n\n1.0\n\n\n1 GB\n\n\nSony UK\n\n\n\n\n\n\na01041\n\n\n2B\n\n\n1.1\n\n\n1 GB\n\n\nSony UK\n\n\n\n\n\n\na02082\n\n\n3B\n\n\n1.2\n\n\n1 GB\n\n\nSony UK\n\n\n\n\n\n\na020a0\n\n\nCM3\n\n\n1.0\n\n\n1 GB\n\n\nSony UK\n\n\n\n\n\n\na21041\n\n\n2B\n\n\n1.1\n\n\n1 GB\n\n\nEmbest\n\n\n\n\n\n\na22042\n\n\n2B (with BCM2837)\n\n\n1.2\n\n\n1 GB\n\n\nEmbest\n\n\n\n\n\n\na22082\n\n\n3B\n\n\n1.2\n\n\n1 GB\n\n\nEmbest\n\n\n\n\n\n\na32082\n\n\n3B\n\n\n1.2\n\n\n1 GB\n\n\nSony Japan",
            "title": "Raspberry Pi revision codes"
        },
        {
            "location": "/hardware/raspberrypi/revision-codes/README/index.html#raspberry-pi-revision-codes",
            "text": "Each distinct Raspberry Pi model revision has a unique revision code. You can look up a Raspberry Pi's revision code by running:  cat /proc/cpuinfo  The last three lines show the hardware type, the revision code, and the Pi's unique serial number. For example:  Hardware      :   BCM2835  Revision      :   a02082  Serial        :   00000000765 fc593   Note: As of the 4.9 kernel, all Pis report  BCM2835 , even those with BCM2836 and BCM2837 processors. You should not use this string to detect the processor.",
            "title": "Raspberry Pi revision codes"
        },
        {
            "location": "/hardware/raspberrypi/revision-codes/README/index.html#old-style-revision-codes",
            "text": "The first set of Raspberry Pi revisions were given sequential hex revision codes from  0002  to  0015 :     Code  Model  Revision  RAM  Manufacturer      0002  B  1.0  256 MB  Egoman    0003  B  1.0  256 MB  Egoman    0004  B  2.0  256 MB  Sony UK    0005  B  2.0  256 MB  Qisda    0006  B  2.0  256 MB  Egoman    0007  A  2.0  256 MB  Egoman    0008  A  2.0  256 MB  Sony UK    0009  A  2.0  256 MB  Qisda    000d  B  2.0  512 MB  Egoman    000e  B  2.0  512 MB  Sony UK    000f  B  2.0  512 MB  Egoman    0010  B+  1.0  512 MB  Sony UK    0011  CM1  1.0  512 MB  Sony UK    0012  A+  1.1  256 MB  Sony UK    0013  B+  1.2  512 MB  Embest    0014  CM1  1.0  512 MB  Embest    0015  A+  1.1  256 MB / 512 MB  Embest",
            "title": "Old-style revision codes"
        },
        {
            "location": "/hardware/raspberrypi/revision-codes/README/index.html#new-style-revision-codes",
            "text": "With the launch of the Raspberry Pi 2, new-style revision codes were introduced. Rather than being sequential, each bit of the hex code represents a piece of information about the revision:  uuuuuuuuFMMMCCCCPPPPTTTTTTTTRRRR     Part  Represents  Options      uuuuuuuu  Unused  Unused    F  New flag  1: new-style revision      0: old-style revision    MMM  Memory size  0: 256 MB      1: 512 MB      2: 1 GB    CCCC  Manufacturer  0: Sony UK      1: Egoman      2: Embest      3: Sony Japan    PPPP  Processor  0: BCM2835      1: BCM2836      2: BCM2837    TTTTTTTT  Type  0: A      1: B      2: A+      3: B+      4: 2B      5: Alpha (early prototype)      6: CM1      8: 3B      9: Zero      a: CM3      c: Zero W    RRRR  Revision  0, 1, 2, etc.     New-style revision codes in use:     Code  Model  Revision  RAM  Manufacturer      900021  A+  1.1  512 MB  Sony UK    900032  B+  1.2  512 MB  Sony UK    900092  Zero  1.2  512 MB  Sony UK    900093  Zero  1.3  512 MB  Sony UK    9000c1  Zero W  1.1  512 MB  Sony UK    920093  Zero  1.3  512 MB  Embest    a01040  2B  1.0  1 GB  Sony UK    a01041  2B  1.1  1 GB  Sony UK    a02082  3B  1.2  1 GB  Sony UK    a020a0  CM3  1.0  1 GB  Sony UK    a21041  2B  1.1  1 GB  Embest    a22042  2B (with BCM2837)  1.2  1 GB  Embest    a22082  3B  1.2  1 GB  Embest    a32082  3B  1.2  1 GB  Sony Japan",
            "title": "New-style revision codes"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html",
            "text": "Schematics\n\n\nSchematics for the various Raspberry Pi board versions:\n\n\nRaspberry Pi 3 Model B\n\n\n\n\nRevision 1.2\n\n\n\n\nRaspberry Pi 2 Model B\n\n\n\n\nRevision 1.2\n\n\n\n\nRaspberry Pi Model B+\n\n\n\n\nRevision 1.2\n\n\n\n\nRaspberry Pi Model A+\n\n\n\n\nRevision 1.1\n\n\n\n\nRaspberry Pi Zero\n\n\n\n\nRevision 1.3\n\n\n\n\nRaspberry Pi Zero W\n\n\n\n\nRevision 1.1",
            "title": "Schematics"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#schematics",
            "text": "Schematics for the various Raspberry Pi board versions:",
            "title": "Schematics"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-3-model-b",
            "text": "Revision 1.2",
            "title": "Raspberry Pi 3 Model B"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-2-model-b",
            "text": "Revision 1.2",
            "title": "Raspberry Pi 2 Model B"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-model-b",
            "text": "Revision 1.2",
            "title": "Raspberry Pi Model B+"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-model-a",
            "text": "Revision 1.1",
            "title": "Raspberry Pi Model A+"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-zero",
            "text": "Revision 1.3",
            "title": "Raspberry Pi Zero"
        },
        {
            "location": "/hardware/raspberrypi/schematics/README/index.html#raspberry-pi-zero-w",
            "text": "Revision 1.1",
            "title": "Raspberry Pi Zero W"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html",
            "text": "SPI\n\n\nPage Contents\n\n\n\n\nOverview\n  \n\n\nSoftware\n\n\nHardware\n\n\nLinux driver\n\n\nTroubleshooting\n\n\n\n\n\n\nOverview\n\n\nThe Raspberry Pi is equipped with one \nSPI\n bus that has 2 chip selects.\n\n\nThe SPI master driver is disabled by default on Raspbian. To enable it, use \nraspi-config\n, or ensure the line \ndtparam=spi=on\n isn't commented out in \n/boot/config.txt\n, and reboot. If the SPI driver was loaded, you should see the device \n/dev/spidev0.0\n.\n\n\nThe SPI bus is available on the P1 Header:\n\n\nMOSI    P1-19\nMISO    P1-21\nSCLK    P1-23   P1-24    CE0\nGND     P1-25   P1-26    CE1\n\n\n\n\n\n\n\nSoftware\n\n\nWiringPi\n\n\nWiringPi includes a library which can make it easier to use the Raspberry Pi's on-board SPI interface. Accesses the hardware registers directly.\n\n\nhttp://wiringpi.com/\n\n\nbcm2835 library\n\n\nThis is a C library for Raspberry Pi (RPi). It provides access to GPIO and other IO functions on the Broadcom BCM 2835 chip. Accesses the hardware registers directly.\n\n\nhttp://www.airspayce.com/mikem/bcm2835/\n\n\nUse spidev from C\n\n\nThere's a loopback test program in the Linux documentation that can be used as a starting point. See the \nTroubleshooting\n section. Uses the Linux \nspidev\n driver to access the bus.\n\n\nShell\n\n\n# Write binary 1, 2 and 3\n\n\necho\n -ne \n\"\\x01\\x02\\x03\"\n > /dev/spidev0.0\n\n\n\n\n\n\n\nHardware\n\n\nThe BCM2835 on the Raspberry Pi has 3 SPI Controllers. Only the SPI0 controller is available on the header.\nChapter 10 in the \nBCM2835 ARM Peripherals\n datasheet describes this controller.\n\n\nMaster modes\n\n\nSignal name abbreviations\n\n\nSCLK - Serial CLocK\nCE   - Chip Enable (often called Chip Select)\nMOSI - Master Out Slave In\nMISO - Master In Slave Out\nMOMI - Master Out Master In\n\n\n\n\n\nStandard mode\n\n\nIn Standard SPI master mode the peripheral implements the standard 3 wire serial protocol (SCLK, MOSI and MISO).\n\n\nBidirectional mode\n\n\nIn bidirectional SPI master mode the same SPI standard is implemented, except that a single wire is used for data (MOMI) instead of the two used in standard mode (MISO and MOSI). In this mode, the MOSI pin serves as MOMI pin.\n\n\nLoSSI mode (Low Speed Serial Interface)\n\n\nThe LoSSI standard allows issuing of commands to peripherals (LCD) and to transfer data to and from them. LoSSI commands and parameters are 8 bits long, but an extra bit is used to indicate whether the byte is a command or parameter/data. This extra bit is set high for a data and low for a command. The resulting 9-bit value is serialized to the output. LoSSI is commonly used with \nMIPI DBI\n type C compatible LCD controllers.\n\n\nNote:\n\n\nSome commands trigger an automatic read by the SPI controller, so this mode can't be used as a multipurpose 9-bit SPI.\n\n\nTransfer modes\n\n\n\n\nPolled\n\n\nInterrupt\n\n\nDMA\n\n\n\n\nSpeed\n\n\nThe CDIV (Clock Divider) field of the CLK register sets the SPI clock speed:\n\n\nSCLK = Core Clock / CDIV\nIf CDIV is set to 0, the divisor is 65536. The divisor must be a power of 2. Odd numbers rounded down. The maximum SPI clock rate is of the APB clock.\n\n\n\n\n\nErrata\n:  \"must be a power of 2\" probably should be \"must be a multiple of 2\"\n\n\nSee the \nLinux driver\n section for more info.\n\n\nChip Select\n\n\nSetup and Hold times related to the automatic assertion and de-assertion of the CS lines when operating in \nDMA\n mode are as follows:\n\n\n\n\nThe CS line will be asserted at least 3 core clock cycles before the msb of the first byte of the transfer.\n\n\nThe CS line will be de-asserted no earlier than 1 core clock cycle after the trailing edge of the final clock pulse.\n\n\n\n\n\n\nLinux driver\n\n\nThe default Linux driver is \nspi-bcm2708\n.\n\n\nThe following information was valid 2014-07-05.\n\n\nSpeed\n\n\nThe driver supports the following speeds:\n\n\n  cdiv    speed\n     2    125.0 MHz\n     4     62.5 MHz\n     8     31.2 MHz\n    16     15.6 MHz\n    32      7.8 MHz\n    64      3.9 MHz\n   128     1953 kHz\n   256      976 kHz\n   512      488 kHz\n  1024      244 kHz\n  2048      122 kHz\n  4096       61 kHz\n  8192     30.5 kHz\n 16384     15.2 kHz\n 32768     7629 Hz\n\n\n\n\n\nWhen asking for say 24 MHz, the actual speed will be 15.6 MHz.\n\n\nForum post: \nSPI has more speeds\n\n\nSupported Mode bits\n\n\nSPI_CPOL    - Clock polarity\nSPI_CPHA    - Clock phase\nSPI_CS_HIGH - Chip Select active high\nSPI_NO_CS   - 1 device per bus, no Chip Select\nSPI_3WIRE   - Bidirectional mode, data in and out pin shared\n\n\n\n\n\nBidirectional or \"3-wire\" mode is supported by the spi-bcm2835 kernel module. Please note that in this mode, either the tx or rx field of the spi_transfer struct must be a NULL pointer, since only half-duplex communication is possible. Otherwise, the transfer will fail. The spidev_test.c source code does not consider this correctly, and therefore does not work at all in 3-wire mode.\n\n\nSupported bits per word\n\n\n\n\n8 - Normal\n\n\n9 - This is supported using LoSSI mode.\n\n\n\n\nTransfer modes\n\n\nOnly interrupt mode is supported.\n\n\nDeprecated warning\n\n\nThe following appears in the kernel log:\n\n\nbcm2708_spi bcm2708_spi.0: master is unqueued, this is deprecated\n\n\n\n\n\nSPI driver latency\n\n\nThis \nthread\n discusses latency problems.\n\n\nDMA capable driver\n\n\nThis is a fork of spi-bcm2708 which enables DMA support for SPI client drivers that support DMA.\n\n\nhttps://github.com/notro/spi-bcm2708 (\nwiki\n)\n\n\n\n\nTroubleshooting\n\n\nLoopback test\n\n\nThis can be used to test SPI send and receive. Put a wire between MOSI and MISO. It does not test CE0 and CE1.\n\n\nwget https://raw.githubusercontent.com/raspberrypi/linux/rpi-3.10.y/Documentation/spi/spidev_test.c\ngcc -o spidev_test spidev_test.c\n./spidev_test -D /dev/spidev0.0\nspi mode: \n0\n\nbits per word: \n8\n\nmax speed: \n500000\n Hz \n(\n500\n KHz\n)\n\n\nFF FF FF FF FF FF\n\n40\n \n00\n \n00\n \n00\n \n00\n \n95\n\nFF FF FF FF FF FF\nFF FF FF FF FF FF\nFF FF FF FF FF FF\nDE AD BE EF BA AD\nF0 0D",
            "title": "SPI"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#spi",
            "text": "",
            "title": "SPI"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#page-contents",
            "text": "Overview     Software  Hardware  Linux driver  Troubleshooting",
            "title": "Page Contents"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#overview",
            "text": "The Raspberry Pi is equipped with one  SPI  bus that has 2 chip selects.  The SPI master driver is disabled by default on Raspbian. To enable it, use  raspi-config , or ensure the line  dtparam=spi=on  isn't commented out in  /boot/config.txt , and reboot. If the SPI driver was loaded, you should see the device  /dev/spidev0.0 .  The SPI bus is available on the P1 Header:  MOSI    P1-19\nMISO    P1-21\nSCLK    P1-23   P1-24    CE0\nGND     P1-25   P1-26    CE1",
            "title": "Overview"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#software",
            "text": "",
            "title": "Software"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#wiringpi",
            "text": "WiringPi includes a library which can make it easier to use the Raspberry Pi's on-board SPI interface. Accesses the hardware registers directly.  http://wiringpi.com/",
            "title": "WiringPi"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#bcm2835-library",
            "text": "This is a C library for Raspberry Pi (RPi). It provides access to GPIO and other IO functions on the Broadcom BCM 2835 chip. Accesses the hardware registers directly.  http://www.airspayce.com/mikem/bcm2835/",
            "title": "bcm2835 library"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#use-spidev-from-c",
            "text": "There's a loopback test program in the Linux documentation that can be used as a starting point. See the  Troubleshooting  section. Uses the Linux  spidev  driver to access the bus.",
            "title": "Use spidev from C"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#shell",
            "text": "# Write binary 1, 2 and 3  echo  -ne  \"\\x01\\x02\\x03\"  > /dev/spidev0.0",
            "title": "Shell"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#hardware",
            "text": "The BCM2835 on the Raspberry Pi has 3 SPI Controllers. Only the SPI0 controller is available on the header.\nChapter 10 in the  BCM2835 ARM Peripherals  datasheet describes this controller.",
            "title": "Hardware"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#master-modes",
            "text": "Signal name abbreviations  SCLK - Serial CLocK\nCE   - Chip Enable (often called Chip Select)\nMOSI - Master Out Slave In\nMISO - Master In Slave Out\nMOMI - Master Out Master In",
            "title": "Master modes"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#standard-mode",
            "text": "In Standard SPI master mode the peripheral implements the standard 3 wire serial protocol (SCLK, MOSI and MISO).",
            "title": "Standard mode"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#bidirectional-mode",
            "text": "In bidirectional SPI master mode the same SPI standard is implemented, except that a single wire is used for data (MOMI) instead of the two used in standard mode (MISO and MOSI). In this mode, the MOSI pin serves as MOMI pin.",
            "title": "Bidirectional mode"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#lossi-mode-low-speed-serial-interface",
            "text": "The LoSSI standard allows issuing of commands to peripherals (LCD) and to transfer data to and from them. LoSSI commands and parameters are 8 bits long, but an extra bit is used to indicate whether the byte is a command or parameter/data. This extra bit is set high for a data and low for a command. The resulting 9-bit value is serialized to the output. LoSSI is commonly used with  MIPI DBI  type C compatible LCD controllers.  Note:  Some commands trigger an automatic read by the SPI controller, so this mode can't be used as a multipurpose 9-bit SPI.",
            "title": "LoSSI mode (Low Speed Serial Interface)"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#transfer-modes",
            "text": "Polled  Interrupt  DMA",
            "title": "Transfer modes"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#speed",
            "text": "The CDIV (Clock Divider) field of the CLK register sets the SPI clock speed:  SCLK = Core Clock / CDIV\nIf CDIV is set to 0, the divisor is 65536. The divisor must be a power of 2. Odd numbers rounded down. The maximum SPI clock rate is of the APB clock.  Errata :  \"must be a power of 2\" probably should be \"must be a multiple of 2\"  See the  Linux driver  section for more info.",
            "title": "Speed"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#chip-select",
            "text": "Setup and Hold times related to the automatic assertion and de-assertion of the CS lines when operating in  DMA  mode are as follows:   The CS line will be asserted at least 3 core clock cycles before the msb of the first byte of the transfer.  The CS line will be de-asserted no earlier than 1 core clock cycle after the trailing edge of the final clock pulse.",
            "title": "Chip Select"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#linux-driver",
            "text": "The default Linux driver is  spi-bcm2708 .  The following information was valid 2014-07-05.",
            "title": "Linux driver"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#speed_1",
            "text": "The driver supports the following speeds:    cdiv    speed\n     2    125.0 MHz\n     4     62.5 MHz\n     8     31.2 MHz\n    16     15.6 MHz\n    32      7.8 MHz\n    64      3.9 MHz\n   128     1953 kHz\n   256      976 kHz\n   512      488 kHz\n  1024      244 kHz\n  2048      122 kHz\n  4096       61 kHz\n  8192     30.5 kHz\n 16384     15.2 kHz\n 32768     7629 Hz  When asking for say 24 MHz, the actual speed will be 15.6 MHz.  Forum post:  SPI has more speeds",
            "title": "Speed"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#supported-mode-bits",
            "text": "SPI_CPOL    - Clock polarity\nSPI_CPHA    - Clock phase\nSPI_CS_HIGH - Chip Select active high\nSPI_NO_CS   - 1 device per bus, no Chip Select\nSPI_3WIRE   - Bidirectional mode, data in and out pin shared  Bidirectional or \"3-wire\" mode is supported by the spi-bcm2835 kernel module. Please note that in this mode, either the tx or rx field of the spi_transfer struct must be a NULL pointer, since only half-duplex communication is possible. Otherwise, the transfer will fail. The spidev_test.c source code does not consider this correctly, and therefore does not work at all in 3-wire mode.",
            "title": "Supported Mode bits"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#supported-bits-per-word",
            "text": "8 - Normal  9 - This is supported using LoSSI mode.",
            "title": "Supported bits per word"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#transfer-modes_1",
            "text": "Only interrupt mode is supported.",
            "title": "Transfer modes"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#deprecated-warning",
            "text": "The following appears in the kernel log:  bcm2708_spi bcm2708_spi.0: master is unqueued, this is deprecated",
            "title": "Deprecated warning"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#spi-driver-latency",
            "text": "This  thread  discusses latency problems.",
            "title": "SPI driver latency"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#dma-capable-driver",
            "text": "This is a fork of spi-bcm2708 which enables DMA support for SPI client drivers that support DMA.  https://github.com/notro/spi-bcm2708 ( wiki )",
            "title": "DMA capable driver"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/hardware/raspberrypi/spi/README/index.html#loopback-test",
            "text": "This can be used to test SPI send and receive. Put a wire between MOSI and MISO. It does not test CE0 and CE1.  wget https://raw.githubusercontent.com/raspberrypi/linux/rpi-3.10.y/Documentation/spi/spidev_test.c\ngcc -o spidev_test spidev_test.c\n./spidev_test -D /dev/spidev0.0\nspi mode:  0 \nbits per word:  8 \nmax speed:  500000  Hz  ( 500  KHz ) \n\nFF FF FF FF FF FF 40   00   00   00   00   95 \nFF FF FF FF FF FF\nFF FF FF FF FF FF\nFF FF FF FF FF FF\nDE AD BE EF BA AD\nF0 0D",
            "title": "Loopback test"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html",
            "text": "USB\n\n\nPage Contents\n\n\n\n\nOverview\n  \n\n\nSupported Devices\n\n\nGeneral Limitations\n\n\nPort Power Limits\n\n\nKnown Issues\n\n\nTroubleshooting\n\n\n\n\n\n\nOverview\n\n\nThe Raspberry Pi Model B is equipped with two USB2.0 ports. These are connected to the LAN9512 combo hub/Ethernet chip IC3, which is itself a USB device connected to the single upstream USB port on BCM2835.\n\n\nOn the Model A, the single USB2.0 port is directly wired to BCM2835.\n\n\nThe USB ports enable the attachment of peripherals such as keyboards, mice, webcams that provide the Pi with additional functionality.\n\n\nThere are some differences between the USB hardware on the Raspberry Pi and the USB hardware on desktop computers or laptop/tablet devices.\n\n\nThe USB host port inside the Pi is an On-The-Go (OTG) host as the application processor powering the Pi, BCM2835, was originally intended to be used in the mobile market: i.e. as the single USB port on a phone for connection to a PC, or to a single device. In essence, the OTG hardware is simpler than the equivalent hardware on a PC.\n\n\nOTG in general supports communication to all types of USB device, but to provide an adequate level of functionality for most of the USB devices that one might plug into a Pi, the system software has to do more work.\n\n\n\n\nSupported devices\n\n\nIn general, every device supported by Linux is possible to use with the Pi, subject to a few caveats detailed further down. Linux has probably the most comprehensive driver database for legacy hardware of any operating system (it can lag behind for modern device support as it requires open-source drivers for Linux to recognise the device by default).\n\n\nIf you have a device and wish to use it with a Pi, then plug it in. Chances are that it'll \"just work\". If you are running in a graphical interface (such as the LXDE desktop environment in Raspbian), then it's likely that an icon or similar will pop up announcing the new device.\n\n\nIf the device doesn't appear to work, then refer to the Troubleshooting section below.\n\n\n\n\nGeneral limitations\n\n\nThe OTG hardware on Raspberry Pi has a simpler level of support for certain devices, which may present a higher software processing overhead. The Raspberry Pi also has only one root USB port: all traffic from all connected devices is funnelled down this bus, which operates at a maximum speed of 480mbps.\n\n\nThe USB specification defines three device speeds - Low, Full and High. Most mice and keyboards are Low-speed, most USB sound devices are Full-speed and most video devices (webcams or video capture) are High-speed.\n\n\nGenerally, there are no issues with connecting multiple High-speed USB devices to a Pi.\n\n\nThe software overhead incurred when talking to Low- and Full-speed devices means that there are soft limitations on the number of simultaneously active Low- and Full-speed devices. Small numbers of these types of devices connected to a Pi will cause no issues.\n\n\n\n\nPort Power Limits\n\n\nUSB devices have defined power requirements, in units of 100mA from 100mA to 500mA. The device advertises its own power requirements to the USB host when it is first connected. In theory, the actual power consumed by the device should not exceed its stated requirement.\n\n\nThe USB ports on a Raspberry Pi have a design loading of 100mA each - sufficient to drive \"low-power\" devices such as mice and keyboards. Devices such as WiFi adapters, USB hard drives, USB pen drives all consume much more current and should be powered from an external hub with its own power supply. While it is possible to plug a 500mA device into a Pi and have it work with a sufficiently powerful supply, reliable operation is not guaranteed.\n\n\nIn addition, hotplugging high-power devices into the Pi's USB ports may cause a brownout which can cause the Pi to reset.\n\n\nSee \nPower\n for more information.\n\n\n\n\nDevices with known issues\n\n\n1. Interoperability between the Raspberry Pi and USB3.0 hubs\n\n   There is an issue with USB3.0 hubs in conjunction with the use of Full- or Low-speed devices (most mice, most keyboards) and the Raspberry Pi. A bug in most USB3.0 hub hardware means that the Raspberry Pi cannot talk to Full- or Low-speed devices connected to a USB3.0 hub.\n\n\nUSB2.0 high-speed devices, including USB2.0 hubs, operate correctly when connected via a USB3.0 hub.\n\n\nAvoid connecting Low- or Full-speed devices into a USB3.0 hub. As a workaround, plug a USB2.0 hub into the downstream port of the USB3.0 hub and connect the low-speed device, or use a USB2.0 hub between the Pi and the USB3.0 hub, then plug low-speed devices into the USB2.0 hub.\n\n\n2. USB1.1 webcams\n\n   Old webcams may be Full-speed devices. Because these devices transfer a lot of data and incur additional software overhead, reliable operation is not guaranteed.\n\n   As a workaround, try to use the camera at a lower resolution.\n\n\n3. Esoteric USB sound cards\n\n  Expensive \"audiophile\" sound cards typically use far more bandwidth than is necessary to stream audio playback. Reliable operation with 96kHz/192kHz DACs is not guaranteed.\n\n  As a workaround, forcing the output stream to be CD quality (44.1kHz/48kHz 16-bit) will reduce the stream bandwidth to reliable levels.\n\n\n4. Single-TT USB hubs\n\n  USB2.0 and 3.0 hubs have a mechanism for talking to Full- or Low-speed devices connected to their downstream ports called a Transaction Translator. This device buffers high-speed requests from the host (i.e. the Pi) and transmits them at Full- or Low-speed to the downstream device. Two configurations of hub are allowed by the USB specification: Single-TT (one TT for all ports) and Multi-TT (one TT per port).\n\n  Because of the OTG hardware limitations, if too many Full- or Low-speed devices are plugged into a single-TT hub, unreliable operation of the devices may occur. It is recommended to use a Multi-TT hub to interface with multiple lower-speed devices.\n\n  As a workaround, spread lower-speed devices out between the Pi's own USB port and the single-TT hub.\n\n\n\n\nTroubleshooting\n\n\nIf your device doesn't work at all\n\n\nThe first step is to see if it is detected at all. There are two commands that can be entered into a terminal for this: \nlsusb\n and \ndmesg\n. The first will print out all devices attached to USB, whether they are actually recognised by a device driver or not, and the second will print out the kernel message buffer (which can be quite big after booting - try doing \nsudo dmesg -C\n then plug in your device and retype \ndmesg\n to see new messages).\n\n\nAs an example with a USB pendrive:\n\n\npi@raspberrypi ~ $ lsusb\nBus \n001\n Device \n002\n: ID \n0424\n:9512 Standard Microsystems Corp.\nBus \n001\n Device \n001\n: ID 1d6b:0002 Linux Foundation \n2\n.0 root hub\nBus \n001\n Device \n003\n: ID \n0424\n:ec00 Standard Microsystems Corp.\nBus \n001\n Device \n005\n: ID 05dc:a781 Lexar Media, Inc.\npi@raspberrypi ~ $ dmesg\n... Stuff that happened before ...\n\n[\n \n8904\n.228539\n]\n usb \n1\n-1.3: new high-speed USB device number \n5\n using dwc_otg\n\n[\n \n8904\n.332308\n]\n usb \n1\n-1.3: New USB device found, \nidVendor\n=\n05dc, \nidProduct\n=\na781\n\n[\n \n8904\n.332347\n]\n usb \n1\n-1.3: New USB device strings: \nMfr\n=\n1\n, \nProduct\n=\n2\n, \nSerialNumber\n=\n3\n\n\n[\n \n8904\n.332368\n]\n usb \n1\n-1.3: Product: JD Firefly\n\n[\n \n8904\n.332386\n]\n usb \n1\n-1.3: Manufacturer: Lexar\n\n[\n \n8904\n.332403\n]\n usb \n1\n-1.3: SerialNumber: AACU6B4JZVH31337\n\n[\n \n8904\n.336583\n]\n usb-storage \n1\n-1.3:1.0: USB Mass Storage device detected\n\n[\n \n8904\n.337483\n]\n scsi1 : usb-storage \n1\n-1.3:1.0\n\n[\n \n8908\n.114261\n]\n scsi \n1\n:0:0:0: Direct-Access     Lexar    JD Firefly       \n0100\n PQ: \n0\n ANSI: \n0\n CCS\n\n[\n \n8908\n.185048\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n \n4048896\n \n512\n-byte logical blocks: \n(\n2\n.07 GB/1.93 GiB\n)\n\n\n[\n \n8908\n.186152\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Write Protect is off\n\n[\n \n8908\n.186194\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Mode Sense: \n43\n \n00\n \n00\n \n00\n\n\n[\n \n8908\n.187274\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n No Caching mode page present\n\n[\n \n8908\n.187312\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Assuming drive cache: write through\n\n[\n \n8908\n.205534\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n No Caching mode page present\n\n[\n \n8908\n.205577\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Assuming drive cache: write through\n\n[\n \n8908\n.207226\n]\n  sda: sda1\n\n[\n \n8908\n.213652\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n No Caching mode page present\n\n[\n \n8908\n.213697\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Assuming drive cache: write through\n\n[\n \n8908\n.213724\n]\n sd \n1\n:0:0:0: \n[\nsda\n]\n Attached SCSI removable disk\n\n\n\n\n\nIn this case, there are no error messages in \ndmesg\n and the pendrive is detected by the usb-storage driver. If your device did not have a driver available, then typically only the first 6 new lines will appear in the dmesg printout.\n\n\nIf a device enumerates without any errors, but doesn't appear to do anything, then it is likely there are no drivers installed for it. Search around, based on the manufacturer's name for the device or the USB IDs that are displayed in lsusb (e.g. 05dc:a781). The device may not be supported with default Linux drivers - and you may need to download or compile your own third-party software.\n\n\nIf your device has intermittent behaviour\n\n\nPoor quality power is the most common cause of devices not working, disconnecting or generally being unreliable.  \n\n\n\n\nIf you are using an external powered hub, try swapping the power adapter supplied with the hub for another compatible power supply with the same voltage rating and polarity.\n\n\nCheck to see if the problem resolves itself if you remove other devices from the hub's downstream ports.\n\n\nTemporarily plug the device directly into the Pi and see if the behaviour improves.",
            "title": "USB"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#usb",
            "text": "",
            "title": "USB"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#page-contents",
            "text": "Overview     Supported Devices  General Limitations  Port Power Limits  Known Issues  Troubleshooting",
            "title": "Page Contents"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#overview",
            "text": "The Raspberry Pi Model B is equipped with two USB2.0 ports. These are connected to the LAN9512 combo hub/Ethernet chip IC3, which is itself a USB device connected to the single upstream USB port on BCM2835.  On the Model A, the single USB2.0 port is directly wired to BCM2835.  The USB ports enable the attachment of peripherals such as keyboards, mice, webcams that provide the Pi with additional functionality.  There are some differences between the USB hardware on the Raspberry Pi and the USB hardware on desktop computers or laptop/tablet devices.  The USB host port inside the Pi is an On-The-Go (OTG) host as the application processor powering the Pi, BCM2835, was originally intended to be used in the mobile market: i.e. as the single USB port on a phone for connection to a PC, or to a single device. In essence, the OTG hardware is simpler than the equivalent hardware on a PC.  OTG in general supports communication to all types of USB device, but to provide an adequate level of functionality for most of the USB devices that one might plug into a Pi, the system software has to do more work.",
            "title": "Overview"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#supported-devices",
            "text": "In general, every device supported by Linux is possible to use with the Pi, subject to a few caveats detailed further down. Linux has probably the most comprehensive driver database for legacy hardware of any operating system (it can lag behind for modern device support as it requires open-source drivers for Linux to recognise the device by default).  If you have a device and wish to use it with a Pi, then plug it in. Chances are that it'll \"just work\". If you are running in a graphical interface (such as the LXDE desktop environment in Raspbian), then it's likely that an icon or similar will pop up announcing the new device.  If the device doesn't appear to work, then refer to the Troubleshooting section below.",
            "title": "Supported devices"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#general-limitations",
            "text": "The OTG hardware on Raspberry Pi has a simpler level of support for certain devices, which may present a higher software processing overhead. The Raspberry Pi also has only one root USB port: all traffic from all connected devices is funnelled down this bus, which operates at a maximum speed of 480mbps.  The USB specification defines three device speeds - Low, Full and High. Most mice and keyboards are Low-speed, most USB sound devices are Full-speed and most video devices (webcams or video capture) are High-speed.  Generally, there are no issues with connecting multiple High-speed USB devices to a Pi.  The software overhead incurred when talking to Low- and Full-speed devices means that there are soft limitations on the number of simultaneously active Low- and Full-speed devices. Small numbers of these types of devices connected to a Pi will cause no issues.",
            "title": "General limitations"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#port-power-limits",
            "text": "USB devices have defined power requirements, in units of 100mA from 100mA to 500mA. The device advertises its own power requirements to the USB host when it is first connected. In theory, the actual power consumed by the device should not exceed its stated requirement.  The USB ports on a Raspberry Pi have a design loading of 100mA each - sufficient to drive \"low-power\" devices such as mice and keyboards. Devices such as WiFi adapters, USB hard drives, USB pen drives all consume much more current and should be powered from an external hub with its own power supply. While it is possible to plug a 500mA device into a Pi and have it work with a sufficiently powerful supply, reliable operation is not guaranteed.  In addition, hotplugging high-power devices into the Pi's USB ports may cause a brownout which can cause the Pi to reset.  See  Power  for more information.",
            "title": "Port Power Limits"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#devices-with-known-issues",
            "text": "1. Interoperability between the Raspberry Pi and USB3.0 hubs \n   There is an issue with USB3.0 hubs in conjunction with the use of Full- or Low-speed devices (most mice, most keyboards) and the Raspberry Pi. A bug in most USB3.0 hub hardware means that the Raspberry Pi cannot talk to Full- or Low-speed devices connected to a USB3.0 hub.  USB2.0 high-speed devices, including USB2.0 hubs, operate correctly when connected via a USB3.0 hub.  Avoid connecting Low- or Full-speed devices into a USB3.0 hub. As a workaround, plug a USB2.0 hub into the downstream port of the USB3.0 hub and connect the low-speed device, or use a USB2.0 hub between the Pi and the USB3.0 hub, then plug low-speed devices into the USB2.0 hub.  2. USB1.1 webcams \n   Old webcams may be Full-speed devices. Because these devices transfer a lot of data and incur additional software overhead, reliable operation is not guaranteed. \n   As a workaround, try to use the camera at a lower resolution.  3. Esoteric USB sound cards \n  Expensive \"audiophile\" sound cards typically use far more bandwidth than is necessary to stream audio playback. Reliable operation with 96kHz/192kHz DACs is not guaranteed. \n  As a workaround, forcing the output stream to be CD quality (44.1kHz/48kHz 16-bit) will reduce the stream bandwidth to reliable levels.  4. Single-TT USB hubs \n  USB2.0 and 3.0 hubs have a mechanism for talking to Full- or Low-speed devices connected to their downstream ports called a Transaction Translator. This device buffers high-speed requests from the host (i.e. the Pi) and transmits them at Full- or Low-speed to the downstream device. Two configurations of hub are allowed by the USB specification: Single-TT (one TT for all ports) and Multi-TT (one TT per port). \n  Because of the OTG hardware limitations, if too many Full- or Low-speed devices are plugged into a single-TT hub, unreliable operation of the devices may occur. It is recommended to use a Multi-TT hub to interface with multiple lower-speed devices. \n  As a workaround, spread lower-speed devices out between the Pi's own USB port and the single-TT hub.",
            "title": "Devices with known issues"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#troubleshooting",
            "text": "",
            "title": "Troubleshooting"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#if-your-device-doesnt-work-at-all",
            "text": "The first step is to see if it is detected at all. There are two commands that can be entered into a terminal for this:  lsusb  and  dmesg . The first will print out all devices attached to USB, whether they are actually recognised by a device driver or not, and the second will print out the kernel message buffer (which can be quite big after booting - try doing  sudo dmesg -C  then plug in your device and retype  dmesg  to see new messages).  As an example with a USB pendrive:  pi@raspberrypi ~ $ lsusb\nBus  001  Device  002 : ID  0424 :9512 Standard Microsystems Corp.\nBus  001  Device  001 : ID 1d6b:0002 Linux Foundation  2 .0 root hub\nBus  001  Device  003 : ID  0424 :ec00 Standard Microsystems Corp.\nBus  001  Device  005 : ID 05dc:a781 Lexar Media, Inc.\npi@raspberrypi ~ $ dmesg\n... Stuff that happened before ... [   8904 .228539 ]  usb  1 -1.3: new high-speed USB device number  5  using dwc_otg [   8904 .332308 ]  usb  1 -1.3: New USB device found,  idVendor = 05dc,  idProduct = a781 [   8904 .332347 ]  usb  1 -1.3: New USB device strings:  Mfr = 1 ,  Product = 2 ,  SerialNumber = 3  [   8904 .332368 ]  usb  1 -1.3: Product: JD Firefly [   8904 .332386 ]  usb  1 -1.3: Manufacturer: Lexar [   8904 .332403 ]  usb  1 -1.3: SerialNumber: AACU6B4JZVH31337 [   8904 .336583 ]  usb-storage  1 -1.3:1.0: USB Mass Storage device detected [   8904 .337483 ]  scsi1 : usb-storage  1 -1.3:1.0 [   8908 .114261 ]  scsi  1 :0:0:0: Direct-Access     Lexar    JD Firefly        0100  PQ:  0  ANSI:  0  CCS [   8908 .185048 ]  sd  1 :0:0:0:  [ sda ]   4048896   512 -byte logical blocks:  ( 2 .07 GB/1.93 GiB )  [   8908 .186152 ]  sd  1 :0:0:0:  [ sda ]  Write Protect is off [   8908 .186194 ]  sd  1 :0:0:0:  [ sda ]  Mode Sense:  43   00   00   00  [   8908 .187274 ]  sd  1 :0:0:0:  [ sda ]  No Caching mode page present [   8908 .187312 ]  sd  1 :0:0:0:  [ sda ]  Assuming drive cache: write through [   8908 .205534 ]  sd  1 :0:0:0:  [ sda ]  No Caching mode page present [   8908 .205577 ]  sd  1 :0:0:0:  [ sda ]  Assuming drive cache: write through [   8908 .207226 ]   sda: sda1 [   8908 .213652 ]  sd  1 :0:0:0:  [ sda ]  No Caching mode page present [   8908 .213697 ]  sd  1 :0:0:0:  [ sda ]  Assuming drive cache: write through [   8908 .213724 ]  sd  1 :0:0:0:  [ sda ]  Attached SCSI removable disk  In this case, there are no error messages in  dmesg  and the pendrive is detected by the usb-storage driver. If your device did not have a driver available, then typically only the first 6 new lines will appear in the dmesg printout.  If a device enumerates without any errors, but doesn't appear to do anything, then it is likely there are no drivers installed for it. Search around, based on the manufacturer's name for the device or the USB IDs that are displayed in lsusb (e.g. 05dc:a781). The device may not be supported with default Linux drivers - and you may need to download or compile your own third-party software.",
            "title": "If your device doesn't work at all"
        },
        {
            "location": "/hardware/raspberrypi/usb/README/index.html#if-your-device-has-intermittent-behaviour",
            "text": "Poor quality power is the most common cause of devices not working, disconnecting or generally being unreliable.     If you are using an external powered hub, try swapping the power adapter supplied with the hub for another compatible power supply with the same voltage rating and polarity.  Check to see if the problem resolves itself if you remove other devices from the hub's downstream ports.  Temporarily plug the device directly into the Pi and see if the behaviour improves.",
            "title": "If your device has intermittent behaviour"
        },
        {
            "location": "/hardware/sense-hat/README/index.html",
            "text": "Sense HAT\n\n\nInstallation\n\n\nIn order to work correctly, the Sense HAT requires an up-to-date kernel, I2C to be enabled, and a few libraries to get started.\n\n\n\n\n\n\nEnsure your APT package list is up-to-date:\n\n\nbash\nsudo apt-get update\n\n\n\n\n\n\nNext, install the sense-hat package which will ensure the kernel is up-to-date, enable I2C, and install the necessary libraries and programs:\n\n\nbash\nsudo apt-get install sense-hat\n\n\n\n\n\n\nFinally, a reboot may be required if I2C was disabled or the kernel was not up-to-date prior to the install:\n\n\nbash\nsudo reboot\n\n\n\n\n\n\nHardware\n\n\nThe schematics can be found \nhere\n.\n\n\nSoftware overview\n\n\nAfter installation, example code can be found under \n/usr/src/sense-hat/examples\n.\n\n\nThese can be copied to the user's home directory by running \ncp /usr/src/sense-hat/examples ~/ -a\n.\n\n\nThe C/C++ examples can be compiled by running \nmake\n in the appropriate directory.\n\n\nThe RTIMULibDrive11 example comes pre-compiled to help ensure everything works as intended. It can be launched by running \nRTIMULibDrive11\n and closed by pressing \nCtrl+c\n.\n\n\n\n\nPython sense-hat\n\n\nsense-hat\n is the officially supported library for the Sense HAT; it provides access to all of the on-board sensors and the LED matrix.\n\n\nComplete documentation can be found at \npythonhosted.org/sense-hat\n.\n\n\nRTIMULib\n\n\nRTIMULib\n is a C++ and Python library that makes it easy to use 9-dof and 10-dof IMUs with embedded Linux systems. A pre-calibrated settings file is provided in \n/etc/RTIMULib.ini\n, which is also copied and used by \nsense-hat\n. The included examples look for \nRTIMULib.ini\n in the current working directory, so you may wish to copy the file there to get more accurate data.\n\n\nOther\n\n\nLED matrix\n\n\nThe LED matrix is an RGB565 \nframebuffer\n with the id \"RPi-Sense FB\". The appropriate device node can be written to as a standard file or mmap-ed. The included 'snake' example shows how to access the framebuffer.\n\n\nJoystick\n\n\nThe joystick comes up as an input event device named \"Raspberry Pi Sense HAT Joystick\", mapped to the arrow keys and \nEnter\n. It should be supported by any library which is capable of handling inputs, or directly through the \nevdev interface\n. Suitable libraries include SDL, \npygame\n and \npython-evdev\n. The included 'snake' example shows how to access the joystick directly.\n\n\nCalibration\n\n\nTaken from this \nforum post\n.\n\n\nInstall the necessary software and run the calibration program as follows:\n\n\nsudo apt-get update\nsudo apt-get install octave -y\ncd\ncp /usr/share/librtimulib-utils/RTEllipsoidFit ./ -a\ncd RTEllipsoidFit\nRTIMULibCal\n\n\n\n\n\nYou will then see this menu:\n\n\nOptions are:\n\n  m - calibrate magnetometer with min/max\n  e - calibrate magnetometer with ellipsoid (do min/max first)\n  a - calibrate accelerometers\n  x - exit\n\nEnter option:\n\n\n\n\n\nPress lowercase \nm\n. The following message will then show; press any key to start.\n\n\n    Magnetometer min/max calibration\n    --------------------------------\n    Waggle the IMU chip around, ensuring that all six axes\n    (+x, -x, +y, -y and +z, -z) go through their extrema.\n    When all extrema have been achieved, enter 's' to save, 'r' to reset\n    or 'x' to abort and discard the data.\n\n    Press any key to start...\n\n\n\n\n\nAfter it starts, you will see something similar to this scrolling up the screen:\n\n\nMin x:  51.60  min y:  69.39  min z:  65.91\nMax x:  53.15  max y:  70.97  max z:  67.97\n\n\n\n\n\nFocus on the two lines at the very bottom of the screen, as these are the most recently posted measurements from the program.\nNow you have to move the Astro Pi around in every possible way you can think of. It helps if you unplug all non-essential cables to avoid clutter.\n\n\nTry and get a complete circle in each of the pitch, roll and yaw axes. Take care not to accidentally eject the SD card while doing this. Spend a few minutes moving the Astro Pi, and stop when you find that the numbers are not changing anymore.\n\n\nNow press lowercase \ns\n then lowercase \nx\n to exit the program. If you run the \nls\n command now, you'll see a new \nRTIMULib.ini\n file has been created.\n\n\nIn addition to those steps, you can also do the ellipsoid fit by performing the steps above, but pressing \ne\n instead of \nm\n.\n\n\nWhen you're done, copy the resulting \nRTIMULib.ini\n to /etc/ and remove the local copy in \n~/.config/sense_hat/\n:\n\n\nrm ~/.config/sense_hat/RTIMULib.ini\nsudo cp RTIMULib.ini /etc\n\n\n\n\n\nYou are now done.\n\n\nUpdating the AVR firmware\n\n\n...\n\n\nEEPROM data\n\n\nThese steps may not work on Raspberry Pi 2 Model B Rev 1.0 and Raspberry Pi 3 Model B boards. The firmware will take control of I2C0, causing the ID pins to be configured as inputs.\n\n\n\n\n\n\nEnable I2C0 and I2C1 by adding the following line to \n/boot/config.txt\n:\n\n\ndtparam=i2c_vc=on\ndtparam=i2c_arm=on\n\n\n\n\n\n\nEnter the following command to reboot:\n\n\nbash\nsudo systemctl reboot\n\n\n\n\n\n\nDownload and build the flash tool:\n\n\nbash\ngit clone https://github.com/raspberrypi/hats.git\ncd hats/eepromutils\nmake\n\n\n\n\n\n\nReading\n\n\n\n\n\n\nEEPROM data can be read with the following command:\n\n\nbash\nsudo ./eepflash.sh -f=sense_read.eep -t=24c32 -r\n\n\n\n\n\n\nWriting\n\n\nPlease note that this operation is potentially dangerous, and is not needed for the everyday user. The steps below are provided for debugging purposes only. If an error occurs, the HAT may no longer be automatically detected.\n\n\n\n\n\n\nDownload EEPROM settings and build the \n.eep\n binary:\n\n\nbash\nwget https://github.com/raspberrypi/rpi-sense/raw/master/eeprom/eeprom_settings.txt -O sense_eeprom.txt\n./eepmake sense_eeprom.txt sense.eep /boot/overlays/rpi-sense-overlay.dtb\n\n\n\n\n\n\nDisable write protection:\n\n\nbash\ni2cset -y -f 1 0x46 0xf3 1\n\n\n\n\n\n\nWrite the EEPROM data:\n\n\n```bash\nsudo ./eepflash.sh -f=sense.eep -t=24c32 -w\n\n\n```\n\n\n\n\n\n\nRe-enable write protection:\n\n\nbash\ni2cset -y -f 1 0x46 0xf3 0",
            "title": "Sense HAT"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#sense-hat",
            "text": "",
            "title": "Sense HAT"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#installation",
            "text": "In order to work correctly, the Sense HAT requires an up-to-date kernel, I2C to be enabled, and a few libraries to get started.    Ensure your APT package list is up-to-date:  bash\nsudo apt-get update    Next, install the sense-hat package which will ensure the kernel is up-to-date, enable I2C, and install the necessary libraries and programs:  bash\nsudo apt-get install sense-hat    Finally, a reboot may be required if I2C was disabled or the kernel was not up-to-date prior to the install:  bash\nsudo reboot",
            "title": "Installation"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#hardware",
            "text": "The schematics can be found  here .",
            "title": "Hardware"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#software-overview",
            "text": "After installation, example code can be found under  /usr/src/sense-hat/examples .  These can be copied to the user's home directory by running  cp /usr/src/sense-hat/examples ~/ -a .  The C/C++ examples can be compiled by running  make  in the appropriate directory.  The RTIMULibDrive11 example comes pre-compiled to help ensure everything works as intended. It can be launched by running  RTIMULibDrive11  and closed by pressing  Ctrl+c .",
            "title": "Software overview"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#python-sense-hat",
            "text": "sense-hat  is the officially supported library for the Sense HAT; it provides access to all of the on-board sensors and the LED matrix.  Complete documentation can be found at  pythonhosted.org/sense-hat .",
            "title": "Python sense-hat"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#rtimulib",
            "text": "RTIMULib  is a C++ and Python library that makes it easy to use 9-dof and 10-dof IMUs with embedded Linux systems. A pre-calibrated settings file is provided in  /etc/RTIMULib.ini , which is also copied and used by  sense-hat . The included examples look for  RTIMULib.ini  in the current working directory, so you may wish to copy the file there to get more accurate data.",
            "title": "RTIMULib"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#other",
            "text": "",
            "title": "Other"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#led-matrix",
            "text": "The LED matrix is an RGB565  framebuffer  with the id \"RPi-Sense FB\". The appropriate device node can be written to as a standard file or mmap-ed. The included 'snake' example shows how to access the framebuffer.",
            "title": "LED matrix"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#joystick",
            "text": "The joystick comes up as an input event device named \"Raspberry Pi Sense HAT Joystick\", mapped to the arrow keys and  Enter . It should be supported by any library which is capable of handling inputs, or directly through the  evdev interface . Suitable libraries include SDL,  pygame  and  python-evdev . The included 'snake' example shows how to access the joystick directly.",
            "title": "Joystick"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#calibration",
            "text": "Taken from this  forum post .  Install the necessary software and run the calibration program as follows:  sudo apt-get update\nsudo apt-get install octave -y\ncd\ncp /usr/share/librtimulib-utils/RTEllipsoidFit ./ -a\ncd RTEllipsoidFit\nRTIMULibCal  You will then see this menu:  Options are:\n\n  m - calibrate magnetometer with min/max\n  e - calibrate magnetometer with ellipsoid (do min/max first)\n  a - calibrate accelerometers\n  x - exit\n\nEnter option:  Press lowercase  m . The following message will then show; press any key to start.      Magnetometer min/max calibration\n    --------------------------------\n    Waggle the IMU chip around, ensuring that all six axes\n    (+x, -x, +y, -y and +z, -z) go through their extrema.\n    When all extrema have been achieved, enter 's' to save, 'r' to reset\n    or 'x' to abort and discard the data.\n\n    Press any key to start...  After it starts, you will see something similar to this scrolling up the screen:  Min x:  51.60  min y:  69.39  min z:  65.91\nMax x:  53.15  max y:  70.97  max z:  67.97  Focus on the two lines at the very bottom of the screen, as these are the most recently posted measurements from the program.\nNow you have to move the Astro Pi around in every possible way you can think of. It helps if you unplug all non-essential cables to avoid clutter.  Try and get a complete circle in each of the pitch, roll and yaw axes. Take care not to accidentally eject the SD card while doing this. Spend a few minutes moving the Astro Pi, and stop when you find that the numbers are not changing anymore.  Now press lowercase  s  then lowercase  x  to exit the program. If you run the  ls  command now, you'll see a new  RTIMULib.ini  file has been created.  In addition to those steps, you can also do the ellipsoid fit by performing the steps above, but pressing  e  instead of  m .  When you're done, copy the resulting  RTIMULib.ini  to /etc/ and remove the local copy in  ~/.config/sense_hat/ :  rm ~/.config/sense_hat/RTIMULib.ini\nsudo cp RTIMULib.ini /etc  You are now done.",
            "title": "Calibration"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#updating-the-avr-firmware",
            "text": "...",
            "title": "Updating the AVR firmware"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#eeprom-data",
            "text": "These steps may not work on Raspberry Pi 2 Model B Rev 1.0 and Raspberry Pi 3 Model B boards. The firmware will take control of I2C0, causing the ID pins to be configured as inputs.    Enable I2C0 and I2C1 by adding the following line to  /boot/config.txt :  dtparam=i2c_vc=on\ndtparam=i2c_arm=on    Enter the following command to reboot:  bash\nsudo systemctl reboot    Download and build the flash tool:  bash\ngit clone https://github.com/raspberrypi/hats.git\ncd hats/eepromutils\nmake",
            "title": "EEPROM data"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#reading",
            "text": "EEPROM data can be read with the following command:  bash\nsudo ./eepflash.sh -f=sense_read.eep -t=24c32 -r",
            "title": "Reading"
        },
        {
            "location": "/hardware/sense-hat/README/index.html#writing",
            "text": "Please note that this operation is potentially dangerous, and is not needed for the everyday user. The steps below are provided for debugging purposes only. If an error occurs, the HAT may no longer be automatically detected.    Download EEPROM settings and build the  .eep  binary:  bash\nwget https://github.com/raspberrypi/rpi-sense/raw/master/eeprom/eeprom_settings.txt -O sense_eeprom.txt\n./eepmake sense_eeprom.txt sense.eep /boot/overlays/rpi-sense-overlay.dtb    Disable write protection:  bash\ni2cset -y -f 1 0x46 0xf3 1    Write the EEPROM data:  ```bash\nsudo ./eepflash.sh -f=sense.eep -t=24c32 -w  ```    Re-enable write protection:  bash\ni2cset -y -f 1 0x46 0xf3 0",
            "title": "Writing"
        },
        {
            "location": "/installation/README/index.html",
            "text": "Installation\n\n\nSome simple guides to setting up the software on your Raspberry Pi.\n\n\nBeginners should start with \nNOOBS\n, which gives the user a choice of operating system from the standard distributions. The recommended distribution for normal use is Raspbian. Alternatives are available, such as LibreELEC (Kodi media centre) or Arch Linux.\n\n\nContents\n\n\n\n\nNOOBS\n\n\nInstalling images\n\n\nSD Cards",
            "title": "Installation"
        },
        {
            "location": "/installation/README/index.html#installation",
            "text": "Some simple guides to setting up the software on your Raspberry Pi.  Beginners should start with  NOOBS , which gives the user a choice of operating system from the standard distributions. The recommended distribution for normal use is Raspbian. Alternatives are available, such as LibreELEC (Kodi media centre) or Arch Linux.",
            "title": "Installation"
        },
        {
            "location": "/installation/README/index.html#contents",
            "text": "NOOBS  Installing images  SD Cards",
            "title": "Contents"
        },
        {
            "location": "/installation/noobs/index.html",
            "text": "NOOBS\n\n\nNew Out Of Box Software (NOOBS)\n is an easy operating system installation manager for the Raspberry Pi.\n\n\n\n\nHow to get NOOBS\n\n\nBuy a pre-installed SD card\n\n\nSD cards with NOOBS preinstalled are available from many of our distributors and independent retailers, including \nPimoroni\n, \nAdafruit\n, and \nPi Hut\n.\n\n\nDownload\n\n\nAlternatively, NOOBS is available for download on the Raspberry Pi website: \nraspberrypi.org/downloads\n\n\nHow to install NOOBS on an SD card\n\n\nOnce you've downloaded the NOOBS zip file, you'll need to copy the contents to a formatted SD card on your computer.\n\n\nTo set up a blank SD card with NOOBS:\n\n\n\n\nFormat an SD card which is 8GB or larger as FAT. See the instructions given below.\n\n\nDownload and extract the files from the NOOBS zip file.\n\n\nCopy the extracted files onto the SD card that you just formatted, so that this file is at the root directory of the SD card. Please note that in some cases it may extract the files into a folder; if this is the case, then please copy across the files from inside the folder rather than the folder itself.\n\n\nOn first boot, the \"RECOVERY\" FAT partition will be automatically resized to a minimum, and a list of OSes that are available to install will be displayed.\n\n\n\n\nHow to format an SD card as FAT\n\n\nNote:\n If you're formatting an SD (or micro SD) card that has a capacity over 32GB (i.e. 64GB and above), then see the separate \nSDXC formatting\n instructions.\n\n\nWindows\n\n\nIf you are a Windows user, we recommend formatting your SD card using the SD Association's Formatting Tool, which can be downloaded from \nsdcard.org\n. Instructions for using the tool are available on the same site.\n\n\nMac OS\n\n\nThe \nSD Association's Formatting Tool\n is also available for Mac users, although the default OS X Disk Utility is also capable of formatting the entire disk. To do this, select the SD card volume and choose \nErase\n with \nMS-DOS\n format.\n\n\nLinux\n\n\nFor Linux users we recommend \ngparted\n (or the command line version \nparted\n). Norman Dunbar has written up \ninstructions\n for Linux users.\n\n\nWhat's included in NOOBS\n\n\nThe following operating systems are currently included in NOOBS:\n\n\n\n\nRaspbian\n\n\nPidora\n\n\nLibreELEC\n\n\nOSMC\n\n\nRISC OS\n\n\nArch Linux\n\n\n\n\nAs of NOOBS v1.3.10 (September 2014), only Raspbian is installed by default in NOOBS. The others can be installed with a network connection.\n\n\nNOOBS and NOOBS Lite\n\n\nNOOBS is available in two forms: offline and network install, or network install only.\n\n\nThe full version has Raspbian included, so it can be installed from the SD card while offline, whereas using NOOBS Lite or installing any other operating system requires an internet connection.\n\n\nNote that the operating system image on the full version can be outdated if a new version of the OS is released, but if connected to the internet you will be shown the option of downloading the latest version if there is a newer one available.\n\n\nNOOBS development\n\n\nLatest NOOBS release\n\n\nThe latest NOOBS release is \nv2.4.5\n, released on \n29th November 2017\n.\n\n\n(From NOOBS v1.4.0 onwards, NOOBS Lite only shares the first two digits of the version number, i.e. v1.4)\n\n\nNOOBS documentation\n\n\nMore comprehensive documentation, including more advanced configuration of NOOBS, is available on \nGitHub\n.\n\n\nNOOBS source code\n\n\nSee the NOOBS source code on \nGitHub\n.",
            "title": "NOOBS"
        },
        {
            "location": "/installation/noobs/index.html#noobs",
            "text": "New Out Of Box Software (NOOBS)  is an easy operating system installation manager for the Raspberry Pi.",
            "title": "NOOBS"
        },
        {
            "location": "/installation/noobs/index.html#how-to-get-noobs",
            "text": "",
            "title": "How to get NOOBS"
        },
        {
            "location": "/installation/noobs/index.html#buy-a-pre-installed-sd-card",
            "text": "SD cards with NOOBS preinstalled are available from many of our distributors and independent retailers, including  Pimoroni ,  Adafruit , and  Pi Hut .",
            "title": "Buy a pre-installed SD card"
        },
        {
            "location": "/installation/noobs/index.html#download",
            "text": "Alternatively, NOOBS is available for download on the Raspberry Pi website:  raspberrypi.org/downloads",
            "title": "Download"
        },
        {
            "location": "/installation/noobs/index.html#how-to-install-noobs-on-an-sd-card",
            "text": "Once you've downloaded the NOOBS zip file, you'll need to copy the contents to a formatted SD card on your computer.  To set up a blank SD card with NOOBS:   Format an SD card which is 8GB or larger as FAT. See the instructions given below.  Download and extract the files from the NOOBS zip file.  Copy the extracted files onto the SD card that you just formatted, so that this file is at the root directory of the SD card. Please note that in some cases it may extract the files into a folder; if this is the case, then please copy across the files from inside the folder rather than the folder itself.  On first boot, the \"RECOVERY\" FAT partition will be automatically resized to a minimum, and a list of OSes that are available to install will be displayed.",
            "title": "How to install NOOBS on an SD card"
        },
        {
            "location": "/installation/noobs/index.html#how-to-format-an-sd-card-as-fat",
            "text": "Note:  If you're formatting an SD (or micro SD) card that has a capacity over 32GB (i.e. 64GB and above), then see the separate  SDXC formatting  instructions.",
            "title": "How to format an SD card as FAT"
        },
        {
            "location": "/installation/noobs/index.html#windows",
            "text": "If you are a Windows user, we recommend formatting your SD card using the SD Association's Formatting Tool, which can be downloaded from  sdcard.org . Instructions for using the tool are available on the same site.",
            "title": "Windows"
        },
        {
            "location": "/installation/noobs/index.html#mac-os",
            "text": "The  SD Association's Formatting Tool  is also available for Mac users, although the default OS X Disk Utility is also capable of formatting the entire disk. To do this, select the SD card volume and choose  Erase  with  MS-DOS  format.",
            "title": "Mac OS"
        },
        {
            "location": "/installation/noobs/index.html#linux",
            "text": "For Linux users we recommend  gparted  (or the command line version  parted ). Norman Dunbar has written up  instructions  for Linux users.",
            "title": "Linux"
        },
        {
            "location": "/installation/noobs/index.html#whats-included-in-noobs",
            "text": "The following operating systems are currently included in NOOBS:   Raspbian  Pidora  LibreELEC  OSMC  RISC OS  Arch Linux   As of NOOBS v1.3.10 (September 2014), only Raspbian is installed by default in NOOBS. The others can be installed with a network connection.",
            "title": "What's included in NOOBS"
        },
        {
            "location": "/installation/noobs/index.html#noobs-and-noobs-lite",
            "text": "NOOBS is available in two forms: offline and network install, or network install only.  The full version has Raspbian included, so it can be installed from the SD card while offline, whereas using NOOBS Lite or installing any other operating system requires an internet connection.  Note that the operating system image on the full version can be outdated if a new version of the OS is released, but if connected to the internet you will be shown the option of downloading the latest version if there is a newer one available.",
            "title": "NOOBS and NOOBS Lite"
        },
        {
            "location": "/installation/noobs/index.html#noobs-development",
            "text": "",
            "title": "NOOBS development"
        },
        {
            "location": "/installation/noobs/index.html#latest-noobs-release",
            "text": "The latest NOOBS release is  v2.4.5 , released on  29th November 2017 .  (From NOOBS v1.4.0 onwards, NOOBS Lite only shares the first two digits of the version number, i.e. v1.4)",
            "title": "Latest NOOBS release"
        },
        {
            "location": "/installation/noobs/index.html#noobs-documentation",
            "text": "More comprehensive documentation, including more advanced configuration of NOOBS, is available on  GitHub .",
            "title": "NOOBS documentation"
        },
        {
            "location": "/installation/noobs/index.html#noobs-source-code",
            "text": "See the NOOBS source code on  GitHub .",
            "title": "NOOBS source code"
        },
        {
            "location": "/installation/sd-cards/index.html",
            "text": "SD cards\n\n\nThe Raspberry Pi should work with any compatible SD card, although there are some guidelines that should be followed:\n\n\nSD card size (capacity).\n\n\nFor installation of NOOBS or the image installation of Raspbian, the minimum recommended card size is 8GB. For Raspbian Lite image installations we recommend a minimum of 4GB. Some distributions, specifically LibreELEC and Arch, can run on much smaller cards. If you're planning to use a card of 64GB or more with NOOBS, see \nthis page\n first.\n\n\nSD card class.\n\n\nThe card class determines the sustained write speed for the card; a class 4 card will be able to write at 4MB/s, whereas a class 10 should be able to attain 10 MB/s. However, it should be noted that this does not mean a class 10 card will outperform a class 4 card for general usage, because often this write speed is achieved at the cost of read speed and increased seek times.\n\n\nSD card physical size.\n\n\nThe original \nRaspberry Pi Model A\n and \nRaspberry Pi Model B\n require full-size SD cards. The newer \nRaspberry Pi Model A+\n, \nRaspberry Pi Model B+\n, \nRaspberry Pi 2 Model B\n, \nRaspberry Pi Zero\n, and \nRaspberry Pi 3 Model B\n require micro SD cards.\n\n\nTroubleshooting\n\n\nWe recommend buying the Raspberry Pi SD card which is available \nhere\n, as well as from other retailers; this is an 8GB class 6 micro SD card (with a full-size SD adapter) that outperforms almost all other SD cards on the market and is a good value solution.\n\n\nIf you are having trouble with corruption of your SD cards, make sure you follow these steps:\n\n\n\n\nMake sure you are using a genuine SD card. There are many cheap SD cards available which are actually smaller than advertised or which will not last very long.\n\n\nMake sure you are using a good quality power supply. You can check your power supply by measuring the voltage between TP1 and TP2 on the Raspberry Pi; if this drops below 4.75V when doing complex tasks then it is most likely unsuitable.\n\n\nMake sure you are using a good quality USB cable for the power supply. When using a lower quality power supply, the TP1->TP2 voltage can drop below 4.75V. This is generally due to the resistance of the wires in the USB power cable; to save money, USB cables have as little copper in them as possible, and as much as 1V (or 1W) can be lost over the length of the cable.\n\n\nMake sure you are shutting your Raspberry Pi down properly before powering it off. Type \nsudo halt\n and wait for the Pi to signal it is ready to be powered off by flashing the activity LED.\n\n\nFinally, corruption has been observed if you are overclocking the Pi. This problem has been fixed previously, although the workaround used may mean that it can still happen. If after checking the steps above you are still having problems with corruption, please let us know.",
            "title": "SD cards"
        },
        {
            "location": "/installation/sd-cards/index.html#sd-cards",
            "text": "The Raspberry Pi should work with any compatible SD card, although there are some guidelines that should be followed:",
            "title": "SD cards"
        },
        {
            "location": "/installation/sd-cards/index.html#sd-card-size-capacity",
            "text": "For installation of NOOBS or the image installation of Raspbian, the minimum recommended card size is 8GB. For Raspbian Lite image installations we recommend a minimum of 4GB. Some distributions, specifically LibreELEC and Arch, can run on much smaller cards. If you're planning to use a card of 64GB or more with NOOBS, see  this page  first.",
            "title": "SD card size (capacity)."
        },
        {
            "location": "/installation/sd-cards/index.html#sd-card-class",
            "text": "The card class determines the sustained write speed for the card; a class 4 card will be able to write at 4MB/s, whereas a class 10 should be able to attain 10 MB/s. However, it should be noted that this does not mean a class 10 card will outperform a class 4 card for general usage, because often this write speed is achieved at the cost of read speed and increased seek times.",
            "title": "SD card class."
        },
        {
            "location": "/installation/sd-cards/index.html#sd-card-physical-size",
            "text": "The original  Raspberry Pi Model A  and  Raspberry Pi Model B  require full-size SD cards. The newer  Raspberry Pi Model A+ ,  Raspberry Pi Model B+ ,  Raspberry Pi 2 Model B ,  Raspberry Pi Zero , and  Raspberry Pi 3 Model B  require micro SD cards.",
            "title": "SD card physical size."
        },
        {
            "location": "/installation/sd-cards/index.html#troubleshooting",
            "text": "We recommend buying the Raspberry Pi SD card which is available  here , as well as from other retailers; this is an 8GB class 6 micro SD card (with a full-size SD adapter) that outperforms almost all other SD cards on the market and is a good value solution.  If you are having trouble with corruption of your SD cards, make sure you follow these steps:   Make sure you are using a genuine SD card. There are many cheap SD cards available which are actually smaller than advertised or which will not last very long.  Make sure you are using a good quality power supply. You can check your power supply by measuring the voltage between TP1 and TP2 on the Raspberry Pi; if this drops below 4.75V when doing complex tasks then it is most likely unsuitable.  Make sure you are using a good quality USB cable for the power supply. When using a lower quality power supply, the TP1->TP2 voltage can drop below 4.75V. This is generally due to the resistance of the wires in the USB power cable; to save money, USB cables have as little copper in them as possible, and as much as 1V (or 1W) can be lost over the length of the cable.  Make sure you are shutting your Raspberry Pi down properly before powering it off. Type  sudo halt  and wait for the Pi to signal it is ready to be powered off by flashing the activity LED.  Finally, corruption has been observed if you are overclocking the Pi. This problem has been fixed previously, although the workaround used may mean that it can still happen. If after checking the steps above you are still having problems with corruption, please let us know.",
            "title": "Troubleshooting"
        },
        {
            "location": "/installation/sdxc_formatting/index.html",
            "text": "Formatting an SDXC card for use with NOOBS\n\n\nAccording to the \nSD specifications\n, any SD card larger than 32GB is an SDXC card and has to be formatted with the exFAT filesystem. This means the official SD Formatter tool will \nalways\n format cards that are 64GB or larger as exFAT.\n\n\nThe Raspberry Pi's bootloader, built into the GPU and non-updateable, only has support for reading from FAT filesystems (both FAT16 and FAT32), and is unable to boot from an exFAT filesystem. So if you want to use NOOBS on a card that is 64GB or larger, you need to reformat it as FAT32 first before copying the NOOBS files to it.\n\n\nLinux and Mac OS\n\n\nThe standard formatting tools built into these operating systems are able to create FAT32 partitions; they might also be labelled as FAT or MS-DOS. Simply delete the existing exFAT partition and create and format a new FAT32 primary partition, before proceeding with the rest of the \nNOOBS instructions\n. On a Mac, this means using the built-in Disk Utility application.\n\n\nWindows\n\n\nThe standard formatting tools built into Windows are limited, as they only allow partitions up to 32GB to be formatted as FAT32, so to format a 64GB partition as FAT32 you need to use a third-party formatting tool. A simple tool to do this is \nFAT32 Format\n which downloads as a single file named \nguiformat.exe\n - no installation is necessary.\n\n\nRun the \nSD Formatter\n tool first with \"FORMAT SIZE ADJUSTMENT\" set to \"ON\", to ensure that any other partitions on the SD card are deleted. Then run the FAT32 Format (guiformat.exe) tool, ensure you choose the correct drive letter, leave the other options at their default settings, and click \"Start\". After it has finished, you can proceed with the rest of the \nNOOBS instructions\n.\n\n\nIf the FAT32 Format tool doesn't work for you, alternative options are \nMiniTool Partition Wizard Free Edition\n and \nEaseUS Partition Master Free\n which are \"home user\" versions of fully featured partition editor tools, and so not as straightforward to use.",
            "title": "Formatting an SDXC card for use with NOOBS"
        },
        {
            "location": "/installation/sdxc_formatting/index.html#formatting-an-sdxc-card-for-use-with-noobs",
            "text": "According to the  SD specifications , any SD card larger than 32GB is an SDXC card and has to be formatted with the exFAT filesystem. This means the official SD Formatter tool will  always  format cards that are 64GB or larger as exFAT.  The Raspberry Pi's bootloader, built into the GPU and non-updateable, only has support for reading from FAT filesystems (both FAT16 and FAT32), and is unable to boot from an exFAT filesystem. So if you want to use NOOBS on a card that is 64GB or larger, you need to reformat it as FAT32 first before copying the NOOBS files to it.",
            "title": "Formatting an SDXC card for use with NOOBS"
        },
        {
            "location": "/installation/sdxc_formatting/index.html#linux-and-mac-os",
            "text": "The standard formatting tools built into these operating systems are able to create FAT32 partitions; they might also be labelled as FAT or MS-DOS. Simply delete the existing exFAT partition and create and format a new FAT32 primary partition, before proceeding with the rest of the  NOOBS instructions . On a Mac, this means using the built-in Disk Utility application.",
            "title": "Linux and Mac OS"
        },
        {
            "location": "/installation/sdxc_formatting/index.html#windows",
            "text": "The standard formatting tools built into Windows are limited, as they only allow partitions up to 32GB to be formatted as FAT32, so to format a 64GB partition as FAT32 you need to use a third-party formatting tool. A simple tool to do this is  FAT32 Format  which downloads as a single file named  guiformat.exe  - no installation is necessary.  Run the  SD Formatter  tool first with \"FORMAT SIZE ADJUSTMENT\" set to \"ON\", to ensure that any other partitions on the SD card are deleted. Then run the FAT32 Format (guiformat.exe) tool, ensure you choose the correct drive letter, leave the other options at their default settings, and click \"Start\". After it has finished, you can proceed with the rest of the  NOOBS instructions .  If the FAT32 Format tool doesn't work for you, alternative options are  MiniTool Partition Wizard Free Edition  and  EaseUS Partition Master Free  which are \"home user\" versions of fully featured partition editor tools, and so not as straightforward to use.",
            "title": "Windows"
        },
        {
            "location": "/installation/installing-images/README/index.html",
            "text": "Installing operating system images\n\n\nThis resource explains how to install a Raspberry Pi operating system image on an SD card. You will need another computer with an SD card reader to install the image.\n\n\nWe recommend most users download \nNOOBS\n, which is designed to be very easy to use. However, more advanced users looking to install a particular image should use this guide.\n\n\nDownload the image\n\n\nOfficial images for recommended operating systems are available to download from the Raspberry Pi website \nDownloads page\n.\n\n\nAlternative distributions are available from third-party vendors.\n\n\nIf you're not using Etcher (see below), you'll need to unzip \n.zip\n downloads to get the image file (\n.img\n) to write to your SD card.\n\n\nNote\n: the Raspbian with PIXEL image contained in the ZIP archive is over 4GB in size and uses the \nZIP64\n format. To uncompress the archive, a unzip tool that supports ZIP64 is required. The following zip tools support ZIP64:\n\n\n\n\n7-Zip\n (Windows)\n\n\nThe Unarchiver\n (Mac)\n\n\nUnzip\n (Linux)\n\n\n\n\nWriting an image to the SD card\n\n\nYou will need to use an image writing tool to install the image you have downloaded on your SD card.\n\n\nEtcher\n is a graphical SD card writing tool that works on Mac OS, Linux and Windows, and is the easiest option for most users. Etcher also supports writing images directly from the zip file, without any unzipping required. To write your image with Etcher:\n\n\n\n\nDownload \nEtcher\n and install it.\n\n\nConnect an SD card reader with the SD card inside.\n\n\nOpen Etcher and select from your hard drive the Raspberry Pi \n.img\n or \n.zip\n file you wish to write to the SD card.\n\n\nSelect the SD card you wish to write your image to.\n\n\nReview your selections and click 'Flash!' to begin writing data to the SD card.\n\n\n\n\nFor more advanced control of this process, see our system-specific guides:\n\n\n\n\nLinux\n\n\nMac OS\n\n\nWindows",
            "title": "Installing operating system images"
        },
        {
            "location": "/installation/installing-images/README/index.html#installing-operating-system-images",
            "text": "This resource explains how to install a Raspberry Pi operating system image on an SD card. You will need another computer with an SD card reader to install the image.  We recommend most users download  NOOBS , which is designed to be very easy to use. However, more advanced users looking to install a particular image should use this guide.",
            "title": "Installing operating system images"
        },
        {
            "location": "/installation/installing-images/README/index.html#download-the-image",
            "text": "Official images for recommended operating systems are available to download from the Raspberry Pi website  Downloads page .  Alternative distributions are available from third-party vendors.  If you're not using Etcher (see below), you'll need to unzip  .zip  downloads to get the image file ( .img ) to write to your SD card.  Note : the Raspbian with PIXEL image contained in the ZIP archive is over 4GB in size and uses the  ZIP64  format. To uncompress the archive, a unzip tool that supports ZIP64 is required. The following zip tools support ZIP64:   7-Zip  (Windows)  The Unarchiver  (Mac)  Unzip  (Linux)",
            "title": "Download the image"
        },
        {
            "location": "/installation/installing-images/README/index.html#writing-an-image-to-the-sd-card",
            "text": "You will need to use an image writing tool to install the image you have downloaded on your SD card.  Etcher  is a graphical SD card writing tool that works on Mac OS, Linux and Windows, and is the easiest option for most users. Etcher also supports writing images directly from the zip file, without any unzipping required. To write your image with Etcher:   Download  Etcher  and install it.  Connect an SD card reader with the SD card inside.  Open Etcher and select from your hard drive the Raspberry Pi  .img  or  .zip  file you wish to write to the SD card.  Select the SD card you wish to write your image to.  Review your selections and click 'Flash!' to begin writing data to the SD card.   For more advanced control of this process, see our system-specific guides:   Linux  Mac OS  Windows",
            "title": "Writing an image to the SD card"
        },
        {
            "location": "/installation/installing-images/linux/index.html",
            "text": "Installing operating system images on Linux\n\n\nEtcher\n is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for more advanced options on Linux, you can use the standard command line tools below.\n\n\nNote\n: use of the \ndd\n tool can overwrite any partition of your machine. If you specify the wrong device in the instructions below, you could delete your primary Linux partition. Please be careful.\n\n\nDiscovering the SD card mountpoint and unmounting it\n\n\n\n\n\n\nRun \ndf -h\n to see which devices are currently mounted.\n\n\n\n\n\n\nIf your computer has a slot for SD cards, insert the card. If not, insert the card into an SD card reader, then connect the reader to your computer.\n\n\n\n\n\n\nRun \ndf -h\n again. The new device that has appeared is your SD card. If no device appears, then your system is not automounting devices. In this case, you will need to search for the device name using another method. The \ndmesg | tail\n command will display the most recent system messages, which should contain information on the naming of the SD card device. The naming of the device will follow the format described in the next paragraph. Note that if the SD card was not automounted, you do not need to unmount later.\n\n\n\n\n\n\nThe left column of the results from \ndf -h\n command gives the device name of your SD card. It will be listed as something like \n/dev/mmcblk0p1\n or \n/dev/sdX1\n, where X is a lower case letter indicating the device.  The last part (\np1\n or \n1\n respectively) is the partition number. You want to write to the whole SD card, not just one partition. You therefore need to remove that section from the name. You should see something like \n/dev/mmcblk0\n or \n/dev/sdX\n as the device name for the whole SD card. Note that the SD card can show up more than once in the output of \ndf\n. It will do this if you have previously written a Raspberry Pi image to this SD card, because the Raspberry Pi SD images have more than one partition.\n\n\n\n\n\n\nNow you have noted the device name, you need to unmount it so that files can't be read or written to the SD card while you are copying over the SD image.\n\n\n\n\n\n\nRun \numount /dev/sdX1\n, replacing \nsdX1\n with whatever your SD card's device name is, including the partition number.\n\n\n\n\n\n\nIf your SD card shows up more than once in the output of \ndf\n, this shows that the card has multiple partitions. You should unmount all of these partitions.\n\n\n\n\n\n\nCopying the image to the SD card\n\n\n\n\n\n\nIn a terminal window, write the image to the card with the command below, making sure you replace the input file \nif=\n argument with the path to your \n.img\n file, and the \n/dev/sdX\n in the output file \nof=\n argument with the correct device name. This is very important, as you will lose all the data on the hard drive if you provide the wrong device name. Make sure the device name is the name of the whole SD card as described above, not just a partition. For example: \nsdd\n, not \nsdds1\n or \nsddp1\n, and \nmmcblk0\n, not \nmmcblk0p1\n.\n\n\nbash\ndd bs=4M if=2017-11-29-raspbian-stretch.img of=/dev/sdX conv=fsync\n\n\n\n\n\n\nPlease note that block size set to \n4M\n will work most of the time. If not,  try \n1M\n, although this will take considerably longer.\n\n\n\n\n\n\nAlso note that if you are not logged in as root you will need to prefix this with \nsudo\n.\n\n\n\n\n\n\nCopying a zipped image to the SD card\n\n\nIn Linux it is possible to combine the unzip and SD copying process into one command, which avoids any issues that might occur when the unzipped image is larger than 4GB. This can happen on certain filesystems that do not support files larger than 4GB (e.g. FAT), although it should be noted that most Linux installations do not use FAT and therefore do not have this limitation.\n\n\nThe following command unzips the zip file (replace 2017-11-29-raspbian-stretch.zip with the appropriate zip filename), and pipes the output directly to the dd command. This in turn copies it to the SD card, as described in the previous section.\n\n\nunzip -p 2017-11-29-raspbian-stretch.zip | sudo dd of=/dev/sdX bs=4M conv=fsync\n\n\n\n\n\nChecking the image copy progress\n\n\n\n\n\n\nBy default, the \ndd\n command does not give any information about its progress, so it may appear to have frozen. It can take more than five minutes to finish writing to the card. If your card reader has an LED, it may blink during the write process. \n\n\n\n\n\n\nTo see the progress of the copy operation, you can run the dd command with the status option.\n   \ndd bs=4M if=2017-11-29-raspbian-stretch.img of=/dev/sdX status=progress conv=fsync\n\n\n\n\nIf you are using an older version of \ndd\n, the status option may not be available. You may be able to use the \ndcfldd\n command instead, which will give a progress report showing how much has been written. Another method is to send a USR1 signal to \ndd\n, which will let it print status information. Find out the PID of \ndd\n by using \npgrep -l dd\n or \nps a | grep dd\n. Then use \nkill -USR1 PID\n to send the USR1 signal to \ndd\n.\n\n\n\n\nChecking whether the image was correctly written to the SD card\n\n\n\n\n\n\nAfter \ndd\n has finished copying, you can check what has been written to the SD card by \ndd\n-ing from the card back to another image on your hard disk; truncating the new image to the same size as the original; and then running \ndiff\n (or \nmd5sum\n) on those two images.\n\n\n\n\n\n\nIf the SD card is bigger than the original image size, \ndd\n will make a copy of the whole card. We must therefore truncate the new image to the size of the original image. Make sure you replace the input file \nif=\n argument with the correct device name. \ndiff\n should report that the files are identical.\n\n\nbash\ndd bs=4M if=/dev/sdX of=from-sd-card.img\ntruncate --reference 2017-11-29-raspbian-stretch.img from-sd-card.img\ndiff -s from-sd-card.img 2017-11-29-raspbian-stretch.img\n\n\n\n\n\n\nRun \nsync\n. This will ensure the write cache is flushed and that it is safe to unmount your SD card.\n\n\n\n\n\n\nRemove the SD card from the card reader.",
            "title": "Installing operating system images on Linux"
        },
        {
            "location": "/installation/installing-images/linux/index.html#installing-operating-system-images-on-linux",
            "text": "Etcher  is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for more advanced options on Linux, you can use the standard command line tools below.  Note : use of the  dd  tool can overwrite any partition of your machine. If you specify the wrong device in the instructions below, you could delete your primary Linux partition. Please be careful.",
            "title": "Installing operating system images on Linux"
        },
        {
            "location": "/installation/installing-images/linux/index.html#discovering-the-sd-card-mountpoint-and-unmounting-it",
            "text": "Run  df -h  to see which devices are currently mounted.    If your computer has a slot for SD cards, insert the card. If not, insert the card into an SD card reader, then connect the reader to your computer.    Run  df -h  again. The new device that has appeared is your SD card. If no device appears, then your system is not automounting devices. In this case, you will need to search for the device name using another method. The  dmesg | tail  command will display the most recent system messages, which should contain information on the naming of the SD card device. The naming of the device will follow the format described in the next paragraph. Note that if the SD card was not automounted, you do not need to unmount later.    The left column of the results from  df -h  command gives the device name of your SD card. It will be listed as something like  /dev/mmcblk0p1  or  /dev/sdX1 , where X is a lower case letter indicating the device.  The last part ( p1  or  1  respectively) is the partition number. You want to write to the whole SD card, not just one partition. You therefore need to remove that section from the name. You should see something like  /dev/mmcblk0  or  /dev/sdX  as the device name for the whole SD card. Note that the SD card can show up more than once in the output of  df . It will do this if you have previously written a Raspberry Pi image to this SD card, because the Raspberry Pi SD images have more than one partition.    Now you have noted the device name, you need to unmount it so that files can't be read or written to the SD card while you are copying over the SD image.    Run  umount /dev/sdX1 , replacing  sdX1  with whatever your SD card's device name is, including the partition number.    If your SD card shows up more than once in the output of  df , this shows that the card has multiple partitions. You should unmount all of these partitions.",
            "title": "Discovering the SD card mountpoint and unmounting it"
        },
        {
            "location": "/installation/installing-images/linux/index.html#copying-the-image-to-the-sd-card",
            "text": "In a terminal window, write the image to the card with the command below, making sure you replace the input file  if=  argument with the path to your  .img  file, and the  /dev/sdX  in the output file  of=  argument with the correct device name. This is very important, as you will lose all the data on the hard drive if you provide the wrong device name. Make sure the device name is the name of the whole SD card as described above, not just a partition. For example:  sdd , not  sdds1  or  sddp1 , and  mmcblk0 , not  mmcblk0p1 .  bash\ndd bs=4M if=2017-11-29-raspbian-stretch.img of=/dev/sdX conv=fsync    Please note that block size set to  4M  will work most of the time. If not,  try  1M , although this will take considerably longer.    Also note that if you are not logged in as root you will need to prefix this with  sudo .",
            "title": "Copying the image to the SD card"
        },
        {
            "location": "/installation/installing-images/linux/index.html#copying-a-zipped-image-to-the-sd-card",
            "text": "In Linux it is possible to combine the unzip and SD copying process into one command, which avoids any issues that might occur when the unzipped image is larger than 4GB. This can happen on certain filesystems that do not support files larger than 4GB (e.g. FAT), although it should be noted that most Linux installations do not use FAT and therefore do not have this limitation.  The following command unzips the zip file (replace 2017-11-29-raspbian-stretch.zip with the appropriate zip filename), and pipes the output directly to the dd command. This in turn copies it to the SD card, as described in the previous section.  unzip -p 2017-11-29-raspbian-stretch.zip | sudo dd of=/dev/sdX bs=4M conv=fsync",
            "title": "Copying a zipped image to the SD card"
        },
        {
            "location": "/installation/installing-images/linux/index.html#checking-the-image-copy-progress",
            "text": "By default, the  dd  command does not give any information about its progress, so it may appear to have frozen. It can take more than five minutes to finish writing to the card. If your card reader has an LED, it may blink during the write process.     To see the progress of the copy operation, you can run the dd command with the status option.\n    dd bs=4M if=2017-11-29-raspbian-stretch.img of=/dev/sdX status=progress conv=fsync   If you are using an older version of  dd , the status option may not be available. You may be able to use the  dcfldd  command instead, which will give a progress report showing how much has been written. Another method is to send a USR1 signal to  dd , which will let it print status information. Find out the PID of  dd  by using  pgrep -l dd  or  ps a | grep dd . Then use  kill -USR1 PID  to send the USR1 signal to  dd .",
            "title": "Checking the image copy progress"
        },
        {
            "location": "/installation/installing-images/linux/index.html#checking-whether-the-image-was-correctly-written-to-the-sd-card",
            "text": "After  dd  has finished copying, you can check what has been written to the SD card by  dd -ing from the card back to another image on your hard disk; truncating the new image to the same size as the original; and then running  diff  (or  md5sum ) on those two images.    If the SD card is bigger than the original image size,  dd  will make a copy of the whole card. We must therefore truncate the new image to the size of the original image. Make sure you replace the input file  if=  argument with the correct device name.  diff  should report that the files are identical.  bash\ndd bs=4M if=/dev/sdX of=from-sd-card.img\ntruncate --reference 2017-11-29-raspbian-stretch.img from-sd-card.img\ndiff -s from-sd-card.img 2017-11-29-raspbian-stretch.img    Run  sync . This will ensure the write cache is flushed and that it is safe to unmount your SD card.    Remove the SD card from the card reader.",
            "title": "Checking whether the image was correctly written to the SD card"
        },
        {
            "location": "/installation/installing-images/mac/index.html",
            "text": "Installing operating system images on Mac OS\n\n\nEtcher\n is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for more advanced options on Mac OS, you can use the built-in graphical and command line tools below.\n\n\nNote\n: use of the \ndd\n tool can overwrite any partition of your machine. If you specify the wrong device in the instructions below, you could delete your primary Mac OS partition. Please be careful.\n\n\n(Mostly) graphical interface\n\n\n\n\nConnect the SD card reader with the SD card inside. Note that it must be formatted as FAT32.\n\n\nFrom the Apple menu, choose 'About This Mac', then click on 'More info...'. If you are using Mac OS X 10.8.x Mountain Lion or newer, you will then need to click on 'System Report'.\n\n\nClick on 'USB' (or 'Card Reader' if you are using a built-in SD card reader), then search for your SD card in the upper right section of the window. Click on it, then search for the BSD name in the lower right section. It will look something like \ndiskn\n where \nn\n is a number (for example, \ndisk4\n). Make sure you take a note of this number.\n\n\nUnmount the partition so that you will be allowed to overwrite the disk. To do this, open Disk Utility and unmount it. Do not eject it. If you eject it, you will have to reconnect it. Note that on Mac OS X 10.8.x Mountain Lion, 'Verify Disk' (before unmounting) will display the BSD name as \n/dev/disk1s2\n or similar, allowing you to skip the previous two steps. Note down the number that appears after 'disk', in this case the number '1'.\n\n\n\n\nFrom the terminal, run the following command:\n\n\nsudo dd bs=1m if=path_of_your_image.img of=/dev/rdiskn conv=sync\n\n\nRemember to replace \nn\n with the number that you noted before!\n\n\nThis will take a few minutes, depending on the image file size. You can check the progress by sending a SIGINFO signal                  (press Ctrl+T).\n\n\n\n\nIf this command fails, try using \ndisk\n instead of \nrdisk\n:\n\n\n\n\nsudo dd bs=1m if=path_of_your_image.img of=/dev/diskn conv=sync\n\nThis will take a few minutes, depending on the size of the image file. To check the progress, open Activity Monitor, click the Disk tab and find the process with the name \ndd\n. If \ndd\n is not in the list, you may need to select 'All Processes' from the View menu. The Bytes Read column will display the amount of data that has been read from the image. Compare that to the file size of the image to determine progress.\n\n\n\n\n\n\nCommand line\n\n\n\n\n\n\nIf you are comfortable with the command line, you can write the image to an SD card without any additional software. Open a terminal, then run:\n\n\ndiskutil list\n\n\n\n\n\n\nIdentify the disk (not the partition) of your SD card, e.g. \ndisk4\n, not \ndisk4s1\n.\n\n\n\n\n\n\nUnmount your SD card by using the disk identifier, to prepare it for copying data:\n\n\ndiskutil unmountDisk /dev/disk<disk# from diskutil>\n\n\nwhere \ndisk\n is your BSD name e.g. \ndiskutil unmountDisk /dev/disk4\n\n\n\n\n\n\nCopy the data to your SD card:\n\n\nsudo dd bs=1m if=image.img of=/dev/rdisk<disk# from diskutil> conv=sync\n\n\nwhere \ndisk\n is your BSD name e.g. \nsudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk4 conv=sync\n\n\n\n\nThis may result in a \ndd: invalid number '1m'\n error if you have GNU\ncoreutils installed. In that case, you need to use a block size of \n1M\n in the \nbs=\n section, as follows:\n\n\n\n\nsudo dd bs=1M if=image.img of=/dev/rdisk<disk# from diskutil> conv=sync\n\n\nThis will take a few minutes, depending on the image file size. You can check the progress by sending a \nSIGINFO\n signal (press Ctrl+T).\n\n\n\n\nIf this command still fails, try using \ndisk\n instead of \nrdisk\n, for example:\n\n\n\n\nsudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/disk4 conv=sync\n\n   or\n   \nsudo dd bs=1M if=2017-11-29-raspbian-stretch.img of=/dev/disk4 conv=sync\n\n\n\n\n\n\nAlternative method\n\n\nNote\n: Some users have reported issues with using this method to create SD cards, possibly because earlier versions of these instructions didn't note that it may be necessary to unmount multiple partitions on the SD card.\n\n\nThese commands and actions must be performed from an account that has administrator privileges.\n\n\n\n\nFrom the terminal run \ndf -h\n.  For example:\n\n\n\n\n$ df -h\nFilesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on\n/dev/disk1     233Gi   73Gi  159Gi    \n32\n% \n1552273\n \n4293415006\n    \n0\n%   /\ndevfs          189Ki  189Ki    0Bi   \n100\n%     \n654\n          \n0\n  \n100\n%   /dev\nmap -hosts       0Bi    0Bi    0Bi   \n100\n%       \n0\n          \n0\n  \n100\n%   /net\nmap auto_home    0Bi    0Bi    0Bi   \n100\n%       \n0\n          \n0\n  \n100\n%   /home\n\n\n\n\n\n\n\nConnect the SD card reader with the SD card inside.\n\n\nRun \ndf -h\n again and look for the new device which was not previously listed. Record the device name(s) of the filesystem's partition(s), for example \n/dev/disk3s5\n and \n/dev/disk3s1\n.  Notice the last two lines:\n\n\n\n\n$ df -h\nFilesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on\n/dev/disk1     233Gi   73Gi  159Gi    \n32\n% \n1552273\n \n4293415006\n    \n0\n%   /\ndevfs          189Ki  189Ki    0Bi   \n100\n%     \n654\n          \n0\n  \n100\n%   /dev\nmap -hosts       0Bi    0Bi    0Bi   \n100\n%       \n0\n          \n0\n  \n100\n%   /net\nmap auto_home    0Bi    0Bi    0Bi   \n100\n%       \n0\n          \n0\n  \n100\n%   /home\n/dev/disk3s5    60Mi   20Mi   40Mi    \n33\n%     \n512\n          \n0\n  \n100\n%   /Volumes/boot\n/dev/disk3s1   812Mi  740Mi   71Mi    \n92\n%       \n0\n          \n0\n  \n100\n%   /Volumes/RECOVERY\n\n\n\n\n\n\n\n\n\nUnmount the partition(s) so that you will be allowed to overwrite the disk:\n\n\nsudo diskutil unmount /dev/disk3s5\nsudo diskutil unmount /dev/disk3s1\n\n\nAlternatively, open Disk Utility and unmount the partition of the SD card. Do not eject it. If you eject it, you will have to reconnect it.\n- Using the device name of the partition, work out the \nraw device name\n for the entire disk by omitting the final \ns#\n and replacing \ndisk\n with \nrdisk\n. This is very important, as you will lose all data on the hard drive if you provide the wrong device name. Make sure the device name is the name of the whole SD card as described above, not just a partition of it, for example, \nrdisk3\n, not \nrdisk3s1\n. Similarly, you might have another SD drive name/number like \nrdisk2\n or \nrdisk4\n. You can check again by using the \ndf -h\n command, both before and after you insert your SD card reader into your Mac. For example: \n/dev/disk3s1\n becomes \n/dev/rdisk3\n.\n- In the terminal, write the image to the card with this command, using the raw device name from above. Read the above step carefully to make sure that you use the correct \nrdisk\n number here:\n\n\nsudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk3 conv=sync\n\n\nIf the above command reports the error \ndd: bs: illegal numeric value\n, change the block size \nbs=1m\n to \nbs=1M\n.\n\n\nIf the above command reports the error \ndd: /dev/rdisk3: Permission denied\n, the partition table of the SD card is being protected against being overwritten by Mac OS. Erase the SD card's partition table using this command:\n\n\nsudo diskutil partitionDisk /dev/disk3 1 MBR \"Free Space\" \"%noformat%\" 100%\n\n\nThat command will also set the permissions on the device to allow writing. Now try the \ndd\n command again.\n\n\nNote that \ndd\n will not provide any on-screen information until there is an error, or it is finished. When the process is complete, information will be shown and the disk will re-mount. If you wish to view the progress, you can use Ctrl-T. This generates SIGINFO, the status argument of your terminal, and will display information on the process.\n- After the \ndd\n command finishes, eject the card:\n\n\nsudo diskutil eject /dev/rdisk3\n\n\nAlternatively, open Disk Utility and use this to eject the SD card.\n\n\n\n\n\n\n\n\nThis article uses content from the eLinux wiki page \nRPi_Easy_SD_Card_Setup\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Installing operating system images on Mac OS"
        },
        {
            "location": "/installation/installing-images/mac/index.html#installing-operating-system-images-on-mac-os",
            "text": "Etcher  is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for more advanced options on Mac OS, you can use the built-in graphical and command line tools below.  Note : use of the  dd  tool can overwrite any partition of your machine. If you specify the wrong device in the instructions below, you could delete your primary Mac OS partition. Please be careful.",
            "title": "Installing operating system images on Mac OS"
        },
        {
            "location": "/installation/installing-images/mac/index.html#mostly-graphical-interface",
            "text": "Connect the SD card reader with the SD card inside. Note that it must be formatted as FAT32.  From the Apple menu, choose 'About This Mac', then click on 'More info...'. If you are using Mac OS X 10.8.x Mountain Lion or newer, you will then need to click on 'System Report'.  Click on 'USB' (or 'Card Reader' if you are using a built-in SD card reader), then search for your SD card in the upper right section of the window. Click on it, then search for the BSD name in the lower right section. It will look something like  diskn  where  n  is a number (for example,  disk4 ). Make sure you take a note of this number.  Unmount the partition so that you will be allowed to overwrite the disk. To do this, open Disk Utility and unmount it. Do not eject it. If you eject it, you will have to reconnect it. Note that on Mac OS X 10.8.x Mountain Lion, 'Verify Disk' (before unmounting) will display the BSD name as  /dev/disk1s2  or similar, allowing you to skip the previous two steps. Note down the number that appears after 'disk', in this case the number '1'.   From the terminal, run the following command:  sudo dd bs=1m if=path_of_your_image.img of=/dev/rdiskn conv=sync  Remember to replace  n  with the number that you noted before!  This will take a few minutes, depending on the image file size. You can check the progress by sending a SIGINFO signal                  (press Ctrl+T).   If this command fails, try using  disk  instead of  rdisk :   sudo dd bs=1m if=path_of_your_image.img of=/dev/diskn conv=sync \nThis will take a few minutes, depending on the size of the image file. To check the progress, open Activity Monitor, click the Disk tab and find the process with the name  dd . If  dd  is not in the list, you may need to select 'All Processes' from the View menu. The Bytes Read column will display the amount of data that has been read from the image. Compare that to the file size of the image to determine progress.",
            "title": "(Mostly) graphical interface"
        },
        {
            "location": "/installation/installing-images/mac/index.html#command-line",
            "text": "If you are comfortable with the command line, you can write the image to an SD card without any additional software. Open a terminal, then run:  diskutil list    Identify the disk (not the partition) of your SD card, e.g.  disk4 , not  disk4s1 .    Unmount your SD card by using the disk identifier, to prepare it for copying data:  diskutil unmountDisk /dev/disk<disk# from diskutil>  where  disk  is your BSD name e.g.  diskutil unmountDisk /dev/disk4    Copy the data to your SD card:  sudo dd bs=1m if=image.img of=/dev/rdisk<disk# from diskutil> conv=sync  where  disk  is your BSD name e.g.  sudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk4 conv=sync   This may result in a  dd: invalid number '1m'  error if you have GNU\ncoreutils installed. In that case, you need to use a block size of  1M  in the  bs=  section, as follows:   sudo dd bs=1M if=image.img of=/dev/rdisk<disk# from diskutil> conv=sync  This will take a few minutes, depending on the image file size. You can check the progress by sending a  SIGINFO  signal (press Ctrl+T).   If this command still fails, try using  disk  instead of  rdisk , for example:   sudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/disk4 conv=sync \n   or\n    sudo dd bs=1M if=2017-11-29-raspbian-stretch.img of=/dev/disk4 conv=sync",
            "title": "Command line"
        },
        {
            "location": "/installation/installing-images/mac/index.html#alternative-method",
            "text": "Note : Some users have reported issues with using this method to create SD cards, possibly because earlier versions of these instructions didn't note that it may be necessary to unmount multiple partitions on the SD card.  These commands and actions must be performed from an account that has administrator privileges.   From the terminal run  df -h .  For example:   $ df -h\nFilesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on\n/dev/disk1     233Gi   73Gi  159Gi     32 %  1552273   4293415006      0 %   /\ndevfs          189Ki  189Ki    0Bi    100 %      654            0    100 %   /dev\nmap -hosts       0Bi    0Bi    0Bi    100 %        0            0    100 %   /net\nmap auto_home    0Bi    0Bi    0Bi    100 %        0            0    100 %   /home   Connect the SD card reader with the SD card inside.  Run  df -h  again and look for the new device which was not previously listed. Record the device name(s) of the filesystem's partition(s), for example  /dev/disk3s5  and  /dev/disk3s1 .  Notice the last two lines:   $ df -h\nFilesystem      Size   Used  Avail Capacity iused      ifree %iused  Mounted on\n/dev/disk1     233Gi   73Gi  159Gi     32 %  1552273   4293415006      0 %   /\ndevfs          189Ki  189Ki    0Bi    100 %      654            0    100 %   /dev\nmap -hosts       0Bi    0Bi    0Bi    100 %        0            0    100 %   /net\nmap auto_home    0Bi    0Bi    0Bi    100 %        0            0    100 %   /home\n/dev/disk3s5    60Mi   20Mi   40Mi     33 %      512            0    100 %   /Volumes/boot\n/dev/disk3s1   812Mi  740Mi   71Mi     92 %        0            0    100 %   /Volumes/RECOVERY    Unmount the partition(s) so that you will be allowed to overwrite the disk:  sudo diskutil unmount /dev/disk3s5\nsudo diskutil unmount /dev/disk3s1  Alternatively, open Disk Utility and unmount the partition of the SD card. Do not eject it. If you eject it, you will have to reconnect it.\n- Using the device name of the partition, work out the  raw device name  for the entire disk by omitting the final  s#  and replacing  disk  with  rdisk . This is very important, as you will lose all data on the hard drive if you provide the wrong device name. Make sure the device name is the name of the whole SD card as described above, not just a partition of it, for example,  rdisk3 , not  rdisk3s1 . Similarly, you might have another SD drive name/number like  rdisk2  or  rdisk4 . You can check again by using the  df -h  command, both before and after you insert your SD card reader into your Mac. For example:  /dev/disk3s1  becomes  /dev/rdisk3 .\n- In the terminal, write the image to the card with this command, using the raw device name from above. Read the above step carefully to make sure that you use the correct  rdisk  number here:  sudo dd bs=1m if=2017-11-29-raspbian-stretch.img of=/dev/rdisk3 conv=sync  If the above command reports the error  dd: bs: illegal numeric value , change the block size  bs=1m  to  bs=1M .  If the above command reports the error  dd: /dev/rdisk3: Permission denied , the partition table of the SD card is being protected against being overwritten by Mac OS. Erase the SD card's partition table using this command:  sudo diskutil partitionDisk /dev/disk3 1 MBR \"Free Space\" \"%noformat%\" 100%  That command will also set the permissions on the device to allow writing. Now try the  dd  command again.  Note that  dd  will not provide any on-screen information until there is an error, or it is finished. When the process is complete, information will be shown and the disk will re-mount. If you wish to view the progress, you can use Ctrl-T. This generates SIGINFO, the status argument of your terminal, and will display information on the process.\n- After the  dd  command finishes, eject the card:  sudo diskutil eject /dev/rdisk3  Alternatively, open Disk Utility and use this to eject the SD card.     This article uses content from the eLinux wiki page  RPi_Easy_SD_Card_Setup , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Alternative method"
        },
        {
            "location": "/installation/installing-images/windows/index.html",
            "text": "Installing operating system images using Windows\n\n\nEtcher\n is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for an alternative on Windows, you can use \nWin32DiskImager\n:\n\n\nWin32DiskImager\n\n\n\n\nInsert the SD card into your SD card reader. You can use the SD card slot if you have one, or an SD adapter in a USB port. Note the drive letter assigned to the SD card. You can see the drive letter in the left hand column of Windows Explorer, for example \nG:\n\n\nDownload the Win32DiskImager utility from the \nSourceforge Project page\n as an installer file, and run it to install the software.\n\n\nRun the \nWin32DiskImager\n utility from your desktop or menu.\n\n\nSelect the image file you extracted earlier.\n\n\nIn the device box, select the drive letter of the SD card. Be careful to select the correct drive: if you choose the wrong drive you could destroy the data on your computer's hard disk! If you are using an SD card slot in your computer, and can't see the drive in the Win32DiskImager window, try using an external SD adapter.\n\n\nClick 'Write' and wait for the write to complete.\n\n\nExit the imager and eject the SD card.\n\n\n\n\n\n\nThis article uses content from the eLinux wiki page \nRPi_Easy_SD_Card_Setup\n, which is shared under the \nCreative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Installing operating system images using Windows"
        },
        {
            "location": "/installation/installing-images/windows/index.html#installing-operating-system-images-using-windows",
            "text": "Etcher  is typically the easiest option for most users to write images to SD cards, so it is a good place to start. If you're looking for an alternative on Windows, you can use  Win32DiskImager :",
            "title": "Installing operating system images using Windows"
        },
        {
            "location": "/installation/installing-images/windows/index.html#win32diskimager",
            "text": "Insert the SD card into your SD card reader. You can use the SD card slot if you have one, or an SD adapter in a USB port. Note the drive letter assigned to the SD card. You can see the drive letter in the left hand column of Windows Explorer, for example  G:  Download the Win32DiskImager utility from the  Sourceforge Project page  as an installer file, and run it to install the software.  Run the  Win32DiskImager  utility from your desktop or menu.  Select the image file you extracted earlier.  In the device box, select the drive letter of the SD card. Be careful to select the correct drive: if you choose the wrong drive you could destroy the data on your computer's hard disk! If you are using an SD card slot in your computer, and can't see the drive in the Win32DiskImager window, try using an external SD adapter.  Click 'Write' and wait for the write to complete.  Exit the imager and eject the SD card.    This article uses content from the eLinux wiki page  RPi_Easy_SD_Card_Setup , which is shared under the  Creative Commons Attribution-ShareAlike 3.0 Unported license",
            "title": "Win32DiskImager"
        },
        {
            "location": "/linux/README/index.html",
            "text": "Linux\n\n\nExplanation of some fundamental Linux usage, and commands for getting around the Pi and managing its file system and users.\n\n\nContents\n\n\n\n\nFilesystem\n\n\nHome\n\n\nYour user's home folder on the Pi, where you keep your files\n\n\n\n\n\n\nWhole File system\n\n\nThe rest of the Linux file system\n\n\n\n\n\n\nBackup\n\n\nBacking up your files and your operating system image\n\n\n\n\n\n\n\n\n\n\nUsage\n\n\nCommands\n\n\nSome basic and more advanced Linux commands\n\n\n\n\n\n\nText editors\n\n\nA selection of text editors available on the Pi\n\n\n\n\n\n\nUsers\n\n\nSetting up multiple Linux users on your Pi system\n\n\n\n\n\n\nRoot\n\n\nThe \nroot\n user and the \nsudo\n prefix\n\n\n\n\n\n\nScripting\n\n\nCombining commands to produce more complex actions\n\n\n\n\n\n\nCron / Crontab\n\n\nSetting up scheduled tasks\n\n\n\n\n\n\n.bashrc and .bash_aliases\n\n\nYour shell configuration and aliases\n\n\n\n\n\n\nrc.local\n\n\nConfiguration of initialisation\n\n\n\n\n\n\n\n\n\n\nSoftware\n\n\nAPT\n\n\nInstalling software with APT\n\n\n\n\n\n\nPython\n\n\nInstalling software using a Python package manager such as \npip\n\n\n\n\n\n\nRuby\n\n\nInstalling software with Ruby's package manager \nruby gems\n\n\n\n\n\n\n\n\n\n\nKernel\n\n\nUpdating\n\n\nUpdating your Linux kernel on Raspberry Pi\n\n\n\n\n\n\nBuilding\n\n\nBuilding the Linux kernel on Raspberry Pi\n\n\n\n\n\n\nConfiguring\n\n\nConfiguring the Linux kernel on Raspberry Pi\n\n\n\n\n\n\nPatching\n\n\nApplying patches to the Linux kernel on Raspberry Pi\n\n\n\n\n\n\nHeaders\n\n\nGetting the kernel headers",
            "title": "Linux"
        },
        {
            "location": "/linux/README/index.html#linux",
            "text": "Explanation of some fundamental Linux usage, and commands for getting around the Pi and managing its file system and users.",
            "title": "Linux"
        },
        {
            "location": "/linux/README/index.html#contents",
            "text": "Filesystem  Home  Your user's home folder on the Pi, where you keep your files    Whole File system  The rest of the Linux file system    Backup  Backing up your files and your operating system image      Usage  Commands  Some basic and more advanced Linux commands    Text editors  A selection of text editors available on the Pi    Users  Setting up multiple Linux users on your Pi system    Root  The  root  user and the  sudo  prefix    Scripting  Combining commands to produce more complex actions    Cron / Crontab  Setting up scheduled tasks    .bashrc and .bash_aliases  Your shell configuration and aliases    rc.local  Configuration of initialisation      Software  APT  Installing software with APT    Python  Installing software using a Python package manager such as  pip    Ruby  Installing software with Ruby's package manager  ruby gems      Kernel  Updating  Updating your Linux kernel on Raspberry Pi    Building  Building the Linux kernel on Raspberry Pi    Configuring  Configuring the Linux kernel on Raspberry Pi    Patching  Applying patches to the Linux kernel on Raspberry Pi    Headers  Getting the kernel headers",
            "title": "Contents"
        },
        {
            "location": "/linux/filesystem/README/index.html",
            "text": "Linux File system\n\n\nIt is important to have a basic understanding of the fundamentals of the Linux file system: where your files are kept, where software is installed, where the danger zones are, and so on.\n\n\nContents\n\n\n\n\nHome\n\n\nBackups\n\n\nWhole file system",
            "title": "Linux File system"
        },
        {
            "location": "/linux/filesystem/README/index.html#linux-file-system",
            "text": "It is important to have a basic understanding of the fundamentals of the Linux file system: where your files are kept, where software is installed, where the danger zones are, and so on.",
            "title": "Linux File system"
        },
        {
            "location": "/linux/filesystem/README/index.html#contents",
            "text": "Home  Backups  Whole file system",
            "title": "Contents"
        },
        {
            "location": "/linux/filesystem/backup/index.html",
            "text": "Backups\n\n\nIt is highly recommended that you keep regular backups of any important files. Backups are often not limited to user files; they could include configuration files, databases, installed software, settings, and even an entire snapshot of a system.\n\n\nHere, we'll guide you through some backup techniques for your Raspberry Pi system.\n\n\nHome folder\n\n\nA sensible way to keep your home folder backed up is to use the \ntar\n command to make a snapshot archive of the folder, and keep a copy of it on your home PC or in cloud storage. To do this, enter the following commands:\n\n\ncd\n /home/\nsudo tar czf pi_home.tar.gz pi\n\n\n\n\n\nThis creates a tar archive called \npi_home.tar.gz\n in \n/home/\n. You should copy this file to a USB stick or transfer it to another machine on your network.\n\n\nMySQL\n\n\nIf you have MySQL databases running on your Raspberry Pi, it would be wise to keep them backed up too. To back up a single database, use the \nmysqldump\n command:\n\n\nmysqldump recipes > recipes.sql\n\n\n\n\n\nThis command will back up the \nrecipes\n database to the file \nrecipes.sql\n. Note that, in this case, no username and password have been supplied to the \nmysqldump\n command. If you don't have your MySQL credentials in a \n.my.cnf\n configuration file in your home folder, then supply the username and password with flags:\n\n\nmysqldump -uroot -ppass recipes > recipes.sql\n\n\n\n\n\nTo restore a MySQL database from a dumpfile, pipe the dumpfile into the \nmysql\n command. Provide credentials, if necessary, and the database name. Note that the database must exist, so create it first:\n\n\nmysql -Bse \n\"create database recipes\"\n\ncat recipes.sql \n|\n mysql recipes\n\n\n\n\n\nAlternatively, you can use the \npv\n command to see a progress meter as the dumpfile is processed by MySQL. This is not installed by default, so install with \nsudo apt-get install pv\n. This command is useful for large files:\n\n\npv recipes.sql \n|\n mysql recipes\n\n\n\n\n\nSD card image\n\n\nIt may be sensible for you to keep a copy of the entire SD card image, so you can restore the card if you lose it or it becomes corrupt. You can do this using the same method you'd use to write an image to a new card, but in reverse.\n\n\nIn Linux:\n\n\nsudo dd \nbs\n=\n4M \nif\n=\n/dev/sdb \nof\n=\nraspbian.img\n\n\n\n\n\nThis will create an image file on your computer which you can use to write to another SD card, and keep exactly the same contents and settings. To restore or clone to another card, use \ndd\n in reverse:\n\n\nsudo dd \nbs\n=\n4M \nif\n=\nraspbian.img \nof\n=\n/dev/sdb\n\n\n\n\n\nThese files can be very large, and compress well. To compress, you can pipe the output of \ndd\n to \ngzip\n to get a compressed file that is significantly smaller than the original size:\n\n\nsudo dd \nbs\n=\n4M \nif\n=\n/dev/sdb \n|\n gzip > raspbian.img.gz\n\n\n\n\n\nTo restore, pipe the output of \ngunzip\n to \ndd\n:\n\n\ngunzip --stdout raspbian.img.gz \n|\n sudo dd \nbs\n=\n4M \nof\n=\n/dev/sdb\n\n\n\n\n\nIf you are using a Mac, the commands used are almost exactly the same, but \n4M\n in the above examples should be replaced with \n4m\n, with a lower case letter.\n\n\nSee more about \ninstalling SD card images\n.\n\n\nAutomation\n\n\nYou could write a Bash script to perform each of these processes automatically, and even have it performed periodically using \ncron\n.",
            "title": "Backups"
        },
        {
            "location": "/linux/filesystem/backup/index.html#backups",
            "text": "It is highly recommended that you keep regular backups of any important files. Backups are often not limited to user files; they could include configuration files, databases, installed software, settings, and even an entire snapshot of a system.  Here, we'll guide you through some backup techniques for your Raspberry Pi system.",
            "title": "Backups"
        },
        {
            "location": "/linux/filesystem/backup/index.html#home-folder",
            "text": "A sensible way to keep your home folder backed up is to use the  tar  command to make a snapshot archive of the folder, and keep a copy of it on your home PC or in cloud storage. To do this, enter the following commands:  cd  /home/\nsudo tar czf pi_home.tar.gz pi  This creates a tar archive called  pi_home.tar.gz  in  /home/ . You should copy this file to a USB stick or transfer it to another machine on your network.",
            "title": "Home folder"
        },
        {
            "location": "/linux/filesystem/backup/index.html#mysql",
            "text": "If you have MySQL databases running on your Raspberry Pi, it would be wise to keep them backed up too. To back up a single database, use the  mysqldump  command:  mysqldump recipes > recipes.sql  This command will back up the  recipes  database to the file  recipes.sql . Note that, in this case, no username and password have been supplied to the  mysqldump  command. If you don't have your MySQL credentials in a  .my.cnf  configuration file in your home folder, then supply the username and password with flags:  mysqldump -uroot -ppass recipes > recipes.sql  To restore a MySQL database from a dumpfile, pipe the dumpfile into the  mysql  command. Provide credentials, if necessary, and the database name. Note that the database must exist, so create it first:  mysql -Bse  \"create database recipes\" \ncat recipes.sql  |  mysql recipes  Alternatively, you can use the  pv  command to see a progress meter as the dumpfile is processed by MySQL. This is not installed by default, so install with  sudo apt-get install pv . This command is useful for large files:  pv recipes.sql  |  mysql recipes",
            "title": "MySQL"
        },
        {
            "location": "/linux/filesystem/backup/index.html#sd-card-image",
            "text": "It may be sensible for you to keep a copy of the entire SD card image, so you can restore the card if you lose it or it becomes corrupt. You can do this using the same method you'd use to write an image to a new card, but in reverse.  In Linux:  sudo dd  bs = 4M  if = /dev/sdb  of = raspbian.img  This will create an image file on your computer which you can use to write to another SD card, and keep exactly the same contents and settings. To restore or clone to another card, use  dd  in reverse:  sudo dd  bs = 4M  if = raspbian.img  of = /dev/sdb  These files can be very large, and compress well. To compress, you can pipe the output of  dd  to  gzip  to get a compressed file that is significantly smaller than the original size:  sudo dd  bs = 4M  if = /dev/sdb  |  gzip > raspbian.img.gz  To restore, pipe the output of  gunzip  to  dd :  gunzip --stdout raspbian.img.gz  |  sudo dd  bs = 4M  of = /dev/sdb  If you are using a Mac, the commands used are almost exactly the same, but  4M  in the above examples should be replaced with  4m , with a lower case letter.  See more about  installing SD card images .",
            "title": "SD card image"
        },
        {
            "location": "/linux/filesystem/backup/index.html#automation",
            "text": "You could write a Bash script to perform each of these processes automatically, and even have it performed periodically using  cron .",
            "title": "Automation"
        },
        {
            "location": "/linux/filesystem/home/index.html",
            "text": "Home\n\n\nWhen you log into a Pi and open a terminal window, or you boot to the command line instead of the graphical user interface, you start in your home folder; this is located at \n/home/pi\n, assuming your username is \npi\n.\n\n\nThis is where the user's own files are kept. The contents of the user's desktop is in a directory here called \nDesktop\n, along with other files and folders.\n\n\nTo navigate to your home folder on the command line, simply type \ncd\n and press \nEnter\n. This is the equivalent of typing \ncd /home/pi\n, where \npi\n is your username. You can also use the tilde key (\n~\n), for example \ncd ~\n, which can be used to relatively link back to your home folder. For instance, \ncd ~/Desktop/\n is the same as \ncd /home/pi/Desktop\n.\n\n\nNavigate to \n/home/\n and run \nls\n, and you'll see the home folders of each of the users on the system.\n\n\nNote that if logged in as the root user, typing \ncd\n or \ncd ~\n will take you to the root user's home directory; unlike normal users, this is located at \n/root/\n not \n/home/root/\n. Read more about the \nroot user\n.\n\n\nIf you have files you would not like to lose, you may want to back up your home folder. Read more about \nbacking up\n.",
            "title": "Home"
        },
        {
            "location": "/linux/filesystem/home/index.html#home",
            "text": "When you log into a Pi and open a terminal window, or you boot to the command line instead of the graphical user interface, you start in your home folder; this is located at  /home/pi , assuming your username is  pi .  This is where the user's own files are kept. The contents of the user's desktop is in a directory here called  Desktop , along with other files and folders.  To navigate to your home folder on the command line, simply type  cd  and press  Enter . This is the equivalent of typing  cd /home/pi , where  pi  is your username. You can also use the tilde key ( ~ ), for example  cd ~ , which can be used to relatively link back to your home folder. For instance,  cd ~/Desktop/  is the same as  cd /home/pi/Desktop .  Navigate to  /home/  and run  ls , and you'll see the home folders of each of the users on the system.  Note that if logged in as the root user, typing  cd  or  cd ~  will take you to the root user's home directory; unlike normal users, this is located at  /root/  not  /home/root/ . Read more about the  root user .  If you have files you would not like to lose, you may want to back up your home folder. Read more about  backing up .",
            "title": "Home"
        },
        {
            "location": "/linux/filesystem/whole-filesystem/index.html",
            "text": "Whole Linux file system\n\n\nA list of directories is shown below. For more information, please refer to the Linux \nFilesystem Hierarchy Standard\n.\n\n\n\n\n\n\nbin\n\n\n\n\n\n\nboot\n\n\n\n\n\n\ndev\n\n\n\n\n\n\netc\n\n\n\n\n\n\nhome\n\n\n\n\n\n\nlib\n\n\n\n\n\n\nlost+found\n\n\n\n\n\n\nmedia\n\n\n\n\n\n\nmnt\n\n\n\n\n\n\nopt\n\n\n\n\n\n\nproc\n\n\n\n\n\n\nroot\n\n\n\n\n\n\nrun\n\n\n\n\n\n\nsbin\n\n\n\n\n\n\nselinux\n\n\n\n\n\n\nsrv\n\n\n\n\n\n\nsys\n\n\n\n\n\n\ntmp\n\n\n\n\n\n\nusr\n\n\n\n\n\n\nvar",
            "title": "Whole Linux file system"
        },
        {
            "location": "/linux/filesystem/whole-filesystem/index.html#whole-linux-file-system",
            "text": "A list of directories is shown below. For more information, please refer to the Linux  Filesystem Hierarchy Standard .    bin    boot    dev    etc    home    lib    lost+found    media    mnt    opt    proc    root    run    sbin    selinux    srv    sys    tmp    usr    var",
            "title": "Whole Linux file system"
        },
        {
            "location": "/linux/kernel/README/index.html",
            "text": "Kernel\n\n\nThe Raspberry Pi kernel is stored in GitHub and can be viewed at \ngithub.com/raspberrypi/linux\n; it follows behind the main \nLinux kernel\n.\n\n\nThe main Linux kernel is continuously updating; we take long-term releases of the kernel, which are mentioned on the front page, and integrate the changes into the Raspberry Pi kernel. We then create a 'next' branch which contains an unstable port of the kernel; after extensive testing and discussion, we push this to the main branch.\n\n\n\n\nUpdating your kernel\n\n\nBuilding a new kernel\n\n\nConfiguring the kernel\n\n\nApplying patches to the kernel\n\n\nGetting the kernel headers\n\n\n\n\nGetting your code into the kernel\n\n\nThere are many reasons you may want to put something into the kernel:\n\n\n\n\nYou've written some Raspberry Pi-specific code that you want everyone to benefit from\n\n\nYou've written a generic Linux kernel driver for a device and want everyone to use it\n\n\nYou've fixed a generic kernel bug\n\n\nYou've fixed a Raspberry Pi-specific kernel bug\n\n\n\n\nInitially, you should fork the Linux repository and clone that on your build system; this can be either on the Raspberry Pi or on a Linux machine you're using for cross-compiling. You can then make your changes, test them, and commit them into your fork.\n\n\nNext, depending upon whether the code is Raspberry Pi-specific or not:\n\n\n\n\n\n\nFor Pi-specific changes or bug fixes, submit a pull request to the kernel.\n\n\n\n\n\n\nFor general Linux kernel changes (i.e. a new driver), these need to be submitted upstream first. Once they've been submitted upstream and accepted, submit the pull request and we'll receive it.",
            "title": "Kernel"
        },
        {
            "location": "/linux/kernel/README/index.html#kernel",
            "text": "The Raspberry Pi kernel is stored in GitHub and can be viewed at  github.com/raspberrypi/linux ; it follows behind the main  Linux kernel .  The main Linux kernel is continuously updating; we take long-term releases of the kernel, which are mentioned on the front page, and integrate the changes into the Raspberry Pi kernel. We then create a 'next' branch which contains an unstable port of the kernel; after extensive testing and discussion, we push this to the main branch.   Updating your kernel  Building a new kernel  Configuring the kernel  Applying patches to the kernel  Getting the kernel headers",
            "title": "Kernel"
        },
        {
            "location": "/linux/kernel/README/index.html#getting-your-code-into-the-kernel",
            "text": "There are many reasons you may want to put something into the kernel:   You've written some Raspberry Pi-specific code that you want everyone to benefit from  You've written a generic Linux kernel driver for a device and want everyone to use it  You've fixed a generic kernel bug  You've fixed a Raspberry Pi-specific kernel bug   Initially, you should fork the Linux repository and clone that on your build system; this can be either on the Raspberry Pi or on a Linux machine you're using for cross-compiling. You can then make your changes, test them, and commit them into your fork.  Next, depending upon whether the code is Raspberry Pi-specific or not:    For Pi-specific changes or bug fixes, submit a pull request to the kernel.    For general Linux kernel changes (i.e. a new driver), these need to be submitted upstream first. Once they've been submitted upstream and accepted, submit the pull request and we'll receive it.",
            "title": "Getting your code into the kernel"
        },
        {
            "location": "/linux/kernel/building/index.html",
            "text": "Kernel building\n\n\nThere are two main methods for building the kernel. You can build locally on a Raspberry Pi, which will take a long time; or you can cross-compile, which is much quicker, but requires more setup.\n\n\nLocal building\n\n\nOn a Raspberry Pi, first install the latest version of \nRaspbian\n. Then boot your Pi, plug in Ethernet to give you access to the sources, and log in.\n\n\nFirst install Git and the build dependencies:\n\n\nsudo apt-get install git bc\n\n\n\n\n\nNext get the sources, which will take some time:\n\n\ngit clone --depth\n=\n1\n https://github.com/raspberrypi/linux\n\n\n\n\n\nConfigure the kernel; as well as the default configuration, you may wish to \nconfigure your kernel in more detail\n or \napply patches from another source\n, to add or remove required functionality:\n\n\nRun the following commands, depending on your Raspberry Pi version.\n\n\nRaspberry Pi 1, Pi 0, Pi 0W, and Compute Module default build configuration\n\n\ncd\n linux\n\nKERNEL\n=\nkernel\nmake bcmrpi_defconfig\n\n\n\n\n\nRaspberry Pi 2, Pi 3, and Compute Module 3 default build configuration\n\n\ncd\n linux\n\nKERNEL\n=\nkernel7\nmake bcm2709_defconfig\n\n\n\n\n\nBuild and install the kernel, modules, and Device Tree blobs; this step takes a \nlong\n time:\n\n\nmake -j4 zImage modules dtbs\nsudo make modules_install\nsudo cp arch/arm/boot/dts/*.dtb /boot/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/\nsudo cp arch/arm/boot/dts/overlays/README /boot/overlays/\nsudo cp arch/arm/boot/zImage /boot/\n$KERNEL\n.img\n\n\n\n\n\nNote\n: On a Raspberry Pi 2/3, the \n-j4\n flag splits the work between all four cores, speeding up compilation significantly.\n\n\nCross-compiling\n\n\nFirst, you will need a suitable Linux cross-compilation host. We tend to use Ubuntu; since Raspbian is \nalso a Debian distribution, it means many aspects are similar, such as the command lines.\n\n\nYou can either do this using VirtualBox (or VMWare) on Windows, or install it directly onto your computer. For reference, you can follow instructions online \nat Wikihow\n.\n\n\nInstall toolchain\n\n\nUse the following command to download the toolchain to the home folder:\n\n\ngit clone https://github.com/raspberrypi/tools ~/tools\n\n\n\n\n\nUpdating the $PATH environment variable makes the system aware of file locations needed for cross-compilation. On a 32-bit host system you can update and reload it using:\n\n\necho\n \nPATH\n=\n\\$\nPATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin >> ~/.bashrc\n\nsource\n ~/.bashrc\n\n\n\n\n\nIf you are on a 64-bit host system, you should use:\n\n\necho\n \nPATH\n=\n\\$\nPATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin >> ~/.bashrc\n\nsource\n ~/.bashrc\n\n\n\n\n\nGet sources\n\n\nTo get the sources, refer to the original \nGitHub\n repository for the various branches.\n\n\n$ git clone --depth\n=\n1\n https://github.com/raspberrypi/linux\n\n\n\n\n\nBuild sources\n\n\nTo build the sources for cross-compilation, there may be extra dependencies beyond those you've installed by default with Ubuntu. If you find you need other things, please submit a pull request to change the documentation.\n\n\nEnter the following commands to build the sources and Device Tree files:\n\n\nFor Pi 1, Pi 0, Pi 0 W, or Compute Module:\n\n\ncd\n linux\n\nKERNEL\n=\nkernel\nmake \nARCH\n=\narm \nCROSS_COMPILE\n=\narm-linux-gnueabihf- bcmrpi_defconfig\n\n\n\n\n\nFor Pi 2, Pi 3, or Compute Module 3:\n\n\ncd\n linux\n\nKERNEL\n=\nkernel7\nmake \nARCH\n=\narm \nCROSS_COMPILE\n=\narm-linux-gnueabihf- bcm2709_defconfig\n\n\n\n\n\nThen, for both:\n\n\nmake \nARCH\n=\narm \nCROSS_COMPILE\n=\narm-linux-gnueabihf- zImage modules dtbs\n\n\n\n\n\nNote\n: To speed up compilation on multiprocessor systems, and get some improvement on single processor ones, use \n-j n\n, where n is the number of processors * 1.5. Alternatively, feel free to experiment and see what works!\n\n\nInstall directly onto the SD card\n\n\nHaving built the kernel, you need to copy it onto your Raspberry Pi and install the modules; this is best done directly using an SD card reader.\n\n\nFirst, use \nlsblk\n before and after plugging in your SD card to identify it. You should end up with something like this:\n\n\nsdb\n   sdb1\n   sdb2\n\n\n\n\n\nwith \nsdb1\n being the FAT (boot) partition, and \nsdb2\n being the ext4 filesystem (root) partition.\n\n\nIf it's a NOOBS card, you should see something like this:\n\n\nsdb\n  sdb1\n  sdb2\n  sdb5\n  sdb6\n  sdb7\n\n\n\n\n\nwith \nsdb6\n being the FAT (boot) partition, and \nsdb7\n being the ext4 filesystem (root) partition.\n\n\nMount these first, adjusting the partition numbers for NOOBS cards:\n\n\nmkdir mnt\nmkdir mnt/fat32\nmkdir mnt/ext4\nsudo mount /dev/sdb1 mnt/fat32\nsudo mount /dev/sdb2 mnt/ext4\n\n\n\n\n\nNext, install the modules:\n\n\nsudo make \nARCH\n=\narm \nCROSS_COMPILE\n=\narm-linux-gnueabihf- \nINSTALL_MOD_PATH\n=\nmnt/ext4 modules_install\n\n\n\n\n\nFinally, copy the kernel and Device Tree blobs onto the SD card, making sure to back up your old kernel:\n\n\nsudo cp mnt/fat32/\n$KERNEL\n.img mnt/fat32/\n$KERNEL\n-backup.img\nsudo cp arch/arm/boot/zImage mnt/fat32/\n$KERNEL\n.img\nsudo cp arch/arm/boot/dts/*.dtb mnt/fat32/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* mnt/fat32/overlays/\nsudo cp arch/arm/boot/dts/overlays/README mnt/fat32/overlays/\nsudo umount mnt/fat32\nsudo umount mnt/ext4\n\n\n\n\n\nAnother option is to copy the kernel into the same place, but with a different filename - for instance, kernel-myconfig.img - rather than overwriting the kernel.img file. You can then edit the config.txt file to select the kernel that the Pi will boot into:\n\n\nkernel=kernel-myconfig.img\n\n\n\n\n\nThis has the advantage of keeping your kernel separate from the kernel image managed by the system and any automatic update tools, and allowing you to easily revert to a stock kernel in the event that your kernel cannot boot.\n\n\nFinally, plug the card into the Pi and boot it!",
            "title": "Kernel building"
        },
        {
            "location": "/linux/kernel/building/index.html#kernel-building",
            "text": "There are two main methods for building the kernel. You can build locally on a Raspberry Pi, which will take a long time; or you can cross-compile, which is much quicker, but requires more setup.",
            "title": "Kernel building"
        },
        {
            "location": "/linux/kernel/building/index.html#local-building",
            "text": "On a Raspberry Pi, first install the latest version of  Raspbian . Then boot your Pi, plug in Ethernet to give you access to the sources, and log in.  First install Git and the build dependencies:  sudo apt-get install git bc  Next get the sources, which will take some time:  git clone --depth = 1  https://github.com/raspberrypi/linux  Configure the kernel; as well as the default configuration, you may wish to  configure your kernel in more detail  or  apply patches from another source , to add or remove required functionality:  Run the following commands, depending on your Raspberry Pi version.",
            "title": "Local building"
        },
        {
            "location": "/linux/kernel/building/index.html#raspberry-pi-1-pi-0-pi-0w-and-compute-module-default-build-configuration",
            "text": "cd  linux KERNEL = kernel\nmake bcmrpi_defconfig",
            "title": "Raspberry Pi 1, Pi 0, Pi 0W, and Compute Module default build configuration"
        },
        {
            "location": "/linux/kernel/building/index.html#raspberry-pi-2-pi-3-and-compute-module-3-default-build-configuration",
            "text": "cd  linux KERNEL = kernel7\nmake bcm2709_defconfig  Build and install the kernel, modules, and Device Tree blobs; this step takes a  long  time:  make -j4 zImage modules dtbs\nsudo make modules_install\nsudo cp arch/arm/boot/dts/*.dtb /boot/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/\nsudo cp arch/arm/boot/dts/overlays/README /boot/overlays/\nsudo cp arch/arm/boot/zImage /boot/ $KERNEL .img  Note : On a Raspberry Pi 2/3, the  -j4  flag splits the work between all four cores, speeding up compilation significantly.",
            "title": "Raspberry Pi 2, Pi 3, and Compute Module 3 default build configuration"
        },
        {
            "location": "/linux/kernel/building/index.html#cross-compiling",
            "text": "First, you will need a suitable Linux cross-compilation host. We tend to use Ubuntu; since Raspbian is \nalso a Debian distribution, it means many aspects are similar, such as the command lines.  You can either do this using VirtualBox (or VMWare) on Windows, or install it directly onto your computer. For reference, you can follow instructions online  at Wikihow .",
            "title": "Cross-compiling"
        },
        {
            "location": "/linux/kernel/building/index.html#install-toolchain",
            "text": "Use the following command to download the toolchain to the home folder:  git clone https://github.com/raspberrypi/tools ~/tools  Updating the $PATH environment variable makes the system aware of file locations needed for cross-compilation. On a 32-bit host system you can update and reload it using:  echo   PATH = \\$ PATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian/bin >> ~/.bashrc source  ~/.bashrc  If you are on a 64-bit host system, you should use:  echo   PATH = \\$ PATH:~/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin >> ~/.bashrc source  ~/.bashrc",
            "title": "Install toolchain"
        },
        {
            "location": "/linux/kernel/building/index.html#get-sources",
            "text": "To get the sources, refer to the original  GitHub  repository for the various branches.  $ git clone --depth = 1  https://github.com/raspberrypi/linux",
            "title": "Get sources"
        },
        {
            "location": "/linux/kernel/building/index.html#build-sources",
            "text": "To build the sources for cross-compilation, there may be extra dependencies beyond those you've installed by default with Ubuntu. If you find you need other things, please submit a pull request to change the documentation.  Enter the following commands to build the sources and Device Tree files:  For Pi 1, Pi 0, Pi 0 W, or Compute Module:  cd  linux KERNEL = kernel\nmake  ARCH = arm  CROSS_COMPILE = arm-linux-gnueabihf- bcmrpi_defconfig  For Pi 2, Pi 3, or Compute Module 3:  cd  linux KERNEL = kernel7\nmake  ARCH = arm  CROSS_COMPILE = arm-linux-gnueabihf- bcm2709_defconfig  Then, for both:  make  ARCH = arm  CROSS_COMPILE = arm-linux-gnueabihf- zImage modules dtbs  Note : To speed up compilation on multiprocessor systems, and get some improvement on single processor ones, use  -j n , where n is the number of processors * 1.5. Alternatively, feel free to experiment and see what works!",
            "title": "Build sources"
        },
        {
            "location": "/linux/kernel/building/index.html#install-directly-onto-the-sd-card",
            "text": "Having built the kernel, you need to copy it onto your Raspberry Pi and install the modules; this is best done directly using an SD card reader.  First, use  lsblk  before and after plugging in your SD card to identify it. You should end up with something like this:  sdb\n   sdb1\n   sdb2  with  sdb1  being the FAT (boot) partition, and  sdb2  being the ext4 filesystem (root) partition.  If it's a NOOBS card, you should see something like this:  sdb\n  sdb1\n  sdb2\n  sdb5\n  sdb6\n  sdb7  with  sdb6  being the FAT (boot) partition, and  sdb7  being the ext4 filesystem (root) partition.  Mount these first, adjusting the partition numbers for NOOBS cards:  mkdir mnt\nmkdir mnt/fat32\nmkdir mnt/ext4\nsudo mount /dev/sdb1 mnt/fat32\nsudo mount /dev/sdb2 mnt/ext4  Next, install the modules:  sudo make  ARCH = arm  CROSS_COMPILE = arm-linux-gnueabihf-  INSTALL_MOD_PATH = mnt/ext4 modules_install  Finally, copy the kernel and Device Tree blobs onto the SD card, making sure to back up your old kernel:  sudo cp mnt/fat32/ $KERNEL .img mnt/fat32/ $KERNEL -backup.img\nsudo cp arch/arm/boot/zImage mnt/fat32/ $KERNEL .img\nsudo cp arch/arm/boot/dts/*.dtb mnt/fat32/\nsudo cp arch/arm/boot/dts/overlays/*.dtb* mnt/fat32/overlays/\nsudo cp arch/arm/boot/dts/overlays/README mnt/fat32/overlays/\nsudo umount mnt/fat32\nsudo umount mnt/ext4  Another option is to copy the kernel into the same place, but with a different filename - for instance, kernel-myconfig.img - rather than overwriting the kernel.img file. You can then edit the config.txt file to select the kernel that the Pi will boot into:  kernel=kernel-myconfig.img  This has the advantage of keeping your kernel separate from the kernel image managed by the system and any automatic update tools, and allowing you to easily revert to a stock kernel in the event that your kernel cannot boot.  Finally, plug the card into the Pi and boot it!",
            "title": "Install directly onto the SD card"
        },
        {
            "location": "/linux/kernel/configuring/index.html",
            "text": "Configuring the kernel\n\n\nThe Linux kernel is highly configurable; advanced users may wish to modify the default configuration to customise it to their needs, such as enabling a new or experimental network protocol, or enabling support for new hardware.\n\n\nConfiguration is most commonly done through the \nmake menuconfig\n interface. Alternatively, you can modify your \n.config\n file manually, but this can be more difficult for new users.\n\n\nPreparing to configure the kernel\n\n\nThe \nmenuconfig\n tool requires the \nncurses\n development headers to compile properly. These can be installed with the following command:\n\n\n$ sudo apt-get install libncurses5-dev\n\n\n\n\n\nYou'll also need to download and prepare your kernel sources, as described in the \nbuild guide\n. In particular, ensure you have installed the default configuration.\n\n\nFor all models of Raspberry Pi 1 (includes Compute Module and Pi Zero):\n\n\n$ \nKERNEL\n=\nkernel\n$ make bcmrpi_defconfig\n\n\n\n\n\nIf you're cross-compiling, the second line should be:\n\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcmrpi_defconfig\n\n\n\n\n\nFor all models of Raspberry Pi 2/3:\n\n\n$ \nKERNEL\n=\nkernel7\n$ make bcm2709_defconfig\n\n\n\n\n\nIf you're cross-compiling, the second line should be:\n\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig\n\n\n\n\n\nUsing menuconfig\n\n\nOnce you've got everything set up and ready to go, you can compile and run the \nmenuconfig\n utility as follows:\n\n\n$ make menuconfig\n\n\n\n\n\nIf you're cross-compiling,:\n\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig\n\n\n\n\n\nThe \nmenuconfig\n utility has simple keyboard navigation. After a brief compilation, you'll be presented with a list of submenus containing all the options you can configure; there's a lot, so take your time to read through them and get acquainted.\n\n\nUse the arrow keys to navigate, the Enter key to enter a submenu (indicated by \n--->\n), Escape twice to go up a level or exit, and the space bar to cycle the state of an option. Some options have multiple choices, in which case they'll appear as a submenu and the Enter key will select an option. You can press \nh\n on most entries to get help about that specific option or menu.\n\n\nResist the temptation to enable or disable a lot of things on your first attempt; it's relatively easy to break your configuration, so start small and get comfortable with the configuration and build process.\n\n\nExiting, saving, and loading configurations\n\n\nOnce you're done making the changes you want, press Escape until you're prompted to save your new configuration. By default, this will save to the \n.config\n file. You can save and load configurations by copying this file around.",
            "title": "Configuring the kernel"
        },
        {
            "location": "/linux/kernel/configuring/index.html#configuring-the-kernel",
            "text": "The Linux kernel is highly configurable; advanced users may wish to modify the default configuration to customise it to their needs, such as enabling a new or experimental network protocol, or enabling support for new hardware.  Configuration is most commonly done through the  make menuconfig  interface. Alternatively, you can modify your  .config  file manually, but this can be more difficult for new users.",
            "title": "Configuring the kernel"
        },
        {
            "location": "/linux/kernel/configuring/index.html#preparing-to-configure-the-kernel",
            "text": "The  menuconfig  tool requires the  ncurses  development headers to compile properly. These can be installed with the following command:  $ sudo apt-get install libncurses5-dev  You'll also need to download and prepare your kernel sources, as described in the  build guide . In particular, ensure you have installed the default configuration.  For all models of Raspberry Pi 1 (includes Compute Module and Pi Zero):  $  KERNEL = kernel\n$ make bcmrpi_defconfig  If you're cross-compiling, the second line should be:  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcmrpi_defconfig  For all models of Raspberry Pi 2/3:  $  KERNEL = kernel7\n$ make bcm2709_defconfig  If you're cross-compiling, the second line should be:  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig",
            "title": "Preparing to configure the kernel"
        },
        {
            "location": "/linux/kernel/configuring/index.html#using-menuconfig",
            "text": "Once you've got everything set up and ready to go, you can compile and run the  menuconfig  utility as follows:  $ make menuconfig  If you're cross-compiling,:  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig  The  menuconfig  utility has simple keyboard navigation. After a brief compilation, you'll be presented with a list of submenus containing all the options you can configure; there's a lot, so take your time to read through them and get acquainted.  Use the arrow keys to navigate, the Enter key to enter a submenu (indicated by  ---> ), Escape twice to go up a level or exit, and the space bar to cycle the state of an option. Some options have multiple choices, in which case they'll appear as a submenu and the Enter key will select an option. You can press  h  on most entries to get help about that specific option or menu.  Resist the temptation to enable or disable a lot of things on your first attempt; it's relatively easy to break your configuration, so start small and get comfortable with the configuration and build process.",
            "title": "Using menuconfig"
        },
        {
            "location": "/linux/kernel/configuring/index.html#exiting-saving-and-loading-configurations",
            "text": "Once you're done making the changes you want, press Escape until you're prompted to save your new configuration. By default, this will save to the  .config  file. You can save and load configurations by copying this file around.",
            "title": "Exiting, saving, and loading configurations"
        },
        {
            "location": "/linux/kernel/headers/index.html",
            "text": "Kernel Headers\n\n\nIf you are compiling a kernel module or similar, you will need the Linux Kernel headers. These provide the various function and structure definitions required when compiling code that interfaces with the kernel.\n\n\nIf you have cloned the entire kernel from github, the headers are already included in the source tree. If you don't need all the extra files, it is possible to install only the kernel headers from the Raspbian repo.\n\n\nsudo apt-get install raspberrypi-kernel-headers\n\n\n\n\n\nNote that it can take quite a while for this command to complete, as it installs a lot of small files. There is no progress indicator.\n\n\nWhen a new kernel release is made, you will need the headers that match that kernel version. It can take several weeks for the repo to be updated to reflect the latest kernel version. If this happens, the best approach is to clone the kernel as described in the \nBuild Section\n.",
            "title": "Kernel Headers"
        },
        {
            "location": "/linux/kernel/headers/index.html#kernel-headers",
            "text": "If you are compiling a kernel module or similar, you will need the Linux Kernel headers. These provide the various function and structure definitions required when compiling code that interfaces with the kernel.  If you have cloned the entire kernel from github, the headers are already included in the source tree. If you don't need all the extra files, it is possible to install only the kernel headers from the Raspbian repo.  sudo apt-get install raspberrypi-kernel-headers  Note that it can take quite a while for this command to complete, as it installs a lot of small files. There is no progress indicator.  When a new kernel release is made, you will need the headers that match that kernel version. It can take several weeks for the repo to be updated to reflect the latest kernel version. If this happens, the best approach is to clone the kernel as described in the  Build Section .",
            "title": "Kernel Headers"
        },
        {
            "location": "/linux/kernel/patching/index.html",
            "text": "Patching the kernel\n\n\nWhen \nbuilding\n your custom kernel you may wish to apply patches, or collections of patches ('patchsets'), to the Linux kernel.\n\n\nPatchsets are often provided with newer hardware as a temporary measure, before the patches are applied to the upstream Linux kernel ('mainline') and then propagated down to the Raspberry Pi kernel sources. However, patchsets for other purposes exist, for instance to enable a fully pre-emptible kernel for real-time usage.\n\n\nVersion identification\n\n\nIt's important to check what version of the kernel you have when downloading and applying patches. In a kernel source directory, the following command will show you the version the sources relate to:\n\n\n$ head Makefile -n \n3\n\n\nVERSION\n \n=\n \n3\n\n\nPATCHLEVEL\n \n=\n \n10\n\n\nSUBLEVEL\n \n=\n \n25\n\n\n\n\n\n\nIn this instance, the sources are for a 3.10.25 kernel. You can see what version you're running on your system with the \nuname -r\n command.\n\n\nApplying patches\n\n\nHow you apply patches depends on the format in which the patches are made available. Most patches are a single file, and applied with the \npatch\n utility. For example, let's download and patch our example kernel version with the real-time kernel patches:\n\n\n$ wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.10/older/patch-3.10.25-rt23.patch.gz\n$ gunzip patch-3.10.25-rt23.patch.gz\n$ cat patch-3.10.25-rt23.patch \n|\n patch -p1\n\n\n\n\n\nIn our example we simply download the file, uncompress it, and then pass it to the \npatch\n utility using the \ncat\n tool and a Unix pipe.\n\n\nSome patchsets come as mailbox-format patchsets, arranged as a folder of patch files. We can use Git to apply these patches to our kernel, but first we must configure Git to let it know who we are when we make these changes:\n\n\n$ git config --global user.name \n\"Your name\"\n\n$ git config --global user.email \n\"your email in here\"\n\n\n\n\n\n\nOnce we've done this we can apply the patches:\n\n\ngit am -3 /path/to/patches/*\n\n\n\n\n\nIf in doubt, consult with the distributor of the patches, who should tell you how to apply them. Some patchsets will require a specific commit to patch against; follow the details provided by the patch distributor.",
            "title": "Patching the kernel"
        },
        {
            "location": "/linux/kernel/patching/index.html#patching-the-kernel",
            "text": "When  building  your custom kernel you may wish to apply patches, or collections of patches ('patchsets'), to the Linux kernel.  Patchsets are often provided with newer hardware as a temporary measure, before the patches are applied to the upstream Linux kernel ('mainline') and then propagated down to the Raspberry Pi kernel sources. However, patchsets for other purposes exist, for instance to enable a fully pre-emptible kernel for real-time usage.",
            "title": "Patching the kernel"
        },
        {
            "location": "/linux/kernel/patching/index.html#version-identification",
            "text": "It's important to check what version of the kernel you have when downloading and applying patches. In a kernel source directory, the following command will show you the version the sources relate to:  $ head Makefile -n  3  VERSION   =   3  PATCHLEVEL   =   10  SUBLEVEL   =   25   In this instance, the sources are for a 3.10.25 kernel. You can see what version you're running on your system with the  uname -r  command.",
            "title": "Version identification"
        },
        {
            "location": "/linux/kernel/patching/index.html#applying-patches",
            "text": "How you apply patches depends on the format in which the patches are made available. Most patches are a single file, and applied with the  patch  utility. For example, let's download and patch our example kernel version with the real-time kernel patches:  $ wget https://www.kernel.org/pub/linux/kernel/projects/rt/3.10/older/patch-3.10.25-rt23.patch.gz\n$ gunzip patch-3.10.25-rt23.patch.gz\n$ cat patch-3.10.25-rt23.patch  |  patch -p1  In our example we simply download the file, uncompress it, and then pass it to the  patch  utility using the  cat  tool and a Unix pipe.  Some patchsets come as mailbox-format patchsets, arranged as a folder of patch files. We can use Git to apply these patches to our kernel, but first we must configure Git to let it know who we are when we make these changes:  $ git config --global user.name  \"Your name\" \n$ git config --global user.email  \"your email in here\"   Once we've done this we can apply the patches:  git am -3 /path/to/patches/*  If in doubt, consult with the distributor of the patches, who should tell you how to apply them. Some patchsets will require a specific commit to patch against; follow the details provided by the patch distributor.",
            "title": "Applying patches"
        },
        {
            "location": "/linux/kernel/updating/index.html",
            "text": "Updating the kernel\n\n\nIf you use the standard Raspbian update/upgrade process (found \nhere\n), this will automatically update the kernel to the latest stable version. This is the recommended procedure. However, in certain circumstances, you may wish to update to the latest 'bleeding edge' or test kernel.\n\n\nManual updates using rpi-update\n\n\nThe \nrpi-update\n utility will download the latest (unstable, testing) kernel version and copy all required files onto your system. Note that the latest kernel from \nrpi-update\n is not guaranteed to work correctly! Make sure that it doesn't conflict with your distribution packages. It doesn't provide a way of automatically uninstalling the files.\n\n\nAfter upgrading the kernel, you'll have to reboot your Pi to switch to the updated version.\n\n\nIf you're using a compiled kernel, rpi-update will have overwritten it, and you will need to \nrebuild\n and reinstall your kernel.\n\n\nCustom \nconfigurations\n can usually be copied over between minor kernel updates, but it's safer to use the \ndiff\n utility to see what's changed and repeat your changes on the new configuration.\n\n\nReverting back to current stock Raspbian kernel\n\n\nThe Raspberry Pi Foundation kernel is part of the \nraspberrypi-kernel\n package, and the bootloader files are part of the \nraspberrypi-bootloader\n package. To revert to the current stock Raspbian kernel after trying \nrpi-update\n or a custom kernel, you need to reinstall both these packages, by running:\n\n\nsudo apt-get install --reinstall raspberrypi-bootloader raspberrypi-kernel",
            "title": "Updating the kernel"
        },
        {
            "location": "/linux/kernel/updating/index.html#updating-the-kernel",
            "text": "If you use the standard Raspbian update/upgrade process (found  here ), this will automatically update the kernel to the latest stable version. This is the recommended procedure. However, in certain circumstances, you may wish to update to the latest 'bleeding edge' or test kernel.",
            "title": "Updating the kernel"
        },
        {
            "location": "/linux/kernel/updating/index.html#manual-updates-using-rpi-update",
            "text": "The  rpi-update  utility will download the latest (unstable, testing) kernel version and copy all required files onto your system. Note that the latest kernel from  rpi-update  is not guaranteed to work correctly! Make sure that it doesn't conflict with your distribution packages. It doesn't provide a way of automatically uninstalling the files.  After upgrading the kernel, you'll have to reboot your Pi to switch to the updated version.  If you're using a compiled kernel, rpi-update will have overwritten it, and you will need to  rebuild  and reinstall your kernel.  Custom  configurations  can usually be copied over between minor kernel updates, but it's safer to use the  diff  utility to see what's changed and repeat your changes on the new configuration.",
            "title": "Manual updates using rpi-update"
        },
        {
            "location": "/linux/kernel/updating/index.html#reverting-back-to-current-stock-raspbian-kernel",
            "text": "The Raspberry Pi Foundation kernel is part of the  raspberrypi-kernel  package, and the bootloader files are part of the  raspberrypi-bootloader  package. To revert to the current stock Raspbian kernel after trying  rpi-update  or a custom kernel, you need to reinstall both these packages, by running:  sudo apt-get install --reinstall raspberrypi-bootloader raspberrypi-kernel",
            "title": "Reverting back to current stock Raspbian kernel"
        },
        {
            "location": "/linux/software/README/index.html",
            "text": "Installing software\n\n\nThere are different ways of installing software on your Raspberry Pi, depending on where the source of the software lives.\n\n\nThe most common is through the command line tool APT (Advanced Packaging Tool). Some software can also be installed using other package managers.\n\n\nContents\n\n\n\n\nAPT\n\n\nUse \napt-get install\n to install software from the Raspbian archives\n\n\n\n\n\n\nPython\n\n\nSome Python software can be installed using Python's package manager \npip\n\n\n\n\n\n\nRuby\n\n\nSome Ruby software can be installed with Ruby's package manager \nruby gems",
            "title": "Installing software"
        },
        {
            "location": "/linux/software/README/index.html#installing-software",
            "text": "There are different ways of installing software on your Raspberry Pi, depending on where the source of the software lives.  The most common is through the command line tool APT (Advanced Packaging Tool). Some software can also be installed using other package managers.",
            "title": "Installing software"
        },
        {
            "location": "/linux/software/README/index.html#contents",
            "text": "APT  Use  apt-get install  to install software from the Raspbian archives    Python  Some Python software can be installed using Python's package manager  pip    Ruby  Some Ruby software can be installed with Ruby's package manager  ruby gems",
            "title": "Contents"
        },
        {
            "location": "/linux/software/apt/index.html",
            "text": "APT\n\n\nThe easiest way to manage installing, upgrading, and removing software is using APT (Advanced Packaging Tool) from Debian. If a piece of software is packaged in Debian and it works on the Raspberry Pi's ARM architecture, it should also be available in Raspbian.\n\n\nTo install or remove packages you need root user permissions, so your user needs to be in \nsudoers\n or you must be logged in as \nroot\n. Read more about \nusers\n and \nroot\n.\n\n\nTo install new packages, or update existing ones, you'll need an internet connection.\n\n\nNote that installing software uses up disk space on your SD card, so you should keep an eye on disk usage and use an appropriately sized SD card.\n\n\nAlso note that a lock is performed while software is installing, so you can't install multiple packages at the same time.\n\n\nSoftware sources\n\n\nAPT keeps a list of software sources on your Pi in a file at \n/etc/apt/sources.list\n. Before installing software, you should update your package list with \napt-get update\n:\n\n\nsudo apt-get update\n\n\n\n\n\nInstalling a package with APT\n\n\nsudo apt-get install tree\n\n\n\n\n\nTyping this command should inform the user how much disk space the package will take up and asks for confirmation of the package installation. Entering \nY\n (or just pressing \nEnter\n, as yes is the default action) will allow the installation to occur. This can be bypassed by adding the \n-y\n flag to the command:\n\n\nsudo apt-get install tree -y\n\n\n\n\n\nInstalling this package makes \ntree\n available for the user.\n\n\nUsing an installed package\n\n\ntree\n is a command-line tool which provides a visualisation of the structure of the current directory, and all its contents.\n\n\n\n\nTyping \ntree\n runs the tree command. For example:\n\n\n\n\ntree\n..\n\u251c\u2500\u2500 hello.py\n\u251c\u2500\u2500 games\n\u2502   \u251c\u2500\u2500 asteroids.py\n\u2502   \u251c\u2500\u2500 pacman.py\n\u2502   \u251c\u2500\u2500 README.txt\n\u2502   \u2514\u2500\u2500 tetris.py\n\n\n\n\n\n\n\nTyping \nman tree\n gives the manual entry for the package \ntree\n.\n\n\nTyping \nwhereis tree\n shows where \ntree\n lives:\n\n\n\n\ntree: /usr/bin/tree\n\n\n\n\n\nUninstalling a package with APT\n\n\nRemove\n\n\nYou can uninstall a package with \napt-get remove\n:\n\n\nsudo apt-get remove tree\n\n\n\n\n\nThe user is prompted to confirm the removal. Again, the \n-y\n flag will auto-confirm.\n\n\nPurge\n\n\nYou can also choose to completely remove the package and its associated configuration files with \napt-get purge\n:\n\n\nsudo apt-get purge tree\n\n\n\n\n\nUpgrading existing software\n\n\nIf software updates are available, you can get the updates with \nsudo apt-get update\n and install the updates with \nsudo apt-get upgrade\n, which will upgrade all of your packages. To upgrade a specific package, without upgrading all the other out-of-date packages at the same time, you can use \nsudo apt-get install somepackage\n (which may be useful if you're low on disk space or you have limited download bandwidth).\n\n\nSearching for software\n\n\nYou can search the archives for a package with a given keyword with \napt-cache search\n:\n\n\napt-cache search locomotive\nsl - Correct you \nif\n you \ntype\n \n`\nsl\n'\n by mistake\n\n\n\n\n\nYou can view more information about a package before installing it with \napt-cache show\n:\n\n\napt-cache show sl\nPackage: sl\nVersion: \n3\n.03-17\nArchitecture: armhf\nMaintainer: Hiroyuki Yamamoto <yama1066@gmail.com>\nInstalled-Size: \n114\n\nDepends: libc6 \n(\n>\n=\n \n2\n.4\n)\n, libncurses5 \n(\n>\n=\n \n5\n.5-5~\n)\n, libtinfo5\nHomepage: http://www.tkl.iis.u-tokyo.ac.jp/~toyoda/index_e.html\nPriority: optional\nSection: games\nFilename: pool/main/s/sl/sl_3.03-17_armhf.deb\nSize: \n26246\n\nSHA256: 42dea9d7c618af8fe9f3c810b3d551102832bf217a5bcdba310f119f62117dfb\nSHA1: b08039acccecd721fc3e6faf264fe59e56118e74\nMD5sum: 450b21cc998dc9026313f72b4bd9807b\nDescription: Correct you \nif\n you \ntype\n \n`\nsl\n' by mistake\n\n\n Sl is a program that can display animations aimed to correct you\n\n\n if you type '\nsl\n'\n by mistake.\n SL stands \nfor\n Steam Locomotive.",
            "title": "APT"
        },
        {
            "location": "/linux/software/apt/index.html#apt",
            "text": "The easiest way to manage installing, upgrading, and removing software is using APT (Advanced Packaging Tool) from Debian. If a piece of software is packaged in Debian and it works on the Raspberry Pi's ARM architecture, it should also be available in Raspbian.  To install or remove packages you need root user permissions, so your user needs to be in  sudoers  or you must be logged in as  root . Read more about  users  and  root .  To install new packages, or update existing ones, you'll need an internet connection.  Note that installing software uses up disk space on your SD card, so you should keep an eye on disk usage and use an appropriately sized SD card.  Also note that a lock is performed while software is installing, so you can't install multiple packages at the same time.",
            "title": "APT"
        },
        {
            "location": "/linux/software/apt/index.html#software-sources",
            "text": "APT keeps a list of software sources on your Pi in a file at  /etc/apt/sources.list . Before installing software, you should update your package list with  apt-get update :  sudo apt-get update",
            "title": "Software sources"
        },
        {
            "location": "/linux/software/apt/index.html#installing-a-package-with-apt",
            "text": "sudo apt-get install tree  Typing this command should inform the user how much disk space the package will take up and asks for confirmation of the package installation. Entering  Y  (or just pressing  Enter , as yes is the default action) will allow the installation to occur. This can be bypassed by adding the  -y  flag to the command:  sudo apt-get install tree -y  Installing this package makes  tree  available for the user.",
            "title": "Installing a package with APT"
        },
        {
            "location": "/linux/software/apt/index.html#using-an-installed-package",
            "text": "tree  is a command-line tool which provides a visualisation of the structure of the current directory, and all its contents.   Typing  tree  runs the tree command. For example:   tree\n..\n\u251c\u2500\u2500 hello.py\n\u251c\u2500\u2500 games\n\u2502   \u251c\u2500\u2500 asteroids.py\n\u2502   \u251c\u2500\u2500 pacman.py\n\u2502   \u251c\u2500\u2500 README.txt\n\u2502   \u2514\u2500\u2500 tetris.py   Typing  man tree  gives the manual entry for the package  tree .  Typing  whereis tree  shows where  tree  lives:   tree: /usr/bin/tree",
            "title": "Using an installed package"
        },
        {
            "location": "/linux/software/apt/index.html#uninstalling-a-package-with-apt",
            "text": "",
            "title": "Uninstalling a package with APT"
        },
        {
            "location": "/linux/software/apt/index.html#remove",
            "text": "You can uninstall a package with  apt-get remove :  sudo apt-get remove tree  The user is prompted to confirm the removal. Again, the  -y  flag will auto-confirm.",
            "title": "Remove"
        },
        {
            "location": "/linux/software/apt/index.html#purge",
            "text": "You can also choose to completely remove the package and its associated configuration files with  apt-get purge :  sudo apt-get purge tree",
            "title": "Purge"
        },
        {
            "location": "/linux/software/apt/index.html#upgrading-existing-software",
            "text": "If software updates are available, you can get the updates with  sudo apt-get update  and install the updates with  sudo apt-get upgrade , which will upgrade all of your packages. To upgrade a specific package, without upgrading all the other out-of-date packages at the same time, you can use  sudo apt-get install somepackage  (which may be useful if you're low on disk space or you have limited download bandwidth).",
            "title": "Upgrading existing software"
        },
        {
            "location": "/linux/software/apt/index.html#searching-for-software",
            "text": "You can search the archives for a package with a given keyword with  apt-cache search :  apt-cache search locomotive\nsl - Correct you  if  you  type   ` sl '  by mistake  You can view more information about a package before installing it with  apt-cache show :  apt-cache show sl\nPackage: sl\nVersion:  3 .03-17\nArchitecture: armhf\nMaintainer: Hiroyuki Yamamoto <yama1066@gmail.com>\nInstalled-Size:  114 \nDepends: libc6  ( > =   2 .4 ) , libncurses5  ( > =   5 .5-5~ ) , libtinfo5\nHomepage: http://www.tkl.iis.u-tokyo.ac.jp/~toyoda/index_e.html\nPriority: optional\nSection: games\nFilename: pool/main/s/sl/sl_3.03-17_armhf.deb\nSize:  26246 \nSHA256: 42dea9d7c618af8fe9f3c810b3d551102832bf217a5bcdba310f119f62117dfb\nSHA1: b08039acccecd721fc3e6faf264fe59e56118e74\nMD5sum: 450b21cc998dc9026313f72b4bd9807b\nDescription: Correct you  if  you  type   ` sl ' by mistake   Sl is a program that can display animations aimed to correct you   if you type ' sl '  by mistake.\n SL stands  for  Steam Locomotive.",
            "title": "Searching for software"
        },
        {
            "location": "/linux/software/python/index.html",
            "text": "Installing Python packages\n\n\nAPT\n\n\nSome Python packages can be found in the Raspbian archives and can be installed using APT. For example:\n\n\nsudo apt-get update\nsudo apt-get install python3-picamera\n\n\n\n\n\nThis is the preferred method of installing software, as it means that the modules you install can be kept up to date easily with the usual \nsudo apt-get update\n and \nsudo apt-get upgrade\n commands.\n\n\nPython packages in Raspbian which are compatible with Python 2.x will always have a \npython-\n prefix. So, the \npicamera\n package for Python 2.x is named \npython-picamera\n (as shown in the example above). Python 3 packages always have a \npython3-\n prefix. So, to install \npicamera\n for Python 3 you would use:\n\n\nsudo apt-get install python3-picamera\n\n\n\n\n\nUninstalling packages installed via APT can be accomplished as follows:\n\n\nsudo apt-get remove python3-picamera\n\n\n\n\n\nThey can be completely removed with \npurge\n:\n\n\nsudo apt-get purge python3-picamera\n\n\n\n\n\npip\n\n\nNot all Python packages are available in the Raspbian archives, and those that are can sometimes be out-of-date. If you can't find a suitable version in the Raspbian archives, you can install packages from the \nPython Package Index\n (PyPI). To do so, use the \npip\n tool.\n\n\npip\n is installed by default in Raspbian Jessie (but not Raspbian Wheezy or Jessie Lite). You can install it with \napt\n:\n\n\nsudo apt-get install python3-pip\n\n\n\n\n\nTo get the Python 2 version:\n\n\nsudo apt-get install python-pip\n\n\n\n\n\npip3\n installs modules for Python 3, and \npip\n installs modules for Python 2.\n\n\nFor example, the following command installs the Unicorn HAT library for Python 3:\n\n\npip3 install unicornhat\n\n\n\n\n\nThe following command installs the Unicorn HAT library for Python 2:\n\n\npip install unicornhat\n\n\n\n\n\nNote\n: In Raspbian Wheezy, the command for managing Python 3 packages was \npip-3.2\n, not \npip3\n.\n\n\nUninstall Python modules with \npip3 uninstall\n or \npip uninstall\n.\n\n\nUpload your own Python modules to \npip\n with the \nguide at PyPI\n.",
            "title": "Installing Python packages"
        },
        {
            "location": "/linux/software/python/index.html#installing-python-packages",
            "text": "",
            "title": "Installing Python packages"
        },
        {
            "location": "/linux/software/python/index.html#apt",
            "text": "Some Python packages can be found in the Raspbian archives and can be installed using APT. For example:  sudo apt-get update\nsudo apt-get install python3-picamera  This is the preferred method of installing software, as it means that the modules you install can be kept up to date easily with the usual  sudo apt-get update  and  sudo apt-get upgrade  commands.  Python packages in Raspbian which are compatible with Python 2.x will always have a  python-  prefix. So, the  picamera  package for Python 2.x is named  python-picamera  (as shown in the example above). Python 3 packages always have a  python3-  prefix. So, to install  picamera  for Python 3 you would use:  sudo apt-get install python3-picamera  Uninstalling packages installed via APT can be accomplished as follows:  sudo apt-get remove python3-picamera  They can be completely removed with  purge :  sudo apt-get purge python3-picamera",
            "title": "APT"
        },
        {
            "location": "/linux/software/python/index.html#pip",
            "text": "Not all Python packages are available in the Raspbian archives, and those that are can sometimes be out-of-date. If you can't find a suitable version in the Raspbian archives, you can install packages from the  Python Package Index  (PyPI). To do so, use the  pip  tool.  pip  is installed by default in Raspbian Jessie (but not Raspbian Wheezy or Jessie Lite). You can install it with  apt :  sudo apt-get install python3-pip  To get the Python 2 version:  sudo apt-get install python-pip  pip3  installs modules for Python 3, and  pip  installs modules for Python 2.  For example, the following command installs the Unicorn HAT library for Python 3:  pip3 install unicornhat  The following command installs the Unicorn HAT library for Python 2:  pip install unicornhat  Note : In Raspbian Wheezy, the command for managing Python 3 packages was  pip-3.2 , not  pip3 .  Uninstall Python modules with  pip3 uninstall  or  pip uninstall .  Upload your own Python modules to  pip  with the  guide at PyPI .",
            "title": "pip"
        },
        {
            "location": "/linux/software/ruby/index.html",
            "text": "Installing Ruby packages\n\n\nRuby's package manager is called Ruby Gems. You can browse the available gems at \nrubygems.org\n.\n\n\nInstall Ruby Gems\n\n\nYou can install Ruby Gems on your Raspberry Pi using APT:\n\n\nsudo apt-get install rubygems\n\n\n\n\n\nInstall packages using Ruby Gems\n\n\nYou can install packages using Gems. For example, to install \njekyll\n:\n\n\nsudo gem install jekyll",
            "title": "Installing Ruby packages"
        },
        {
            "location": "/linux/software/ruby/index.html#installing-ruby-packages",
            "text": "Ruby's package manager is called Ruby Gems. You can browse the available gems at  rubygems.org .",
            "title": "Installing Ruby packages"
        },
        {
            "location": "/linux/software/ruby/index.html#install-ruby-gems",
            "text": "You can install Ruby Gems on your Raspberry Pi using APT:  sudo apt-get install rubygems",
            "title": "Install Ruby Gems"
        },
        {
            "location": "/linux/software/ruby/index.html#install-packages-using-ruby-gems",
            "text": "You can install packages using Gems. For example, to install  jekyll :  sudo gem install jekyll",
            "title": "Install packages using Ruby Gems"
        },
        {
            "location": "/linux/usage/README/index.html",
            "text": "Linux usage\n\n\nSome general help with Linux usage.\n\n\nContents\n\n\n\n\nCommands\n\n\nSome basic and more advanced Linux commands\n\n\n\n\n\n\nText editors\n\n\nA selection of text editors available on the Pi\n\n\n\n\n\n\nUsers\n\n\nSetting up multiple Linux users on your Pi system\n\n\n\n\n\n\nRoot\n\n\nThe \nroot\n user and the \nsudo\n prefix\n\n\n\n\n\n\nCron / Crontab\n\n\nSetting up scheduled tasks\n\n\n\n\n\n\n.bashrc and .bash_aliases\n\n\nYour shell configuration and aliases\n\n\n\n\n\n\nsystemd\n\n\nConfiguration of systemd services to start scripts at booting\n\n\n\n\n\n\nrc.local\n\n\nConfiguration of initialisation",
            "title": "Linux usage"
        },
        {
            "location": "/linux/usage/README/index.html#linux-usage",
            "text": "Some general help with Linux usage.",
            "title": "Linux usage"
        },
        {
            "location": "/linux/usage/README/index.html#contents",
            "text": "Commands  Some basic and more advanced Linux commands    Text editors  A selection of text editors available on the Pi    Users  Setting up multiple Linux users on your Pi system    Root  The  root  user and the  sudo  prefix    Cron / Crontab  Setting up scheduled tasks    .bashrc and .bash_aliases  Your shell configuration and aliases    systemd  Configuration of systemd services to start scripts at booting    rc.local  Configuration of initialisation",
            "title": "Contents"
        },
        {
            "location": "/linux/usage/bashrc/index.html",
            "text": ".bashrc and .bash_aliases\n\n\nIn your home folder you will find a hidden file called \n.bashrc\n which contains some user configuration options. You can edit this file to suit your needs. Changes made in this file will be actioned the next time a terminal is opened, since that is when the \n.bashrc\n file is read.\n\n\nIf you want your changes to take place in your current terminal, you can use either \nsource ~/.bashrc\n or \nexec bash\n. These actually do slightly different things: the former simply re-executes the \n.bashrc\n file, which may result in undesirable changes to things like the path, the latter replaces the current shell with a new bash shell, which resets the shell back to the state at login, throwing away any shell variables you may have set. Choose whichever is most appropriate.\n\n\nSome useful adaptions are provided for you; some of these are commented out with a \n#\n by default. To enable them, remove the \n#\n and they will be active next time you boot your Pi or start a new terminal.\n\n\nFor example, some \nls\n aliases:\n\n\nalias ls='ls --color=auto'\n#alias dir='dir --color=auto'\n#alias vdir='vdir --color=auto'\n\nalias grep='grep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias egrep='egrep --color=auto'\n\n\n\n\n\nAliases like these are provided to help users of other systems like Microsoft Windows (\ndir\n is the \nls\n of DOS/Windows). Others are to add colour to the output of commands like \nls\n and \ngrep\n by default.\n\n\nMore variations of \nls\n are also provided:\n\n\n# some more ls aliases\n#alias ll='ls -l'\n#alias la='ls -A'\n#alias l='ls -CF'\n\n\n\n\n\nUbuntu users may be familiar with these as they are provided by default on that distribution. Uncomment these lines to have access to these aliases in future.\n\n\n.bashrc\n also contains a reference to a \n.bash_aliases\n file, which does not exist by default. You can add it to provide a handy way of keeping all your aliases in a separate file.\n\n\nif [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi\n\n\n\n\n\nThe \nif\n statement here checks the file exists before including it.\n\n\nThen you just create the file \n.bash_aliases\n and add more aliases like so:\n\n\nalias gs='git status'\n\n\n\n\n\nYou can add other things directly to this file, or to another and include that file like the \n.bash_aliases\n example above.",
            "title": ".bashrc and .bash_aliases"
        },
        {
            "location": "/linux/usage/bashrc/index.html#bashrc-and-bash_aliases",
            "text": "In your home folder you will find a hidden file called  .bashrc  which contains some user configuration options. You can edit this file to suit your needs. Changes made in this file will be actioned the next time a terminal is opened, since that is when the  .bashrc  file is read.  If you want your changes to take place in your current terminal, you can use either  source ~/.bashrc  or  exec bash . These actually do slightly different things: the former simply re-executes the  .bashrc  file, which may result in undesirable changes to things like the path, the latter replaces the current shell with a new bash shell, which resets the shell back to the state at login, throwing away any shell variables you may have set. Choose whichever is most appropriate.  Some useful adaptions are provided for you; some of these are commented out with a  #  by default. To enable them, remove the  #  and they will be active next time you boot your Pi or start a new terminal.  For example, some  ls  aliases:  alias ls='ls --color=auto'\n#alias dir='dir --color=auto'\n#alias vdir='vdir --color=auto'\n\nalias grep='grep --color=auto'\nalias fgrep='fgrep --color=auto'\nalias egrep='egrep --color=auto'  Aliases like these are provided to help users of other systems like Microsoft Windows ( dir  is the  ls  of DOS/Windows). Others are to add colour to the output of commands like  ls  and  grep  by default.  More variations of  ls  are also provided:  # some more ls aliases\n#alias ll='ls -l'\n#alias la='ls -A'\n#alias l='ls -CF'  Ubuntu users may be familiar with these as they are provided by default on that distribution. Uncomment these lines to have access to these aliases in future.  .bashrc  also contains a reference to a  .bash_aliases  file, which does not exist by default. You can add it to provide a handy way of keeping all your aliases in a separate file.  if [ -f ~/.bash_aliases ]; then\n    . ~/.bash_aliases\nfi  The  if  statement here checks the file exists before including it.  Then you just create the file  .bash_aliases  and add more aliases like so:  alias gs='git status'  You can add other things directly to this file, or to another and include that file like the  .bash_aliases  example above.",
            "title": ".bashrc and .bash_aliases"
        },
        {
            "location": "/linux/usage/commands/index.html",
            "text": "Linux commands\n\n\nHere are some fundamental and common Linux commands with example usage:\n\n\nFilesystem\n\n\nls\n\n\nThe \nls\n command lists the content of the current directory (or one that is specified). It can be used with the \n-l\n flag to display additional information (permissions, owner, group, size, date and timestamp of last edit) about each file and directory in a list format. The \n-a\n flag allows you to view files beginning with \n.\n (i.e. dotfiles).\n\n\ncd\n\n\nUsing \ncd\n changes the current directory to the one specified. You can use relative (i.e. \ncd directoryA\n) or absolute (i.e. \ncd /home/pi/directoryA\n) paths.\n\n\npwd\n\n\nThe \npwd\n command displays the name of the present working directory: on a Raspberry Pi, entering \npwd\n will output something like \n/home/pi\n.\n\n\nmkdir\n\n\nYou can use \nmkdir\n to create a new directory, e.g. \nmkdir newDir\n would create the directory \nnewDir\n in the present working directory.\n\n\nrmdir\n\n\nTo remove empty directories, use \nrmdir\n. So, for example, \nrmdir oldDir\n will remove the directory \noldDir\n only if it is empty.\n\n\nrm\n\n\nThe command \nrm\nremoves the specified file (or recursively from a directory when used with \n-r\n). Be careful with this command: files deleted in this way are mostly gone for good!\n\n\ncp\n\n\nUsing \ncp\n makes a copy of a file and places it at the specified location (this is similar to copying and pasting). For example, \ncp ~/fileA /home/otherUser/\n would copy the file \nfileA\n from your home directory to that of the user \notherUser\n (assuming you have permission to copy it there). This command can either take \nFILE FILE\n (\ncp fileA fileB\n), \nFILE DIR\n (\ncp fileA /directoryB/\n) or \n-r DIR DIR\n (which recursively copies the contents of directories) as arguments.\n\n\nmv\n\n\nThe \nmv\n command moves a file and places it at the specified location (so where \ncp\n performs a 'copy-paste', \nmv\n performs a 'cut-paste'). The usage is similar to \ncp\n. So \nmv ~/fileA /home/otherUser/\n would move the file \nfileA\n from your home directory to that of the user otherUser. This command can either take \nFILE FILE\n (\nmv fileA fileB\n), \nFILE DIR\n (\nmv fileA /directoryB/\n) or \nDIR DIR\n (\nmv /directoryB /directoryC\n) as arguments. This command is also useful as a method to rename files and directories after they've been created.\n\n\ntouch\n\n\nThe command \ntouch\n sets the last modified time-stamp of the specified file(s) or creates it if it does not already exist.\n\n\ncat\n\n\nYou can use \ncat\n to list the contents of file(s), e.g. \ncat thisFile\n will display the contents of \nthisFile\n. Can be used to list the contents of multiple files, i.e. \ncat *.txt\n will list the contents of all \n.txt\n files in the current directory.\n\n\nhead\n\n\nThe \nhead\n command displays the beginning of a file. Can be used with \n-n\n to specify the number of lines to show (by default ten), or with \n-c\n to specify the number of bytes.\n\n\ntail\n\n\nThe opposite of \nhead\n, \ntail\n displays the end of a file. The starting point in the file can be specified either through \n-b\n for 512 byte blocks, \n-c\n for bytes, or \n-n\n for number of lines.\n\n\nchmod\n\n\nYou would normally use \nchmod\n to change the permissions for a file. The \nchmod\n command can use symbols \nu\n (user that owns the file), \ng\n (the files group) ,  and \no\n (other users) and the permissions \nr\n (read), \nw\n (write), and \nx\n (execute). Using \nchmod u+x *filename*\n will add execute permission for the owner of the file.\n\n\nchown\n\n\nThe \nchown\n command changes the user and/or group that owns a file. It normally needs to be run as root using sudo e.g. \nsudo chown pi:root *filename*\n will change the owner to pi and the group to root. \n\n\nssh\n\n\nssh\n denotes the secure shell. Connect to another computer using an encrypted network connection.\nFor more details see \nSSH (secure shell)\n\n\nscp\n\n\nThe \nscp\n command copies a file from one computer to another using \nssh\n.\nFor more details see \nSCP (secure copy)\n\n\nsudo\n\n\nThe \nsudo\n command enables you to run a command as a superuser, or another user. Use \nsudo -s\n for a superuser shell.\nFor more details see \nRoot user / sudo\n\n\ndd\n\n\nThe \ndd\n command copies a file converting the file as specified. It is often used to copy an entire disk to a single file or back again. So, for example, \ndd if=/dev/sdd of=backup.img\n will create a backup image from an SD card or USB disk drive at /dev/sdd. Make sure to use the correct drive when copying an image to the SD card as it can overwrite the entire disk.\n\n\ndf\n\n\nUse \ndf\n to display the disk space available and used on the mounted filesystems. Use \ndf -h\n to see the output in a human-readable format using M for MBs rather than showing number of bytes. \n\n\nunzip\n\n\nThe \nunzip\n command extracts the files from a compressed zip file. \n\n\ntar\n\n\nUse \ntar\n to store or extract files from a tape archive file. It can also reduce the space required by compressing the file similar to a zip file. \n\n\nTo create a compressed file, use \ntar -cvzf *filename.tar.gz* *directory/*\n\nTo extract the contents of a file, use \ntar -xvzf *filename.tar.gz*\n\n\npipes\n\n\nA pipe allows the output from one command to be used as the input for another command. The pipe symbol is a vertical line \n|\n. For example, to only show the first ten entries of the \nls\n command it can be piped through the head command \nls | head\n\n\ntree\n\n\nUse the \ntree\n command to show a directory and all subdirectories and files indented as a tree structure.\n\n\n&\n\n\nRun a command in the background with \n&\n, freeing up the shell for future commands. \n\n\nwget\n\n\nDownload a file from the web directly to the computer with \nwget\n. So \nwget https://www.raspberrypi.org/documentation/linux/usage/commands.md\n will download this file to your computer as \ncommands.md\n\n\ncurl\n\n\nUse \ncurl\n to download or upload a file to/from a server. By default, it will output the file contents of the file to the screen.\n\n\nman\n\n\nShow the manual page for a file with \nman\n. To find out more, run \nman man\n to view the manual page of the man command. \n\n\nSearch\n\n\ngrep\n\n\nUse \ngrep\n to search inside files for certain search patterns. For example, \ngrep \"search\" *.txt\n will look in all the files in the current directory ending with .txt for the string search.\n\n\nThe \ngrep\n command supports regular expressions which allows special letter combinations to be included in the search.\n\n\nawk\n\n\nawk\n is a programming language useful for searching and manipulating text files.\n\n\nfind\n\n\nThe \nfind\n command searches a directory and subdirectories for files matching certain patterns. \n\n\nwhereis\n\n\nUse \nwhereis\n to find the location of a command. It looks through standard program locations until it finds the requested command.\n\n\nNetworking\n\n\nping\n\n\nThe \nping\n utility is usually used to check if communication can be made with another host. It can be used with default settings by just specifying a hostname (e.g. \nping raspberrypi.org\n) or an IP address (e.g. \nping 8.8.8.8\n). It can specify the number of packets to send with the \n-c\n flag.\n\n\nnmap\n\n\nnmap\n is a network exploration and scanning tool. It can return port and OS information about a host or a range of hosts. Running just \nnmap\n will display the options available as well as example usage.\n\n\nhostname\n\n\nThe \nhostname\n command displays the current hostname of the system. A privileged (super) user can set the hostname to a new one by supplying it as an argument (e.g. \nhostname new-host\n).\n\n\nifconfig\n\n\nUse \nifconfig\n to display the network configuration details for the interfaces on the current system when run without any arguments (i.e. \nifconfig\n). By supplying the command with the name of an interface (e.g. \neth0\n or \nlo\n) you can then alter the configuration: check the manual page for more details.",
            "title": "Linux commands"
        },
        {
            "location": "/linux/usage/commands/index.html#linux-commands",
            "text": "Here are some fundamental and common Linux commands with example usage:",
            "title": "Linux commands"
        },
        {
            "location": "/linux/usage/commands/index.html#filesystem",
            "text": "",
            "title": "Filesystem"
        },
        {
            "location": "/linux/usage/commands/index.html#ls",
            "text": "The  ls  command lists the content of the current directory (or one that is specified). It can be used with the  -l  flag to display additional information (permissions, owner, group, size, date and timestamp of last edit) about each file and directory in a list format. The  -a  flag allows you to view files beginning with  .  (i.e. dotfiles).",
            "title": "ls"
        },
        {
            "location": "/linux/usage/commands/index.html#cd",
            "text": "Using  cd  changes the current directory to the one specified. You can use relative (i.e.  cd directoryA ) or absolute (i.e.  cd /home/pi/directoryA ) paths.",
            "title": "cd"
        },
        {
            "location": "/linux/usage/commands/index.html#pwd",
            "text": "The  pwd  command displays the name of the present working directory: on a Raspberry Pi, entering  pwd  will output something like  /home/pi .",
            "title": "pwd"
        },
        {
            "location": "/linux/usage/commands/index.html#mkdir",
            "text": "You can use  mkdir  to create a new directory, e.g.  mkdir newDir  would create the directory  newDir  in the present working directory.",
            "title": "mkdir"
        },
        {
            "location": "/linux/usage/commands/index.html#rmdir",
            "text": "To remove empty directories, use  rmdir . So, for example,  rmdir oldDir  will remove the directory  oldDir  only if it is empty.",
            "title": "rmdir"
        },
        {
            "location": "/linux/usage/commands/index.html#rm",
            "text": "The command  rm removes the specified file (or recursively from a directory when used with  -r ). Be careful with this command: files deleted in this way are mostly gone for good!",
            "title": "rm"
        },
        {
            "location": "/linux/usage/commands/index.html#cp",
            "text": "Using  cp  makes a copy of a file and places it at the specified location (this is similar to copying and pasting). For example,  cp ~/fileA /home/otherUser/  would copy the file  fileA  from your home directory to that of the user  otherUser  (assuming you have permission to copy it there). This command can either take  FILE FILE  ( cp fileA fileB ),  FILE DIR  ( cp fileA /directoryB/ ) or  -r DIR DIR  (which recursively copies the contents of directories) as arguments.",
            "title": "cp"
        },
        {
            "location": "/linux/usage/commands/index.html#mv",
            "text": "The  mv  command moves a file and places it at the specified location (so where  cp  performs a 'copy-paste',  mv  performs a 'cut-paste'). The usage is similar to  cp . So  mv ~/fileA /home/otherUser/  would move the file  fileA  from your home directory to that of the user otherUser. This command can either take  FILE FILE  ( mv fileA fileB ),  FILE DIR  ( mv fileA /directoryB/ ) or  DIR DIR  ( mv /directoryB /directoryC ) as arguments. This command is also useful as a method to rename files and directories after they've been created.",
            "title": "mv"
        },
        {
            "location": "/linux/usage/commands/index.html#touch",
            "text": "The command  touch  sets the last modified time-stamp of the specified file(s) or creates it if it does not already exist.",
            "title": "touch"
        },
        {
            "location": "/linux/usage/commands/index.html#cat",
            "text": "You can use  cat  to list the contents of file(s), e.g.  cat thisFile  will display the contents of  thisFile . Can be used to list the contents of multiple files, i.e.  cat *.txt  will list the contents of all  .txt  files in the current directory.",
            "title": "cat"
        },
        {
            "location": "/linux/usage/commands/index.html#head",
            "text": "The  head  command displays the beginning of a file. Can be used with  -n  to specify the number of lines to show (by default ten), or with  -c  to specify the number of bytes.",
            "title": "head"
        },
        {
            "location": "/linux/usage/commands/index.html#tail",
            "text": "The opposite of  head ,  tail  displays the end of a file. The starting point in the file can be specified either through  -b  for 512 byte blocks,  -c  for bytes, or  -n  for number of lines.",
            "title": "tail"
        },
        {
            "location": "/linux/usage/commands/index.html#chmod",
            "text": "You would normally use  chmod  to change the permissions for a file. The  chmod  command can use symbols  u  (user that owns the file),  g  (the files group) ,  and  o  (other users) and the permissions  r  (read),  w  (write), and  x  (execute). Using  chmod u+x *filename*  will add execute permission for the owner of the file.",
            "title": "chmod"
        },
        {
            "location": "/linux/usage/commands/index.html#chown",
            "text": "The  chown  command changes the user and/or group that owns a file. It normally needs to be run as root using sudo e.g.  sudo chown pi:root *filename*  will change the owner to pi and the group to root.",
            "title": "chown"
        },
        {
            "location": "/linux/usage/commands/index.html#ssh",
            "text": "ssh  denotes the secure shell. Connect to another computer using an encrypted network connection.\nFor more details see  SSH (secure shell)",
            "title": "ssh"
        },
        {
            "location": "/linux/usage/commands/index.html#scp",
            "text": "The  scp  command copies a file from one computer to another using  ssh .\nFor more details see  SCP (secure copy)",
            "title": "scp"
        },
        {
            "location": "/linux/usage/commands/index.html#sudo",
            "text": "The  sudo  command enables you to run a command as a superuser, or another user. Use  sudo -s  for a superuser shell.\nFor more details see  Root user / sudo",
            "title": "sudo"
        },
        {
            "location": "/linux/usage/commands/index.html#dd",
            "text": "The  dd  command copies a file converting the file as specified. It is often used to copy an entire disk to a single file or back again. So, for example,  dd if=/dev/sdd of=backup.img  will create a backup image from an SD card or USB disk drive at /dev/sdd. Make sure to use the correct drive when copying an image to the SD card as it can overwrite the entire disk.",
            "title": "dd"
        },
        {
            "location": "/linux/usage/commands/index.html#df",
            "text": "Use  df  to display the disk space available and used on the mounted filesystems. Use  df -h  to see the output in a human-readable format using M for MBs rather than showing number of bytes.",
            "title": "df"
        },
        {
            "location": "/linux/usage/commands/index.html#unzip",
            "text": "The  unzip  command extracts the files from a compressed zip file.",
            "title": "unzip"
        },
        {
            "location": "/linux/usage/commands/index.html#tar",
            "text": "Use  tar  to store or extract files from a tape archive file. It can also reduce the space required by compressing the file similar to a zip file.   To create a compressed file, use  tar -cvzf *filename.tar.gz* *directory/* \nTo extract the contents of a file, use  tar -xvzf *filename.tar.gz*",
            "title": "tar"
        },
        {
            "location": "/linux/usage/commands/index.html#pipes",
            "text": "A pipe allows the output from one command to be used as the input for another command. The pipe symbol is a vertical line  | . For example, to only show the first ten entries of the  ls  command it can be piped through the head command  ls | head",
            "title": "pipes"
        },
        {
            "location": "/linux/usage/commands/index.html#tree",
            "text": "Use the  tree  command to show a directory and all subdirectories and files indented as a tree structure.",
            "title": "tree"
        },
        {
            "location": "/linux/usage/commands/index.html#_1",
            "text": "Run a command in the background with  & , freeing up the shell for future commands.",
            "title": "&amp;"
        },
        {
            "location": "/linux/usage/commands/index.html#wget",
            "text": "Download a file from the web directly to the computer with  wget . So  wget https://www.raspberrypi.org/documentation/linux/usage/commands.md  will download this file to your computer as  commands.md",
            "title": "wget"
        },
        {
            "location": "/linux/usage/commands/index.html#curl",
            "text": "Use  curl  to download or upload a file to/from a server. By default, it will output the file contents of the file to the screen.",
            "title": "curl"
        },
        {
            "location": "/linux/usage/commands/index.html#man",
            "text": "Show the manual page for a file with  man . To find out more, run  man man  to view the manual page of the man command.",
            "title": "man"
        },
        {
            "location": "/linux/usage/commands/index.html#search",
            "text": "",
            "title": "Search"
        },
        {
            "location": "/linux/usage/commands/index.html#grep",
            "text": "Use  grep  to search inside files for certain search patterns. For example,  grep \"search\" *.txt  will look in all the files in the current directory ending with .txt for the string search.  The  grep  command supports regular expressions which allows special letter combinations to be included in the search.",
            "title": "grep"
        },
        {
            "location": "/linux/usage/commands/index.html#awk",
            "text": "awk  is a programming language useful for searching and manipulating text files.",
            "title": "awk"
        },
        {
            "location": "/linux/usage/commands/index.html#find",
            "text": "The  find  command searches a directory and subdirectories for files matching certain patterns.",
            "title": "find"
        },
        {
            "location": "/linux/usage/commands/index.html#whereis",
            "text": "Use  whereis  to find the location of a command. It looks through standard program locations until it finds the requested command.",
            "title": "whereis"
        },
        {
            "location": "/linux/usage/commands/index.html#networking",
            "text": "",
            "title": "Networking"
        },
        {
            "location": "/linux/usage/commands/index.html#ping",
            "text": "The  ping  utility is usually used to check if communication can be made with another host. It can be used with default settings by just specifying a hostname (e.g.  ping raspberrypi.org ) or an IP address (e.g.  ping 8.8.8.8 ). It can specify the number of packets to send with the  -c  flag.",
            "title": "ping"
        },
        {
            "location": "/linux/usage/commands/index.html#nmap",
            "text": "nmap  is a network exploration and scanning tool. It can return port and OS information about a host or a range of hosts. Running just  nmap  will display the options available as well as example usage.",
            "title": "nmap"
        },
        {
            "location": "/linux/usage/commands/index.html#hostname",
            "text": "The  hostname  command displays the current hostname of the system. A privileged (super) user can set the hostname to a new one by supplying it as an argument (e.g.  hostname new-host ).",
            "title": "hostname"
        },
        {
            "location": "/linux/usage/commands/index.html#ifconfig",
            "text": "Use  ifconfig  to display the network configuration details for the interfaces on the current system when run without any arguments (i.e.  ifconfig ). By supplying the command with the name of an interface (e.g.  eth0  or  lo ) you can then alter the configuration: check the manual page for more details.",
            "title": "ifconfig"
        },
        {
            "location": "/linux/usage/cron/index.html",
            "text": "Scheduling tasks with Cron\n\n\nCron is a tool for configuring scheduled tasks on Unix systems. It is used to schedule commands or scripts to run periodically and at fixed intervals. Tasks range from backing up the user's home folders every day at midnight, to logging CPU information every hour.\n\n\nThe command \ncrontab\n (cron table) is used to edit the list of scheduled tasks in operation, and is done on a per-user basis; each user (including \nroot\n) has their own \ncrontab\n.\n\n\nCron GUI\n\n\nA graphical application for Cron is available by installing the \ngnome-schedule\n package:\n\n\nsudo apt-get install gnome-schedule\n\n\n\n\n\nYou can then launch the program \nScheduled Tasks\n from the main menu.\n\n\nEditing crontab\n\n\nRun \ncrontab\n with the \n-e\n flag to edit the cron table:\n\n\ncrontab -e\n\n\n\n\n\nSelect an editor\n\n\nThe first time you run \ncrontab\n you'll be prompted to select an editor; if you are not sure which one to use, choose \nnano\n by pressing \nEnter\n.\n\n\nAdd a scheduled task\n\n\nThe layout for a cron entry is made up of six components: minute, hour, day of month, month of year, day of week, and the command to be executed.\n\n\n# m h  dom mon dow   command\n\n\n\n\n\n# * * * * *  command to execute\n\n\n# \u252c \u252c \u252c \u252c \u252c\n\n\n# \u2502 \u2502 \u2502 \u2502 \u2502\n\n\n# \u2502 \u2502 \u2502 \u2502 \u2502\n\n\n# \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500 day of week (0 - 7) (0 to 6 are Sunday to Saturday, or use names; 7 is Sunday, the same as 0)\n\n\n# \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)\n\n\n# \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)\n\n\n# \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)\n\n\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 min (0 - 59)\n\n\n\n\n\n\nFor example:\n\n\n0 0 * * *  /home/pi/backup.sh\n\n\n\n\n\nThis cron entry would run the \nbackup.sh\n script every day at midnight.\n\n\nView scheduled tasks\n\n\nView your currently saved scheduled tasks with:\n\n\ncrontab -l\n\n````\n\n\n\n### Run a task on reboot\n\n\nTo run a \ncommand\n every \ntime\n the Raspberry Pi starts up, write \n`\n@reboot\n`\n instead of the \ntime\n and date. For example:\n\n\n\n\n\n@reboot python /home/pi/myscript.py\n\n\nThis will run your Python script every time the Raspberry Pi reboots. If you want your command to be run in the background while the Raspberry Pi continues starting up, add a space and `&` at the end of the line, like this:\n\n\n\n\n\n@reboot python /home/pi/myscript.py &\n```",
            "title": "Scheduling tasks with Cron"
        },
        {
            "location": "/linux/usage/cron/index.html#scheduling-tasks-with-cron",
            "text": "Cron is a tool for configuring scheduled tasks on Unix systems. It is used to schedule commands or scripts to run periodically and at fixed intervals. Tasks range from backing up the user's home folders every day at midnight, to logging CPU information every hour.  The command  crontab  (cron table) is used to edit the list of scheduled tasks in operation, and is done on a per-user basis; each user (including  root ) has their own  crontab .",
            "title": "Scheduling tasks with Cron"
        },
        {
            "location": "/linux/usage/cron/index.html#cron-gui",
            "text": "A graphical application for Cron is available by installing the  gnome-schedule  package:  sudo apt-get install gnome-schedule  You can then launch the program  Scheduled Tasks  from the main menu.",
            "title": "Cron GUI"
        },
        {
            "location": "/linux/usage/cron/index.html#editing-crontab",
            "text": "Run  crontab  with the  -e  flag to edit the cron table:  crontab -e",
            "title": "Editing crontab"
        },
        {
            "location": "/linux/usage/cron/index.html#select-an-editor",
            "text": "The first time you run  crontab  you'll be prompted to select an editor; if you are not sure which one to use, choose  nano  by pressing  Enter .",
            "title": "Select an editor"
        },
        {
            "location": "/linux/usage/cron/index.html#add-a-scheduled-task",
            "text": "The layout for a cron entry is made up of six components: minute, hour, day of month, month of year, day of week, and the command to be executed.  # m h  dom mon dow   command  # * * * * *  command to execute  # \u252c \u252c \u252c \u252c \u252c  # \u2502 \u2502 \u2502 \u2502 \u2502  # \u2502 \u2502 \u2502 \u2502 \u2502  # \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500 day of week (0 - 7) (0 to 6 are Sunday to Saturday, or use names; 7 is Sunday, the same as 0)  # \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12)  # \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of month (1 - 31)  # \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23)  # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 min (0 - 59)   For example:  0 0 * * *  /home/pi/backup.sh  This cron entry would run the  backup.sh  script every day at midnight.",
            "title": "Add a scheduled task"
        },
        {
            "location": "/linux/usage/cron/index.html#view-scheduled-tasks",
            "text": "View your currently saved scheduled tasks with:  crontab -l ````  ### Run a task on reboot \n\nTo run a  command  every  time  the Raspberry Pi starts up, write  ` @reboot `  instead of the  time  and date. For example:  @reboot python /home/pi/myscript.py  This will run your Python script every time the Raspberry Pi reboots. If you want your command to be run in the background while the Raspberry Pi continues starting up, add a space and `&` at the end of the line, like this:  @reboot python /home/pi/myscript.py &\n```",
            "title": "View scheduled tasks"
        },
        {
            "location": "/linux/usage/rc-local/index.html",
            "text": "rc.local\n\n\nIn order to have a command or program run when the Pi boots, you can add commands to the \nrc.local\n file. This is especially useful if you want to be able to plug your Pi in to power headless, and have it run a program without configuration or a manual start.\n\n\nAn alternative for scheduled task management is \ncron\n.\n\n\nEditing rc.local\n\n\nOn your Pi, edit the file \n/etc/rc.local\n using the editor of your choice. You must edit with root, for example:\n\n\nsudo nano /etc/rc.local\n\n\n\n\n\nAdd commands below the comment, but leave the line \nexit 0\n at the end, then save the file and exit.\n\n\nWarning\n\n\nIf your command runs continuously (perhaps runs an infinite loop) or is likely not to exit, you must be sure to fork the process by adding an ampersand to the end of the command, like so:\n\n\npython /home/pi/myscript.py &\n\n\n\n\n\nOtherwise, the script will not end and the Pi will not boot. The ampersand allows the command to run in a separate process and continue booting with the process running.\n\n\nAlso, be sure to reference absolute filenames rather than relative to your home folder; for example, \n/home/pi/myscript.py\n rather than \nmyscript.py\n.",
            "title": "rc.local"
        },
        {
            "location": "/linux/usage/rc-local/index.html#rclocal",
            "text": "In order to have a command or program run when the Pi boots, you can add commands to the  rc.local  file. This is especially useful if you want to be able to plug your Pi in to power headless, and have it run a program without configuration or a manual start.  An alternative for scheduled task management is  cron .",
            "title": "rc.local"
        },
        {
            "location": "/linux/usage/rc-local/index.html#editing-rclocal",
            "text": "On your Pi, edit the file  /etc/rc.local  using the editor of your choice. You must edit with root, for example:  sudo nano /etc/rc.local  Add commands below the comment, but leave the line  exit 0  at the end, then save the file and exit.",
            "title": "Editing rc.local"
        },
        {
            "location": "/linux/usage/rc-local/index.html#warning",
            "text": "If your command runs continuously (perhaps runs an infinite loop) or is likely not to exit, you must be sure to fork the process by adding an ampersand to the end of the command, like so:  python /home/pi/myscript.py &  Otherwise, the script will not end and the Pi will not boot. The ampersand allows the command to run in a separate process and continue booting with the process running.  Also, be sure to reference absolute filenames rather than relative to your home folder; for example,  /home/pi/myscript.py  rather than  myscript.py .",
            "title": "Warning"
        },
        {
            "location": "/linux/usage/root/index.html",
            "text": "Root user/sudo\n\n\nThe Linux operating system is a multi-user operating system which allows multiple users to log in and use the computer. To protect the computer (and the privacy of other users), the users' abilities are restricted. \n\n\nMost users are allowed to run most programs, and to save and edit files stored in their own home folder. Normal users are not normally allowed to edit files in other users' folders or any of the system files. There's a special user in Linux known as the \nsuperuser\n, which is usually given the username \nroot\n. The superuser has unrestricted access to the computer and can do almost anything.\n\n\nsudo\n\n\nYou won't normally log into the computer as \nroot\n, but you can use the \nsudo\n command to provide access as the superuser. If you log into your Raspberry Pi as the \npi\n user, then you're logging in as a normal user. You can run commands as the \nroot\n user by using the \nsudo\n command before the program you want to run. \n\n\nFor example, if you want to install additional software on Raspbian then you normally use the \napt-get\n tool. To update the list of available software, you need to prefix the \napt-get\n command with sudo:\n\n\nsudo apt-get update\n\n\nFind out more about the \napt commands\n.\n\n\nYou can also run a superuser shell by using \nsudo su\n. When running commands as a superuser there's nothing to protect against mistakes that could damage the system. It's recommended that you only run commands as the superuser when required, and to exit a superuser shell when it's no longer needed.\n\n\nWho can use sudo?\n\n\nIt would defeat the point of the security if anyone could just put \nsudo\n in front of their commands, so only approved users can use \nsudo\n to gain administrator privileges. The \npi\n user is included in the \nsudoers\n file of approved users. To allow other users to act as a superuser you can add the user to the \nsudo\n group with \nusermod\n, edit the \n/etc/sudoers\n file, or add them using \nvisudo\n.\n\n\nFind out more about users\n.",
            "title": "Root user/sudo"
        },
        {
            "location": "/linux/usage/root/index.html#root-usersudo",
            "text": "The Linux operating system is a multi-user operating system which allows multiple users to log in and use the computer. To protect the computer (and the privacy of other users), the users' abilities are restricted.   Most users are allowed to run most programs, and to save and edit files stored in their own home folder. Normal users are not normally allowed to edit files in other users' folders or any of the system files. There's a special user in Linux known as the  superuser , which is usually given the username  root . The superuser has unrestricted access to the computer and can do almost anything.",
            "title": "Root user/sudo"
        },
        {
            "location": "/linux/usage/root/index.html#sudo",
            "text": "You won't normally log into the computer as  root , but you can use the  sudo  command to provide access as the superuser. If you log into your Raspberry Pi as the  pi  user, then you're logging in as a normal user. You can run commands as the  root  user by using the  sudo  command before the program you want to run.   For example, if you want to install additional software on Raspbian then you normally use the  apt-get  tool. To update the list of available software, you need to prefix the  apt-get  command with sudo:  sudo apt-get update  Find out more about the  apt commands .  You can also run a superuser shell by using  sudo su . When running commands as a superuser there's nothing to protect against mistakes that could damage the system. It's recommended that you only run commands as the superuser when required, and to exit a superuser shell when it's no longer needed.",
            "title": "sudo"
        },
        {
            "location": "/linux/usage/root/index.html#who-can-use-sudo",
            "text": "It would defeat the point of the security if anyone could just put  sudo  in front of their commands, so only approved users can use  sudo  to gain administrator privileges. The  pi  user is included in the  sudoers  file of approved users. To allow other users to act as a superuser you can add the user to the  sudo  group with  usermod , edit the  /etc/sudoers  file, or add them using  visudo .  Find out more about users .",
            "title": "Who can use sudo?"
        },
        {
            "location": "/linux/usage/scripting/index.html",
            "text": "Shell scripts\n\n\nCommands can be combined together in a file which can then be executed. As an example, copy the following into your favourite text editor:\n\n\nwhile\n :\n\ndo\n\n\necho\n Raspberry Pi!\n\ndone\n\n\n\n\n\n\nSave this with the name \nfun-script\n. Before you can run it you must first make it executable; this can be done by using the change mode command \nchmod\n. Each file and directory has its own set of permissions that dictate what a user can and can't do to it. In this case, by running the command \nchmod +x fun-script\n, the file \nfun-script\n will now be executable. You can then run it by typing \n./fun-script\n (assuming that it's in your current directory). This script infinitely loops and prints \nRaspberry Pi!\n; to stop it, press \nCtrl + C\n. This kills any command that's currently being run in the terminal.",
            "title": "Shell scripts"
        },
        {
            "location": "/linux/usage/scripting/index.html#shell-scripts",
            "text": "Commands can be combined together in a file which can then be executed. As an example, copy the following into your favourite text editor:  while  : do  echo  Raspberry Pi! done   Save this with the name  fun-script . Before you can run it you must first make it executable; this can be done by using the change mode command  chmod . Each file and directory has its own set of permissions that dictate what a user can and can't do to it. In this case, by running the command  chmod +x fun-script , the file  fun-script  will now be executable. You can then run it by typing  ./fun-script  (assuming that it's in your current directory). This script infinitely loops and prints  Raspberry Pi! ; to stop it, press  Ctrl + C . This kills any command that's currently being run in the terminal.",
            "title": "Shell scripts"
        },
        {
            "location": "/linux/usage/systemd/index.html",
            "text": "systemd\n\n\nIn order to have a command or program run when the Pi boots, you can add it as a service. Once this is done, you can start/stop enable/disable from the linux prompt.\n\n\nCreating a service\n\n\nOn your Pi, create a .service file for your service, for example:\n\n\nmyscript.service\n\n\n[Unit]\n\n\nDescription\n=\nMy service\n\n\nAfter\n=\nnetwork.target\n\n\n\n[Service]\n\n\nExecStart\n=\n/usr/bin/python3 -u main.py\n\n\nWorkingDirectory\n=\n/home/pi/myscript\n\n\nStandardOutput\n=\ninherit\n\n\nStandardError\n=\ninherit\n\n\nRestart\n=\nalways\n\n\nUser\n=\npi\n\n\n\n[Install]\n\n\nWantedBy\n=\nmulti-user.target\n\n\n\n\n\n\nSo in this instance, the service would run Python 3 from our working directory \n/home/pi/myscript\n which contains our python program to run \nmyscript.py\n. But you are not limited to Python programs: simply change the ExecStart line to be the command to start any program/script that you want running from booting.\n\n\nCopy this file into \n/lib/systemd/system\n as root, for example:\n\n\nsudo cp myscript.service /lib/systemd/system/myscript.service\n\n\n\n\n\nOnce this has been copied, you can attempt to start the service using the following command:\n\n\nsudo systemctl start myscript.service\n\n\n\n\n\nStop it using following command:\n\n\nsudo systemctl stop myscript.service\n\n\n\n\n\nWhen you are happy that this starts and stops your app, you can have it start automatically on reboot by using this command:\n\n\nsudo systemctl enable myscript.service\n\n\n\n\n\nThe \nsystemctl\n command can also be used to restart the service or disable it from boot up!\n\n\nSome things to be aware of:\n+ The order in which things are started is based on their dependencies \u2014 this particular script should start fairly late in the boot process, after a network is available (see the After section).\n+ You can configure different dependencies and orders based on your requirements.\n\n\nYou can get more information from:\n\nman systemctl\n\nor here: https://fedoramagazine.org/what-is-an-init-system/\n\n\nAlso be sure to reference absolute file names rather than doing so relative to your home folder, for example use \n/home/pi/myscript.py\n rather than \nmyscript.py\n.",
            "title": "systemd"
        },
        {
            "location": "/linux/usage/systemd/index.html#systemd",
            "text": "In order to have a command or program run when the Pi boots, you can add it as a service. Once this is done, you can start/stop enable/disable from the linux prompt.",
            "title": "systemd"
        },
        {
            "location": "/linux/usage/systemd/index.html#creating-a-service",
            "text": "On your Pi, create a .service file for your service, for example:  myscript.service  [Unit]  Description = My service  After = network.target  [Service]  ExecStart = /usr/bin/python3 -u main.py  WorkingDirectory = /home/pi/myscript  StandardOutput = inherit  StandardError = inherit  Restart = always  User = pi  [Install]  WantedBy = multi-user.target   So in this instance, the service would run Python 3 from our working directory  /home/pi/myscript  which contains our python program to run  myscript.py . But you are not limited to Python programs: simply change the ExecStart line to be the command to start any program/script that you want running from booting.  Copy this file into  /lib/systemd/system  as root, for example:  sudo cp myscript.service /lib/systemd/system/myscript.service  Once this has been copied, you can attempt to start the service using the following command:  sudo systemctl start myscript.service  Stop it using following command:  sudo systemctl stop myscript.service  When you are happy that this starts and stops your app, you can have it start automatically on reboot by using this command:  sudo systemctl enable myscript.service  The  systemctl  command can also be used to restart the service or disable it from boot up!  Some things to be aware of:\n+ The order in which things are started is based on their dependencies \u2014 this particular script should start fairly late in the boot process, after a network is available (see the After section).\n+ You can configure different dependencies and orders based on your requirements.  You can get more information from: man systemctl \nor here: https://fedoramagazine.org/what-is-an-init-system/  Also be sure to reference absolute file names rather than doing so relative to your home folder, for example use  /home/pi/myscript.py  rather than  myscript.py .",
            "title": "Creating a service"
        },
        {
            "location": "/linux/usage/text-editors/index.html",
            "text": "Text editors\n\n\nOn Linux, you have a choice of text editors. Some are easy-to-use but have limited functionality; others require training to use and take a long time to master, but offer incredible functionality.\n\n\nDesktop graphical editors\n\n\nLeafpad\n\n\nOn Raspbian, you'll find an editor called Leafpad. This is a simple editor which opens in a window like a normal application. It allows use of the mouse and keyboard, and has tabs and syntax highlighting.\n\n\nYou can use keyboard shortcuts, such as \nCtrl + S\n to save a file and \nCtrl + X\n to exit.\n\n\nIDLE\n\n\nIDLE is a Python REPL and IDE, so you can write and edit Python code in a window and run it from there.\n\n\nIDLE has independent windows and syntax highlighting. It's somewhat buggy, but it's generally fine for basic use.\n\n\nYou can use keyboard shortcuts like \nCtrl + S\n to save a file, or \nAlt + P\n (previous command) and \nAlt + N\n (next command) in the REPL.\n\n\nNote that IDLE uses Python 2 and IDLE 3 uses Python 3.\n\n\nGVim\n\n\nSee Vim below.\n\n\nCommand-line editors\n\n\nNano\n\n\nGNU Nano is at the easy-to-use end of command-line editors. It's installed by default, so use \nnano somefile.txt\n to edit a file, and keyboard shortcuts like \nCtrl + O\n to save and \nCtrl + X\n to exit.\n\n\nVi\n\n\nVi is a very old (c. 1976) command-line editor, which is available on most UNIX systems and is pre-installed on Raspbian. It's succeeded by Vim (Vi Improved), which requires installation.\n\n\nUnlike most editors, Vi and Vim have a number of different modes. When you open Vi with \nvi somefile.txt\n, you start in command mode which doesn't directly permit text entry. Press \ni\n to switch to insert mode in order to edit the file, and type away. To save the file you must return to command mode, so press the \nEscape\n key and enter \n:w\n (followed by \nEnter\n), which is the command to write the file to disk.\n\n\nTo search for the word 'raspberry' in a file, make sure you're in command mode (press \nEscape\n), then type \n/raspberry\n followed by \nn\n and \nN\n to flick forwards/backwards through the results.\n\n\nTo save and exit, enter the command \n:wq\n. To exit without saving, enter the command \n:q!\n.\n\n\nDepending on your keyboard configuration, you may find your cursor keys don't work. In this case, you can use the H-J-K-L keys (which move left, down, up, and right respectively) to navigate the file in command mode.\n\n\nVim\n\n\nVim is an extension of Vi and works in much the same way, with a number of improvements. Only Vi is installed by default so to get the full features of Vim, install it with APT:\n\n\nsudo apt-get install vim\n\n\n\n\n\nYou can edit a file in Vim with \nvim somefile.txt\n. Vim also has a graphical version which opens in a window and allows interaction with the mouse. This version is installable separately:\n\n\nsudo apt-get install vim-gnome\n\n\n\n\n\nTo use the graphical version of Vim, use \ngvim somefile.txt\n. You can save configuration in a \n.vimrc\n file in your user's home directory. To learn more about editing in Vi and Vim, you can run \nvimtutor\n and follow the tutorial.\n\n\nEmacs\n\n\nEmacs is a GNU command-line text editor; it's powerful, extensible, and customisable. You can install it with APT:\n\n\nsudo apt-get install emacs\n\n\n\n\n\nYou can use keyboard combination commands, such as \nCtrl + X Ctrl + S\n to save and \nCtrl + X Ctrl + C\n to close.",
            "title": "Text editors"
        },
        {
            "location": "/linux/usage/text-editors/index.html#text-editors",
            "text": "On Linux, you have a choice of text editors. Some are easy-to-use but have limited functionality; others require training to use and take a long time to master, but offer incredible functionality.",
            "title": "Text editors"
        },
        {
            "location": "/linux/usage/text-editors/index.html#desktop-graphical-editors",
            "text": "",
            "title": "Desktop graphical editors"
        },
        {
            "location": "/linux/usage/text-editors/index.html#leafpad",
            "text": "On Raspbian, you'll find an editor called Leafpad. This is a simple editor which opens in a window like a normal application. It allows use of the mouse and keyboard, and has tabs and syntax highlighting.  You can use keyboard shortcuts, such as  Ctrl + S  to save a file and  Ctrl + X  to exit.",
            "title": "Leafpad"
        },
        {
            "location": "/linux/usage/text-editors/index.html#idle",
            "text": "IDLE is a Python REPL and IDE, so you can write and edit Python code in a window and run it from there.  IDLE has independent windows and syntax highlighting. It's somewhat buggy, but it's generally fine for basic use.  You can use keyboard shortcuts like  Ctrl + S  to save a file, or  Alt + P  (previous command) and  Alt + N  (next command) in the REPL.  Note that IDLE uses Python 2 and IDLE 3 uses Python 3.",
            "title": "IDLE"
        },
        {
            "location": "/linux/usage/text-editors/index.html#gvim",
            "text": "See Vim below.",
            "title": "GVim"
        },
        {
            "location": "/linux/usage/text-editors/index.html#command-line-editors",
            "text": "",
            "title": "Command-line editors"
        },
        {
            "location": "/linux/usage/text-editors/index.html#nano",
            "text": "GNU Nano is at the easy-to-use end of command-line editors. It's installed by default, so use  nano somefile.txt  to edit a file, and keyboard shortcuts like  Ctrl + O  to save and  Ctrl + X  to exit.",
            "title": "Nano"
        },
        {
            "location": "/linux/usage/text-editors/index.html#vi",
            "text": "Vi is a very old (c. 1976) command-line editor, which is available on most UNIX systems and is pre-installed on Raspbian. It's succeeded by Vim (Vi Improved), which requires installation.  Unlike most editors, Vi and Vim have a number of different modes. When you open Vi with  vi somefile.txt , you start in command mode which doesn't directly permit text entry. Press  i  to switch to insert mode in order to edit the file, and type away. To save the file you must return to command mode, so press the  Escape  key and enter  :w  (followed by  Enter ), which is the command to write the file to disk.  To search for the word 'raspberry' in a file, make sure you're in command mode (press  Escape ), then type  /raspberry  followed by  n  and  N  to flick forwards/backwards through the results.  To save and exit, enter the command  :wq . To exit without saving, enter the command  :q! .  Depending on your keyboard configuration, you may find your cursor keys don't work. In this case, you can use the H-J-K-L keys (which move left, down, up, and right respectively) to navigate the file in command mode.",
            "title": "Vi"
        },
        {
            "location": "/linux/usage/text-editors/index.html#vim",
            "text": "Vim is an extension of Vi and works in much the same way, with a number of improvements. Only Vi is installed by default so to get the full features of Vim, install it with APT:  sudo apt-get install vim  You can edit a file in Vim with  vim somefile.txt . Vim also has a graphical version which opens in a window and allows interaction with the mouse. This version is installable separately:  sudo apt-get install vim-gnome  To use the graphical version of Vim, use  gvim somefile.txt . You can save configuration in a  .vimrc  file in your user's home directory. To learn more about editing in Vi and Vim, you can run  vimtutor  and follow the tutorial.",
            "title": "Vim"
        },
        {
            "location": "/linux/usage/text-editors/index.html#emacs",
            "text": "Emacs is a GNU command-line text editor; it's powerful, extensible, and customisable. You can install it with APT:  sudo apt-get install emacs  You can use keyboard combination commands, such as  Ctrl + X Ctrl + S  to save and  Ctrl + X Ctrl + C  to close.",
            "title": "Emacs"
        },
        {
            "location": "/linux/usage/users/index.html",
            "text": "Linux users\n\n\nUser management in Raspbian is done on the command line. The default user is \npi\n, and the password is \nraspberry\n. You can add users and change each user's password.\n\n\nChange your password\n\n\nWhen logged in as the \npi\n user, you can change your password with the \npasswd\n command.\n\n\nEnter \npasswd\n on the command line and press \nEnter\n. You'll be prompted to enter your current password to authenticate, and then asked for a new password. Press \nEnter\n on completion and you'll be asked to confirm it. Note that no characters will be displayed while entering your password. Once you've correctly confirmed your password, you'll be shown a success message (\npasswd: password updated successfully\n), and the new password will apply immediately.\n\n\nIf your user has \nsudo\n permissions, you can change another user's password with \npasswd\n preceded by the user's username. For example, \nsudo passwd bob\n will allow you to set the user \nbob\n's password, and then some additional optional values for the user such as their name. Just press \nEnter\n to skip each of these options.\n\n\nRemove a user's password\n\n\nYou can remove the password for the user \nbob\n with \nsudo passwd bob -d\n.\n\n\nCreate a new user\n\n\nYou can create additional users on your Raspbian installation with the \nadduser\n command.\n\n\nEnter \nsudo adduser bob\n and you'll be prompted for a password for the new user \nbob\n. Leave this blank if you don't want a password.\n\n\nHome folder\n\n\nWhen you create a new user, they will have a home folder in \n/home/\n. The \npi\n user's home folder is at \n/home/pi/\n.\n\n\nskel\n\n\nUpon creating a new user, the contents of \n/etc/skel/\n will be copied to the new user's home folder. You can add or modify dot-files such as the \n.bashrc\n in \n/etc/skel/\n to your requirements, and this version will be applied to new users.\n\n\nSudoers\n\n\nThe default \npi\n user on Raspbian is a sudoer. This gives the ability to run commands as root when preceded by \nsudo\n, and to switch to the root user with \nsudo su\n.\n\n\nTo add a new user to sudoers, type \nsudo visudo\n (from a sudoer user) and find the line \nroot    ALL=(ALL:ALL) ALL\n, under the commented header \n# User privilege specification\n. Copy this line and switch from \nroot\n to the username. To allow passwordless root access, change to \nNOPASSWD: ALL\n. The example below gives the user \nbob\n passwordless sudo access:\n\n\n# User privilege specification\n\nroot  \nALL\n=(\nALL:ALL\n)\n ALL\nbob   \nALL\n \n=\n NOPASSWD: ALL\n\n\n\n\n\nSave and exit to apply the changes. Be careful, as it's possible to remove your own sudo rights by accident.\n\n\nYou can change the editor the \nvisudo\n command uses (the default is Nano) by entering:\n\n\nupdate-alternatives --set editor /usr/bin/vim.tiny\n\n\n\n\n\nThis sets the editor to Vim.\n\n\nDelete a user\n\n\nYou can delete a user on your system with the command \nuserdel\n. Apply the \n-r\n flag to remove their home folder too:\n\n\nsudo userdel -r bob",
            "title": "Linux users"
        },
        {
            "location": "/linux/usage/users/index.html#linux-users",
            "text": "User management in Raspbian is done on the command line. The default user is  pi , and the password is  raspberry . You can add users and change each user's password.",
            "title": "Linux users"
        },
        {
            "location": "/linux/usage/users/index.html#change-your-password",
            "text": "When logged in as the  pi  user, you can change your password with the  passwd  command.  Enter  passwd  on the command line and press  Enter . You'll be prompted to enter your current password to authenticate, and then asked for a new password. Press  Enter  on completion and you'll be asked to confirm it. Note that no characters will be displayed while entering your password. Once you've correctly confirmed your password, you'll be shown a success message ( passwd: password updated successfully ), and the new password will apply immediately.  If your user has  sudo  permissions, you can change another user's password with  passwd  preceded by the user's username. For example,  sudo passwd bob  will allow you to set the user  bob 's password, and then some additional optional values for the user such as their name. Just press  Enter  to skip each of these options.",
            "title": "Change your password"
        },
        {
            "location": "/linux/usage/users/index.html#remove-a-users-password",
            "text": "You can remove the password for the user  bob  with  sudo passwd bob -d .",
            "title": "Remove a user's password"
        },
        {
            "location": "/linux/usage/users/index.html#create-a-new-user",
            "text": "You can create additional users on your Raspbian installation with the  adduser  command.  Enter  sudo adduser bob  and you'll be prompted for a password for the new user  bob . Leave this blank if you don't want a password.",
            "title": "Create a new user"
        },
        {
            "location": "/linux/usage/users/index.html#home-folder",
            "text": "When you create a new user, they will have a home folder in  /home/ . The  pi  user's home folder is at  /home/pi/ .",
            "title": "Home folder"
        },
        {
            "location": "/linux/usage/users/index.html#skel",
            "text": "Upon creating a new user, the contents of  /etc/skel/  will be copied to the new user's home folder. You can add or modify dot-files such as the  .bashrc  in  /etc/skel/  to your requirements, and this version will be applied to new users.",
            "title": "skel"
        },
        {
            "location": "/linux/usage/users/index.html#sudoers",
            "text": "The default  pi  user on Raspbian is a sudoer. This gives the ability to run commands as root when preceded by  sudo , and to switch to the root user with  sudo su .  To add a new user to sudoers, type  sudo visudo  (from a sudoer user) and find the line  root    ALL=(ALL:ALL) ALL , under the commented header  # User privilege specification . Copy this line and switch from  root  to the username. To allow passwordless root access, change to  NOPASSWD: ALL . The example below gives the user  bob  passwordless sudo access:  # User privilege specification \nroot   ALL =( ALL:ALL )  ALL\nbob    ALL   =  NOPASSWD: ALL  Save and exit to apply the changes. Be careful, as it's possible to remove your own sudo rights by accident.  You can change the editor the  visudo  command uses (the default is Nano) by entering:  update-alternatives --set editor /usr/bin/vim.tiny  This sets the editor to Vim.",
            "title": "Sudoers"
        },
        {
            "location": "/linux/usage/users/index.html#delete-a-user",
            "text": "You can delete a user on your system with the command  userdel . Apply the  -r  flag to remove their home folder too:  sudo userdel -r bob",
            "title": "Delete a user"
        },
        {
            "location": "/raspbian/README/index.html",
            "text": "Raspbian\n\n\nRaspbian is the recommended operating system for normal use on a Raspberry Pi.\n\n\nRaspbian is a free operating system based on Debian, optimised for the Raspberry Pi hardware. Raspbian comes with over 35,000 packages: precompiled software bundled in a nice format for easy installation on your Raspberry Pi.\n\n\nRaspbian is a community project under active development, with an emphasis on improving the stability and performance of as many Debian packages as possible.\n\n\nContents\n\n\n\n\nInstalling Raspbian\n\n\nInstalling software in Raspbian\n\n\nUpdating/Upgrading Raspbian\n\n\nConfiguring Raspbian\n\n\nraspi-config\n\n\nconfig.txt\n\n\nscreensaver\n\n\n\n\n\n\nApplications\n\n\nCamera\n\n\nOMXPlayer",
            "title": "Raspbian"
        },
        {
            "location": "/raspbian/README/index.html#raspbian",
            "text": "Raspbian is the recommended operating system for normal use on a Raspberry Pi.  Raspbian is a free operating system based on Debian, optimised for the Raspberry Pi hardware. Raspbian comes with over 35,000 packages: precompiled software bundled in a nice format for easy installation on your Raspberry Pi.  Raspbian is a community project under active development, with an emphasis on improving the stability and performance of as many Debian packages as possible.",
            "title": "Raspbian"
        },
        {
            "location": "/raspbian/README/index.html#contents",
            "text": "Installing Raspbian  Installing software in Raspbian  Updating/Upgrading Raspbian  Configuring Raspbian  raspi-config  config.txt  screensaver    Applications  Camera  OMXPlayer",
            "title": "Contents"
        },
        {
            "location": "/raspbian/updating/index.html",
            "text": "Updating and Upgrading Raspbian\n\n\nTo update software in Raspbian, you'll need to use the \napt\n tool in a terminal window. Open the terminal from the taskbar or application menu:\n\n\n\n\nFirst, \nupdate\n your system's package list by entering the following command:\n\n\nsudo apt-get update\n\n\n\n\n\nNext, \nupgrade\n all your installed packages to their latest versions with the command:\n\n\nsudo apt-get dist-upgrade\n\n\n\n\n\nGenerally speaking, doing this regularly will keep your installation up to date, in that it will be equivalent to the latest released image available from \nraspberrypi.org/downloads\n.\n\n\nHowever, there are occasional changes made in the Foundation's Raspbian image that require manual intervention, for example a newly introduced package. These are not installed with an upgrade, as this command only updates the packages you already have installed.\n\n\nUpdating the kernel and firmware\n\n\nThe kernel and firmware are installed as a Debian package, and so will also get updates when using the procedure above. These packages are updated infrequently and after extensive testing.\n\n\nRunning out of space\n\n\nWhen running \nsudo apt-get dist-upgrade\n, it will show how much data will be downloaded and how much space it will take up on the SD card. It's worth checking with \ndf -h\n that you have enough free disk space, as unfortunately \napt\n will not do this for you. Also be aware that downloaded package files (\n.deb\n files) are kept in \n/var/cache/apt/archives\n. You can remove these in order to free up space with \nsudo apt-get clean\n.",
            "title": "Updating and Upgrading Raspbian"
        },
        {
            "location": "/raspbian/updating/index.html#updating-and-upgrading-raspbian",
            "text": "To update software in Raspbian, you'll need to use the  apt  tool in a terminal window. Open the terminal from the taskbar or application menu:   First,  update  your system's package list by entering the following command:  sudo apt-get update  Next,  upgrade  all your installed packages to their latest versions with the command:  sudo apt-get dist-upgrade  Generally speaking, doing this regularly will keep your installation up to date, in that it will be equivalent to the latest released image available from  raspberrypi.org/downloads .  However, there are occasional changes made in the Foundation's Raspbian image that require manual intervention, for example a newly introduced package. These are not installed with an upgrade, as this command only updates the packages you already have installed.",
            "title": "Updating and Upgrading Raspbian"
        },
        {
            "location": "/raspbian/updating/index.html#updating-the-kernel-and-firmware",
            "text": "The kernel and firmware are installed as a Debian package, and so will also get updates when using the procedure above. These packages are updated infrequently and after extensive testing.",
            "title": "Updating the kernel and firmware"
        },
        {
            "location": "/raspbian/updating/index.html#running-out-of-space",
            "text": "When running  sudo apt-get dist-upgrade , it will show how much data will be downloaded and how much space it will take up on the SD card. It's worth checking with  df -h  that you have enough free disk space, as unfortunately  apt  will not do this for you. Also be aware that downloaded package files ( .deb  files) are kept in  /var/cache/apt/archives . You can remove these in order to free up space with  sudo apt-get clean .",
            "title": "Running out of space"
        },
        {
            "location": "/raspbian/applications/README/index.html",
            "text": "Raspbian Applications\n\n\n\n\nCamera\n\n\nInformation on the demonstration camera software\n\n\n\n\n\n\nOMXPlayer\n\n\nInformation on the OMXPlayer command line media player",
            "title": "Raspbian Applications"
        },
        {
            "location": "/raspbian/applications/README/index.html#raspbian-applications",
            "text": "Camera  Information on the demonstration camera software    OMXPlayer  Information on the OMXPlayer command line media player",
            "title": "Raspbian Applications"
        },
        {
            "location": "/raspbian/applications/camera/index.html",
            "text": "Raspberry Pi Camera Module\n\n\nThis document describes the use of the three Raspberry Pi camera applications, as of January 8th 2015.\n\n\nThere are three applications provided: \nraspistill\n, \nraspivid\n, and \nraspistillyuv\n. \nraspistill\n and \nraspistillyuv\n are very similar and are intended for capturing images; \nraspivid\n is for capturing video.\n\n\nAll the applications are driven from the command line, and written to take advantage of the MMAL API which runs over OpenMAX. The MMAL API provides an easier to use system than that presented by OpenMAX. Note that MMAL is a Broadcom-specific API used only on Videocore 4 systems.\n\n\nThe applications use up to four OpenMAX (MMAL) components: camera, preview, encoder, and null_sink. All applications use the camera component; \nraspistill\n uses the Image Encode component; \nraspivid\n uses the Video Encode component; and \nraspistillyuv\n doesn't use an encoder, and sends its YUV or RGB output directly from the camera component to file.\n\n\nThe preview display is optional, but can be used full-screen or directed to a specific rectangular area on the display. If preview is disabled, the null_sink component is used to 'absorb' the preview frames. The camera must produce preview frames even if these aren't required for display, as they're used for calculating exposure and white balance settings.\n\n\nIn addition, it's possible to omit the filename option (in which case the preview is displayed but no file is written), or to redirect all output to stdout.\n\n\nCommand line help is available by typing just the application name in the command line.\n\n\nSetting up\n\n\nSee \nCamera Setup\n.\n\n\nTroubleshooting\n\n\nIf the Camera Module isn't working correctly, there are number of things to try:\n\n\n\n\n\n\nIs the ribbon cable attached to the Camera Serial Interface (CSI), not the Display Serial Interface (DSI)? The ribbon connector will fit into either port. The Camera port is located near the HDMI connector.\n\n\n\n\n\n\nAre the ribbon connectors all firmly seated, and are they the right way round? They must be straight in their sockets.\n\n\n\n\n\n\nIs the Camera Module connector, between the smaller black Camera Module itself and the PCB, firmly attached? Sometimes this connection can come loose during transit or when putting the Camera Module in a case. Using a fingernail, flip up the connector on the PCB, then reconnect it with gentle pressure. It engages with a very slight click. Don't force it; if it doesn't engage, it's probably slightly misaligned.\n\n\n\n\n\n\nHave \nsudo apt-get update\n and \nsudo apt-get upgrade\n been run?\n\n\n\n\n\n\nHas \nraspi-config\n been run and the Camera Module enabled?\n\n\n\n\n\n\nIs your power supply sufficient? The Camera Module adds about 200-250mA to the power requirements of your Raspberry Pi.\n\n\n\n\n\n\nIf things are still not working, try the following:\n\n\n\n\n\n\nError : raspistill/raspivid command not found\n. This probably means your update/upgrade failed in some way. Try it again.\n\n\n\n\n\n\nError : ENOMEM\n. The Camera Module is not starting up. Check all connections again.\n\n\n\n\n\n\nError : ENOSPC\n. The Camera Module is probably running out of GPU memory. Check \nconfig.txt\n in the /boot/ folder. The \ngpu_mem\n option should be at least 128. Alternatively, use the Memory Split option in the Advanced section of \nraspi-config\n to set this.\n\n\n\n\n\n\nIf you've checked all the above issues and the Camera Module is still not working, you may need to upgrade the firmware on the Raspberry Pi. Use the following command to get the very latest (but experimental) firmware:\n\n\nbash\nsudo rpi-update\n\n\n\n\n\n\nIf even a firmware update doesn't fix the problem, your Camera Module may be defective, and may need to be replaced.\n\n\n\n\n\n\nCommon command line options\n\n\nPreview window\n\n\n    --preview,  -p      Preview window settings <'x,y,w,h'>\n\n\n\n\n\nAllows the user to define the size of the preview window and its location on the screen. Note this will be superimposed over the top of any other windows/graphics.\n\n\n    --fullscreen,   -f      Fullscreen preview mode\n\n\n\n\n\nForces the preview window to use the whole screen. Note that the aspect ratio of the incoming image will be retained, so there may be bars on some edges.\n\n\n    --nopreview,    -n      Do not display a preview window\n\n\n\n\n\nDisables the preview window completely. Note that even though the preview is disabled, the camera will still be producing frames, so will be using power.\n\n\n    --opacity,  -op     Set preview window opacity\n\n\n\n\n\nSets the opacity of the preview windows. 0 = invisible, 255 = fully opaque.\n\n\nCamera control options\n\n\n    --sharpness,    -sh     Set image sharpness (-100 - 100)\n\n\n\n\n\nSets the sharpness of the image. 0 is the default.\n\n\n    --contrast, -co     Set image contrast (-100 - 100)\n\n\n\n\n\nSets the contrast of the image. 0 is the default.\n\n\n    --brightness,   -br     Set image brightness (0 - 100)\n\n\n\n\n\nSets the brightness of the image. 50 is the default. 0 is black, 100 is white.\n\n\n    --saturation,   -sa     Set image saturation (-100 - 100)\n\n\n\n\n\nSets the colour saturation of the image. 0 is the default.\n\n\n    --ISO,  -ISO        Set capture ISO (100 - 800)\n\n\n\n\n\nSets the ISO to be used for captures.\n\n\n    --vstab,    -vs     Turn on video stabilisation\n\n\n\n\n\nIn video mode only, turns on video stabilisation.\n\n\n    --ev,   -ev     Set EV compensation (-10 - 10)\n\n\n\n\n\nSets the EV compensation of the image. Default is 0.\n\n\n    --exposure, -ex     Set exposure mode\n\n\n\n\n\nPossible options are:\n\n\n\n\nauto: use automatic exposure mode\n\n\nnight: select setting for night shooting\n\n\nnightpreview: \n\n\nbacklight: select setting for backlit subject\n\n\nspotlight:  \n\n\nsports: select setting for sports (fast shutter etc.)\n\n\nsnow: select setting optimised for snowy scenery\n\n\nbeach: select setting optimised for beach\n\n\nverylong: select setting for long exposures\n\n\nfixedfps: constrain fps to a fixed value\n\n\nantishake: antishake mode\n\n\nfireworks: select setting optimised for fireworks\n\n\n\n\nNote that not all of these settings may be implemented, depending on camera tuning.\n\n\n    --awb,  -awb        Set Automatic White Balance (AWB) mode\n\n\n\n\n\nModes for which colour temperature ranges (K) are available have these settings in brackets.\n\n\n\n\noff: turn off white balance calculation\n\n\nauto: automatic mode (default)\n\n\nsun: sunny mode (between 5000K and 6500K) \n\n\ncloud: cloudy mode (between 6500K and 12000K)\n\n\nshade: shade mode \n\n\ntungsten: tungsten lighting mode (between 2500K and 3500K)\n\n\nfluorescent: fluorescent lighting mode (between 2500K and 4500K)\n\n\nincandescent: incandescent lighting mode\n\n\nflash: flash mode\n\n\nhorizon: horizon mode\n\n\n\n\nNote that not all of these settings may be implemented, depending on camera type.\n\n\n    --imxfx,    -ifx        Set image effect\n\n\n\n\n\nSet an effect to be applied to the image:\n\n\n\n\nnone: no effect (default)\n\n\nnegative: invert the image colours\n\n\nsolarise: solarise the image\n\n\nposterise: posterise the image\n\n\nwhiteboard: whiteboard effect\n\n\nblackboard: blackboard effect\n\n\nsketch: sketch effect\n\n\ndenoise: denoise the image\n\n\nemboss: emboss the image\n\n\noilpaint: oil paint effect\n\n\nhatch: hatch sketch effect\n\n\ngpen: graphite sketch effect\n\n\npastel: pastel effect\n\n\nwatercolour: watercolour effect\n\n\nfilm: film grain effect\n\n\nblur: blur the image\n\n\nsaturation: colour saturate the image\n\n\ncolourswap: not fully implemented\n\n\nwashedout: not fully implemented\n\n\ncolourpoint: not fully implemented\n\n\ncolourbalance: not fully implemented\n\n\ncartoon: not fully implemented\n\n\n\n\nNote that not all of these settings may be available in all circumstances.\n\n\n    --colfx,    -cfx        Set colour effect <U:V>\n\n\n\n\n\nThe supplied U and V parameters (range 0 - 255) are applied to the U and Y channels of the image. For example, --colfx 128:128 should result in a monochrome image.\n\n\n    --metering, -mm     Set metering mode\n\n\n\n\n\nSpecify the metering mode used for the preview and capture:\n\n\n\n\naverage: average the whole frame for metering\n\n\nspot: spot metering\n\n\nbacklit: assume a backlit image\n\n\nmatrix: matrix metering\n\n\n\n\n    --rotation, -rot        Set image rotation (0 - 359)\n\n\n\n\n\nSets the rotation of the image in the viewfinder and resulting image. This can take any value from 0 upwards, but due to hardware constraints only 0, 90, 180, and 270 degree rotations are supported.\n\n\n    --hflip,    -hf     Set horizontal flip\n\n\n\n\n\nFlips the preview and saved image horizontally.\n\n\n    --vflip,    -vf     Set vertical flip\n\n\n\n\n\nFlips the preview and saved image vertically.\n\n\n    --roi,  -roi        Set sensor region of interest\n\n\n\n\n\nAllows the specification of the area of the sensor to be used as the source for the preview and capture. This is defined as x,y for the top-left corner, and a width and height, with all values in normalised coordinates (0.0 - 1.0). So, to set a ROI at halfway across and down the sensor, and a width and height of a quarter of the sensor, use:\n\n\n-roi 0.5,0.5,0.25,0.25\n\n\n\n\n\n--shutter,  -ss     Set shutter speed\n\n\n\n\n\nSets the shutter speed to the specified value (in microseconds). There's currently an upper limit of approximately 6000000us (6000ms, 6s), past which operation is undefined.\n\n\n--drc,  -drc        Enable/disable dynamic range compression\n\n\n\n\n\nDRC changes the images by increasing the range of dark areas, and decreasing the brighter areas. This can improve the image in low light areas.\n\n\n\n\noff\n\n\nlow\n\n\nmed\n\n\nhigh\n\n\n\n\nBy default, DRC is off.\n\n\n--stats,    -st     Display image statistics\n\n\n\n\n\nDisplays the exposure, analogue and digital gains, and AWB settings used.\n\n\n--awbgains, -awbg\n\n\n\n\n\nSets blue and red gains (as floating point numbers) to be applied when \n-awb -off\n is set e.g. -awbg 1.5,1.2\n\n\n--mode, -md\n\n\n\n\n\nSets a specified sensor mode, disabling the automatic selection. Possible values depend on the version of the Camera Module being used: \n\n\nVersion 1.x (OV5647)\n\n\n\n\n\n\n\n\nMode\n\n\nSize\n\n\nAspect Ratio\n\n\nFrame rates\n\n\nFOV\n\n\nBinning\n\n\n\n\n\n\n\n\n\n\n0\n\n\nautomatic selection\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1920x1080\n\n\n16:9\n\n\n1-30fps\n\n\nPartial\n\n\nNone\n\n\n\n\n\n\n2\n\n\n2592x1944\n\n\n4:3\n\n\n1-15fps\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n3\n\n\n2592x1944\n\n\n4:3\n\n\n0.1666-1fps\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n4\n\n\n1296x972\n\n\n4:3\n\n\n1-42fps\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n5\n\n\n1296x730\n\n\n16:9\n\n\n1-49fps\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n6\n\n\n640x480\n\n\n4:3\n\n\n42.1-60fps\n\n\nFull\n\n\n2x2 plus skip\n\n\n\n\n\n\n7\n\n\n640x480\n\n\n4:3\n\n\n60.1-90fps\n\n\nFull\n\n\n2x2 plus skip\n\n\n\n\n\n\n\n\nVersion 2.x (IMX219)\n\n\n\n\n\n\n\n\nMode\n\n\nSize\n\n\nAspect Ratio\n\n\nFrame rates\n\n\nFOV\n\n\nBinning\n\n\n\n\n\n\n\n\n\n\n0\n\n\nautomatic selection\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n\n\n1920x1080\n\n\n16:9\n\n\n0.1-30fps\n\n\nPartial\n\n\nNone\n\n\n\n\n\n\n2\n\n\n3280x2464\n\n\n4:3\n\n\n0.1-15fps\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n3\n\n\n3280x2464\n\n\n4:3\n\n\n0.1-15fps\n\n\nFull\n\n\nNone\n\n\n\n\n\n\n4\n\n\n1640x1232\n\n\n4:3\n\n\n0.1-40fps\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n5\n\n\n1640x922\n\n\n16:9\n\n\n0.1-40fps\n\n\nFull\n\n\n2x2\n\n\n\n\n\n\n6\n\n\n1280x720\n\n\n16:9\n\n\n40-90fps\n\n\nPartial\n\n\n2x2\n\n\n\n\n\n\n7\n\n\n640x480\n\n\n4:3\n\n\n40-90fps\n\n\nPartial\n\n\n2x2\n\n\n\n\n\n\n\n\n    --camselect,    -cs\n\n\n\n\n\nSelects which camera to use on a multi-camera system. Use 0 or 1.\n\n\n    --annotate, -a      Enable/set annotate flags or text\n\n\n\n\n\nAdds some text and/or metadata to the picture.\n\n\nMetadata is indicated using a bitmask notation, so add them together to show multiple parameters. For example, 12 will show time(4) and date(8), since 4+8=12.\n\n\nText may include date/time placeholders by using the '%' character, as used by \nstrftime\n.\n\n\n\n\n\n\n\n\nValue\n\n\nMeaning\n\n\nExample Output\n\n\n\n\n\n\n\n\n\n\n-a 4\n\n\nTime\n\n\n20:09:33\n\n\n\n\n\n\n-a 8\n\n\nDate\n\n\n10/28/15\n\n\n\n\n\n\n-a 12\n\n\n4+8=12 Show the date(4) and time(8)\n\n\n20:09:33 10/28/15\n\n\n\n\n\n\n-a 16\n\n\nShutter Settings\n\n\n\n\n\n\n\n\n-a 32\n\n\nCAF Settings\n\n\n\n\n\n\n\n\n-a 64\n\n\nGain Settings\n\n\n\n\n\n\n\n\n-a 128\n\n\nLens Settings\n\n\n\n\n\n\n\n\n-a 256\n\n\nMotion Settings\n\n\n\n\n\n\n\n\n-a 512\n\n\nFrame Number\n\n\n\n\n\n\n\n\n-a 1024\n\n\nBlack Background\n\n\n\n\n\n\n\n\n-a \"ABC %Y-%m-%d %X\"\n\n\nShow some text\n\n\nABC %Y-%m-%d %X\n\n\n\n\n\n\n-a 4 -a \"ABC %Y-%m-%d %X\"\n\n\nShow custom \nformatted\n date/time\n\n\nABC 2015-10-28 20:09:33\n\n\n\n\n\n\n-a 8 -a \"ABC %Y-%m-%d %X\"\n\n\nShow custom \nformatted\n date/time\n\n\nABC 2015-10-28 20:09:33\n\n\n\n\n\n\n\n\n--annotateex,   -ae     Set extra annotation parameters\n\n\n\n\n\nSpecifies annotation size, text colour, and background colour. Colours are in hex YUV format.\n\n\nSize ranges from 6 - 160; default is 32. Asking for an invalid size should give you the default.\n\n\n\n\n\n\n\n\nExample\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\n-ae 32,0xff,0x808000 -a \"Annotation text\"\n\n\ngives size 32 white text on black background\n\n\n\n\n\n\n-ae 10,0x00,0x8080FF -a \"Annotation text\"\n\n\ngives size 10 black text on white background\n\n\n\n\n\n\n\n\nApplication-specific settings\n\n\nraspistill\n\n\n--width,    -w      Set image width <size>\n\n--height,   -h      Set image height <size>\n\n--quality,  -q      Set JPEG quality <0 to 100>\n\n\n\n\n\nQuality 100 is almost completely uncompressed. 75 is a good all-round value.\n\n\n--raw,  -r      Add raw Bayer data to JPEG metadata\n\n\n\n\n\nThis option inserts the raw Bayer data from the camera into the JPEG metadata.\n\n\n--output,   -o      Output filename <filename>\n\n\n\n\n\nSpecifies the output filename. If not specified, no file is saved. If the filename is '-', then all output is sent to stdout.\n\n\n--latest,   -l      Link latest frame to filename <filename>\n\n\n\n\n\nMakes a file system link under this name to the latest frame.\n\n\n--verbose,  -v      Output verbose information during run\n\n\n\n\n\nOutputs debugging/information messages during the program run.\n\n\n--timeout,  -t      Time before the camera takes picture and shuts down\n\n\n\n\n\nThe program will run for this length of time, then take the capture (if output is specified). If not specified, this is set to 5 seconds.\n\n\n--timelapse,    -tl     time-lapse mode\n\n\n\n\n\nThe specific value is the time between shots in milliseconds. Note that you should specify \n%04d\n at the point in the filename where you want a frame count number to appear. So, for example, the code below will produce a capture every 2 seconds, over a total period of 30s, named \nimage0001.jpg\n, \nimage0002.jpg\n and so on, through to \nimage0015.jpg\n. \n\n\n-t 30000 -tl 2000 -o image%04d.jpg\n\n\n\n\n\nNote that the \n%04d\n indicates a 4-digit number, with leading zeroes added to make the required number of digits. So, for example,  \n%08d\n would result in an 8-digit number.\n\n\nIf a time-lapse value of 0 is entered, the application will take pictures as fast as possible. Note that there's an minimum enforced pause of 30ms between captures to ensure that exposure calculations can be made.\n\n\n--thumb,    -th     Set thumbnail parameters (x:y:quality)\n\n\n\n\n\nAllows specification of the thumbnail image inserted into the JPEG file. If not specified, defaults are a size of 64x48 at quality 35.\n\n\nif \n--thumb none\n is specified, no thumbnail information will be placed in the file. This reduces the file size slightly.\n\n\n--demo, -d      Run a demo mode <milliseconds>\n\n\n\n\n\nThis options cycles through the range of camera options. No capture is taken, and the demo will end at the end of the timeout period, irrespective of whether all the options have been cycled. The time between cycles should be specified as a millisecond value.\n\n\n--encoding, -e      Encoding to use for output file\n\n\n\n\n\nValid options are \njpg\n, \nbmp\n, \ngif\n, and \npng\n. Note that unaccelerated image types (GIF, PNG, BMP) will take much longer to save than jpg, which is hardware accelerated. Also note that the filename suffix is completely ignored when deciding the encoding of a file.\n\n\n--exif, -x      EXIF tag to apply to captures (format as 'key=value')\n\n\n\n\n\nAllows the insertion of specific EXIF tags into the JPEG image. You can have up to 32 EXIF tag entries. This is useful for tasks like adding GPS metadata. For example, to set the longitude:\n\n\n--exif GPS.GPSLongitude=5/1,10/1,15/1\n\n\n\n\n\nwould set the longitude to 5 degs, 10 minutes, 15 seconds. See EXIF documentation for more details on the range of tags available; the supported tags are as follows:\n\n\nIFD0.<   or\nIFD1.<\nImageWidth, ImageLength, BitsPerSample, Compression, PhotometricInterpretation, ImageDescription, Make, Model, StripOffsets, Orientation, SamplesPerPixel, RowsPerString, StripByteCounts, XResolution, YResolution, PlanarConfiguration, ResolutionUnit, TransferFunction, Software, DateTime, Artist, WhitePoint, PrimaryChromaticities, JPEGInterchangeFormat, JPEGInterchangeFormatLength, YCbCrCoefficients, YCbCrSubSampling, YCbCrPositioning, ReferenceBlackWhite, Copyright>\n\nEXIF.<\nExposureTime, FNumber, ExposureProgram, SpectralSensitivity, ISOSpeedRatings, OECF, ExifVersion, DateTimeOriginal, DateTimeDigitized, ComponentsConfiguration, CompressedBitsPerPixel, ShutterSpeedValue, ApertureValue, BrightnessValue, ExposureBiasValue, MaxApertureValue, SubjectDistance, MeteringMode, LightSource, Flash, FocalLength, SubjectArea, MakerNote, UserComment, SubSecTime, SubSecTimeOriginal, SubSecTimeDigitized, FlashpixVersion, ColorSpace, PixelXDimension, PixelYDimension, RelatedSoundFile, FlashEnergy, SpatialFrequencyResponse, FocalPlaneXResolution, FocalPlaneYResolution, FocalPlaneResolutionUnit, SubjectLocation, ExposureIndex, SensingMethod, FileSource, SceneType, CFAPattern, CustomRendered, ExposureMode, WhiteBalance, DigitalZoomRatio, FocalLengthIn35mmFilm, SceneCaptureType, GainControl, Contrast, Saturation, Sharpness, DeviceSettingDescription, SubjectDistanceRange, ImageUniqueID>\n\nGPS.<\nGPSVersionID, GPSLatitudeRef, GPSLatitude, GPSLongitudeRef, GPSLongitude, GPSAltitudeRef, GPSAltitude, GPSTimeStamp, GPSSatellites, GPSStatus, GPSMeasureMode, GPSDOP, GPSSpeedRef, GPSSpeed, GPSTrackRef, GPSTrack, GPSImgDirectionRef, GPSImgDirection, GPSMapDatum, GPSDestLatitudeRef, GPSDestLatitude, GPSDestLongitudeRef, GPSDestLongitude, GPSDestBearingRef, GPSDestBearing, GPSDestDistanceRef, GPSDestDistance, GPSProcessingMethod, GPSAreaInformation, GPSDateStamp, GPSDifferential>\n\nEINT.<\nInteroperabilityIndex, InteroperabilityVersion, RelatedImageFileFormat, RelatedImageWidth, RelatedImageLength>\n\n\n\n\n\nNote that a small subset of these tags will be set automatically by the camera system, but will be overridden by any EXIF options on the command line.\n\n\nSetting \n--exif none\n will prevent any EXIF information being stored in the file. This reduces the file size slightly.\n\n\n--fullpreview,  -fp     Full preview mode\n\n\n\n\n\nThis runs the preview window using the full resolution capture mode. Maximum frames per second in this mode is 15fps, and the preview will have the same field of view as the capture. Captures should happen more quickly, as no mode change should be required. This feature is currently under development.\n\n\n--keypress, -k      Keypress mode\n\n\n\n\n\nThe camera is run for the requested time (\n-t\n), and a capture can be initiated throughout that time by pressing the Enter key. Pressing X then Enter will exit the application before the timeout is reached. If the timeout is set to 0, the camera will run indefinitely until the user presses X then Enter. Using the verbose option (\n-v\n) will display a prompt asking for user input, otherwise no prompt is displayed.\n\n\n--signal,   -s      Signal mode\n\n\n\n\n\nThe camera is run for the requested time (\n-t\n), and a capture can be initiated throughout that time by sending a \nUSR1\n signal to the camera process. This can be done using the \nkill\n command. You can find the camera process ID using the \npgrep raspistill\n command.\n\n\nkill -USR1 <process id of raspistill>\n\n\n\n\n\nraspistillyuv\n\n\nMany of the options for \nraspistillyuv\n are the same as those for \nraspistill\n. This section shows the differences.\n\n\nUnsupported options:\n\n\n--exif, --encoding, --thumb, --raw, --quality\n\n\n\n\n\nExtra options :\n\n\n--rgb,  -rgb        Save uncompressed data as RGB888\n\n\n\n\n\nThis option forces the image to be saved as RGB data with 8 bits per channel, rather than YUV420.\n\n\nNote that the image buffers saved in \nraspistillyuv\n are padded to a horizontal size divisible by 32, so there may be unused bytes at the end of each line. Buffers are also padded vertically to be divisible by 16, and in the YUV mode, each plane of Y,U,V is padded in this way.\n\n\nraspivid\n\n\n--width,    -w      Set image width <size>\n\n\n\n\n\nWidth of resulting video. This should be between 64 and 1920.\n\n\n--height,   -h      Set image height <size>\n\n\n\n\n\nHeight of resulting video. This should be between 64 and 1080.\n\n\n--bitrate,  -b      Set bitrate\n\n\n\n\n\nUse bits per second, so 10Mbits/s would be \n-b 10000000\n. For H264, 1080p30 a high quality bitrate would be 15Mbits/s or more. Maximum bitrate is 25Mbits/s (\n-b 25000000\n), but much over 17Mbits/s won't show noticeable improvement at 1080p30.\n\n\n--output,   -o      Output filename <filename>\n\n\n\n\n\nSpecify the output filename. If not specified, no file is saved. If the filename is '-', then all output is sent to stdout.\n\n\n--verbose,  -v      Output verbose information during run\n\n\n\n\n\nOutputs debugging/information messages during the program run.\n\n\n--timeout,  -t      Time before the camera takes picture and shuts down\n\n\n\n\n\nThe program will run for this length of time, then take the capture (if output is specified). If not specified, this is set to 5 seconds. Setting 0 will mean the application will run continuously until stopped with Ctrl-C.\n\n\n--demo, -d      Run a demo mode <milliseconds>\n\n\n\n\n\nThis options cycles through the range of camera options. No capture is done, and the demo will end at the end of the timeout period, irrespective of whether all the options have been cycled. The time between cycles should be specified as a millisecond value.\n\n\n--framerate,    -fps        Specify the frames per second to record\n\n\n\n\n\nAt present, the minimum frame rate allowed is 2fps, and the maximum is 30fps. This is likely to change in the future.\n\n\n--penc, -e      Display preview image after encoding\n\n\n\n\n\nSwitch on an option to display the preview after compression. This will show any compression artefacts in the preview window. In normal operation, the preview will show the camera output prior to being compressed. This option is not guaranteed to work in future releases.\n\n\n--intra,    -g      Specify the intra refresh period (key frame rate/GoP)\n\n\n\n\n\nSets the intra refresh period (GoP) rate for the recorded video. H264 video uses a complete frame (I-frame) every intra refresh period, from which subsequent frames are based. This option specifies the number of frames between each I-frame. Larger numbers here will reduce the size of the resulting video, and smaller numbers make the stream less error-prone.\n\n\n--qp,   -qp     Set quantisation parameter\n\n\n\n\n\nSets the initial quantisation parameter for the stream. Varies from approximately 10 to 40, and will greatly affect the quality of the recording. Higher values reduce quality and decrease file size. Combine this setting with a bitrate of 0 to set a completely variable bitrate.\n\n\n--profile,  -pf     Specify H264 profile to use for encoding\n\n\n\n\n\nSets the H264 profile to be used for the encoding. Options are:\n\n\n\n\nbaseline\n\n\nmain\n\n\nhigh\n\n\n\n\n--inline,   -ih     Insert PPS, SPS headers\n\n\n\n\n\nForces the stream to include PPS and SPS headers on every I-frame. Needed for certain streaming cases e.g. Apple HLS. These headers are small, so don't greatly increase the file size.\n\n\n--timed,    -td     Do timed switches between capture and pause\n\n\n\n\n\nThis options allows the video capture to be paused and restarted at particular time intervals. Two values are required: the on time and the off time. On time is the amount of time the video is captured, and off time is the amount it is paused. The total time of the recording is defined by the \ntimeout\n option. Note that the recording may take slightly over the timeout setting depending on the on and off times.\n\n\nFor example:\n\n\nraspivid -o test.h264 -t 25000 -timed 2500,5000\n\n\n\n\n\nwill record for a period of 25 seconds. The recording will be over a timeframe consisting of 2500ms (2.5s) segments with 5000ms (5s) gaps, repeating over the 20s. So the entire recording will actually be only 10s long, since 4 segments of 2.5s = 10s separated by 5s gaps. So:\n\n\n2.5 record \u2013 5 pause - 2.5 record \u2013 5 pause - 2.5 record \u2013 5 pause \u2013 2.5 record\n\n\ngives a total recording period of 25s, but only 10s of actual recorded footage.\n\n\n--keypress, -k      Toggle between record and pause on Enter keypress\n\n\n\n\n\nOn each press of the Enter key, the recording will be paused or restarted. Pressing X then Enter will stop recording and close the application. Note that the timeout value will be used to signal the end of recording, but is only checked after each Enter keypress; so if the system is waiting for a keypress, even if the timeout has expired, it will still wait for the keypress before exiting.\n\n\n--signal,   -s      Toggle between record and pause according to SIGUSR1\n\n\n\n\n\nSending a \nUSR1\n signal to the \nraspivid\n process will toggle between recording and paused. This can be done using the \nkill\n command, as below. You can find the \nraspivid\n process ID using \npgrep raspivid\n.\n\n\nkill -USR1 <process id of raspivid>\n\n\n\n\n\nNote that the timeout value will be used to indicate the end of recording, but is only checked after each receipt of the \nSIGUSR1\n signal; so if the system is waiting for a signal, even if the timeout has expired, it will still wait for the signal before exiting.\n\n\n--initial,  -i      Define initial state on startup\n\n\n\n\n\nDefine whether the camera will start paused or will immediately start recording. Options are \nrecord\n or \npause\n. Note that if you are using a simple timeout, and \ninitial\n is set to \npause\n, no output will be recorded.\n\n\n--segment,  -sg     Segment the stream into multiple files\n\n\n\n\n\nRather than creating a single file, the file is split into segments of approximately the number of milliseconds specified. In order to provide different filenames, you should add  \n%04d\n or similar at the point in the filename where you want a segment count number to appear e.g:\n\n\n--segment 3000 -o video%04d.h264\n\n\n\n\n\nwill produce video clips of approximately 3000ms (3s) long, named \nvideo0001.h264\n, \nvideo0002.h264\n etc. The clips should be seamless (no frame drops between clips), but the accuracy of each clip length will depend on the intraframe period, as the segments will always start on an I-frame. They will therefore always be equal or longer to the specified period.\n\n\n--wrap, -wr     Set the maximum value for segment number\n\n\n\n\n\nWhen outputting segments, this is the maximum the segment number can reach before it's reset to 1,  giving the ability to keep recording segments, but overwriting the oldest one. So if set to 4, in the segment example above, the files produced will be \nvideo0001.h264\n, \nvideo0002.h264\n, \nvideo0003.h264\n, and \nvideo0004.h264\n. Once \nvideo0004.h264\n is recorded, the count will reset to 1, and \nvideo0001.h264\n will be overwritten.\n\n\n--start,    -sn     Set the initial segment number\n\n\n\n\n\nWhen outputting segments, this is the initial segment number, giving the ability to resume a previous recording from a given segment. The default value is 1.\n\n\nExamples\n\n\nStill captures\n\n\nBy default, captures are done at the highest resolution supported by the sensor. This can be changed using the \n-w\n and \n-h\n command line options.\n\n\nTake a default capture after 2s (times are specified in milliseconds) on the viewfinder, saving in \nimage.jpg\n:\n\n\nraspistill -t \n2000\n -o image.jpg\n\n\n\n\n\nTake a capture at a different resolution:\n\n\nraspistill -t \n2000\n -o image.jpg -w \n640\n -h \n480\n\n\n\n\n\n\nReduce the quality considerably to reduce file size:\n\n\nraspistill -t \n2000\n -o image.jpg -q \n5\n\n\n\n\n\n\nForce the preview to appear at coordinate 100,100, with width 300 pixels and height 200 pixels:\n\n\nraspistill -t \n2000\n -o image.jpg -p \n100\n,100,300,200\n\n\n\n\n\nDisable preview entirely:\n\n\nraspistill -t \n2000\n -o image.jpg -n\n\n\n\n\n\nSave the image as a PNG file (lossless compression, but slower than JPEG). Note that the filename suffix is ignored when choosing the image encoding:\n\n\nraspistill -t \n2000\n -o image.png \u2013e png\n\n\n\n\n\nAdd some EXIF information to the JPEG. This sets the Artist tag name to Boris, and the GPS altitude to 123.5m. Note that if setting GPS tags you should set as a minimum GPSLatitude, GPSLatitudeRef, GPSLongitude, GPSLongitudeRef, GPSAltitude, and GPSAltitudeRef:\n\n\nraspistill -t \n2000\n -o image.jpg -x IFD0.Artist\n=\nBoris -x GPS.GPSAltitude\n=\n1235\n/10\n\n\n\n\n\nSet an emboss image effect:\n\n\nraspistill -t \n2000\n -o image.jpg -ifx emboss\n\n\n\n\n\nSet the U and V channels of the YUV image to specific values (128:128 produces a greyscale image):\n\n\nraspistill -t \n2000\n -o image.jpg -cfx \n128\n:128\n\n\n\n\n\nRun preview for 2s, with no saved image:\n\n\nraspistill -t \n2000\n\n\n\n\n\n\nTake a time-lapse picture, every 10 seconds for 10 minutes (10 minutes = 600000ms), naming the files \nimage_num_001_today.jpg\n, \nimage_num_002_today.jpg\n and so on, with the latest picture also available under the name \nlatest.jpg\n:\n\n\nraspistill -t \n600000\n -tl \n10000\n -o image_num_%03d_today.jpg -l latest.jpg\n\n\n\n\n\nTake a picture and send the image data to stdout:\n\n\nraspistill -t \n2000\n -o -\n\n\n\n\n\nTake a picture and send the image data to a file:\n\n\nraspistill -t \n2000\n -o - > my_file.jpg\n\n\n\n\n\nRun the camera forever, taking a picture when Enter is pressed:\n\n\nraspistill -t \n0\n -k -o my_pics%02d.jpg\n\n\n\n\n\nVideo captures\n\n\nImage size and preview settings are the same as for stills capture. Default size for video recording is 1080p (1920x1080).\n\n\nRecord a 5s clip with default settings (1080p30):\n\n\nraspivid -t \n5000\n -o video.h264\n\n\n\n\n\nRecord a 5s clip at a specified bitrate (3.5Mbits/s):\n\n\nraspivid -t \n5000\n -o video.h264 -b \n3500000\n\n\n\n\n\n\nRecord a 5s clip at a specified framerate (5fps):\n\n\nraspivid -t \n5000\n -o video.h264 -f \n5\n\n\n\n\n\n\nEncode a 5s camera stream and send the image data to stdout:\n\n\nraspivid -t \n5000\n -o -\n\n\n\n\n\nEncode a 5s camera stream and send the image data to a file:\n\n\nraspivid -t \n5000\n -o - > my_file.h264\n\n\n\n\n\nShell error codes\n\n\nThe applications described here will return a standard error code to the shell on completion. Possible error codes are:\n\n\n\n\n\n\n\n\nC Define\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nEX_OK\n\n\n0\n\n\nApplication ran successfully\n\n\n\n\n\n\nEX_USAGE\n\n\n64\n\n\nBad command line parameter\n\n\n\n\n\n\nEX_SOFTWARE\n\n\n70\n\n\nSoftware or camera error\n\n\n\n\n\n\n\n\n130\n\n\nApplication terminated by Ctrl-C",
            "title": "Raspberry Pi Camera Module"
        },
        {
            "location": "/raspbian/applications/camera/index.html#raspberry-pi-camera-module",
            "text": "This document describes the use of the three Raspberry Pi camera applications, as of January 8th 2015.  There are three applications provided:  raspistill ,  raspivid , and  raspistillyuv .  raspistill  and  raspistillyuv  are very similar and are intended for capturing images;  raspivid  is for capturing video.  All the applications are driven from the command line, and written to take advantage of the MMAL API which runs over OpenMAX. The MMAL API provides an easier to use system than that presented by OpenMAX. Note that MMAL is a Broadcom-specific API used only on Videocore 4 systems.  The applications use up to four OpenMAX (MMAL) components: camera, preview, encoder, and null_sink. All applications use the camera component;  raspistill  uses the Image Encode component;  raspivid  uses the Video Encode component; and  raspistillyuv  doesn't use an encoder, and sends its YUV or RGB output directly from the camera component to file.  The preview display is optional, but can be used full-screen or directed to a specific rectangular area on the display. If preview is disabled, the null_sink component is used to 'absorb' the preview frames. The camera must produce preview frames even if these aren't required for display, as they're used for calculating exposure and white balance settings.  In addition, it's possible to omit the filename option (in which case the preview is displayed but no file is written), or to redirect all output to stdout.  Command line help is available by typing just the application name in the command line.",
            "title": "Raspberry Pi Camera Module"
        },
        {
            "location": "/raspbian/applications/camera/index.html#setting-up",
            "text": "See  Camera Setup .",
            "title": "Setting up"
        },
        {
            "location": "/raspbian/applications/camera/index.html#troubleshooting",
            "text": "If the Camera Module isn't working correctly, there are number of things to try:    Is the ribbon cable attached to the Camera Serial Interface (CSI), not the Display Serial Interface (DSI)? The ribbon connector will fit into either port. The Camera port is located near the HDMI connector.    Are the ribbon connectors all firmly seated, and are they the right way round? They must be straight in their sockets.    Is the Camera Module connector, between the smaller black Camera Module itself and the PCB, firmly attached? Sometimes this connection can come loose during transit or when putting the Camera Module in a case. Using a fingernail, flip up the connector on the PCB, then reconnect it with gentle pressure. It engages with a very slight click. Don't force it; if it doesn't engage, it's probably slightly misaligned.    Have  sudo apt-get update  and  sudo apt-get upgrade  been run?    Has  raspi-config  been run and the Camera Module enabled?    Is your power supply sufficient? The Camera Module adds about 200-250mA to the power requirements of your Raspberry Pi.    If things are still not working, try the following:    Error : raspistill/raspivid command not found . This probably means your update/upgrade failed in some way. Try it again.    Error : ENOMEM . The Camera Module is not starting up. Check all connections again.    Error : ENOSPC . The Camera Module is probably running out of GPU memory. Check  config.txt  in the /boot/ folder. The  gpu_mem  option should be at least 128. Alternatively, use the Memory Split option in the Advanced section of  raspi-config  to set this.    If you've checked all the above issues and the Camera Module is still not working, you may need to upgrade the firmware on the Raspberry Pi. Use the following command to get the very latest (but experimental) firmware:  bash\nsudo rpi-update    If even a firmware update doesn't fix the problem, your Camera Module may be defective, and may need to be replaced.",
            "title": "Troubleshooting"
        },
        {
            "location": "/raspbian/applications/camera/index.html#common-command-line-options",
            "text": "",
            "title": "Common command line options"
        },
        {
            "location": "/raspbian/applications/camera/index.html#preview-window",
            "text": "--preview,  -p      Preview window settings <'x,y,w,h'>  Allows the user to define the size of the preview window and its location on the screen. Note this will be superimposed over the top of any other windows/graphics.      --fullscreen,   -f      Fullscreen preview mode  Forces the preview window to use the whole screen. Note that the aspect ratio of the incoming image will be retained, so there may be bars on some edges.      --nopreview,    -n      Do not display a preview window  Disables the preview window completely. Note that even though the preview is disabled, the camera will still be producing frames, so will be using power.      --opacity,  -op     Set preview window opacity  Sets the opacity of the preview windows. 0 = invisible, 255 = fully opaque.",
            "title": "Preview window"
        },
        {
            "location": "/raspbian/applications/camera/index.html#camera-control-options",
            "text": "--sharpness,    -sh     Set image sharpness (-100 - 100)  Sets the sharpness of the image. 0 is the default.      --contrast, -co     Set image contrast (-100 - 100)  Sets the contrast of the image. 0 is the default.      --brightness,   -br     Set image brightness (0 - 100)  Sets the brightness of the image. 50 is the default. 0 is black, 100 is white.      --saturation,   -sa     Set image saturation (-100 - 100)  Sets the colour saturation of the image. 0 is the default.      --ISO,  -ISO        Set capture ISO (100 - 800)  Sets the ISO to be used for captures.      --vstab,    -vs     Turn on video stabilisation  In video mode only, turns on video stabilisation.      --ev,   -ev     Set EV compensation (-10 - 10)  Sets the EV compensation of the image. Default is 0.      --exposure, -ex     Set exposure mode  Possible options are:   auto: use automatic exposure mode  night: select setting for night shooting  nightpreview:   backlight: select setting for backlit subject  spotlight:    sports: select setting for sports (fast shutter etc.)  snow: select setting optimised for snowy scenery  beach: select setting optimised for beach  verylong: select setting for long exposures  fixedfps: constrain fps to a fixed value  antishake: antishake mode  fireworks: select setting optimised for fireworks   Note that not all of these settings may be implemented, depending on camera tuning.      --awb,  -awb        Set Automatic White Balance (AWB) mode  Modes for which colour temperature ranges (K) are available have these settings in brackets.   off: turn off white balance calculation  auto: automatic mode (default)  sun: sunny mode (between 5000K and 6500K)   cloud: cloudy mode (between 6500K and 12000K)  shade: shade mode   tungsten: tungsten lighting mode (between 2500K and 3500K)  fluorescent: fluorescent lighting mode (between 2500K and 4500K)  incandescent: incandescent lighting mode  flash: flash mode  horizon: horizon mode   Note that not all of these settings may be implemented, depending on camera type.      --imxfx,    -ifx        Set image effect  Set an effect to be applied to the image:   none: no effect (default)  negative: invert the image colours  solarise: solarise the image  posterise: posterise the image  whiteboard: whiteboard effect  blackboard: blackboard effect  sketch: sketch effect  denoise: denoise the image  emboss: emboss the image  oilpaint: oil paint effect  hatch: hatch sketch effect  gpen: graphite sketch effect  pastel: pastel effect  watercolour: watercolour effect  film: film grain effect  blur: blur the image  saturation: colour saturate the image  colourswap: not fully implemented  washedout: not fully implemented  colourpoint: not fully implemented  colourbalance: not fully implemented  cartoon: not fully implemented   Note that not all of these settings may be available in all circumstances.      --colfx,    -cfx        Set colour effect <U:V>  The supplied U and V parameters (range 0 - 255) are applied to the U and Y channels of the image. For example, --colfx 128:128 should result in a monochrome image.      --metering, -mm     Set metering mode  Specify the metering mode used for the preview and capture:   average: average the whole frame for metering  spot: spot metering  backlit: assume a backlit image  matrix: matrix metering       --rotation, -rot        Set image rotation (0 - 359)  Sets the rotation of the image in the viewfinder and resulting image. This can take any value from 0 upwards, but due to hardware constraints only 0, 90, 180, and 270 degree rotations are supported.      --hflip,    -hf     Set horizontal flip  Flips the preview and saved image horizontally.      --vflip,    -vf     Set vertical flip  Flips the preview and saved image vertically.      --roi,  -roi        Set sensor region of interest  Allows the specification of the area of the sensor to be used as the source for the preview and capture. This is defined as x,y for the top-left corner, and a width and height, with all values in normalised coordinates (0.0 - 1.0). So, to set a ROI at halfway across and down the sensor, and a width and height of a quarter of the sensor, use:  -roi 0.5,0.5,0.25,0.25  --shutter,  -ss     Set shutter speed  Sets the shutter speed to the specified value (in microseconds). There's currently an upper limit of approximately 6000000us (6000ms, 6s), past which operation is undefined.  --drc,  -drc        Enable/disable dynamic range compression  DRC changes the images by increasing the range of dark areas, and decreasing the brighter areas. This can improve the image in low light areas.   off  low  med  high   By default, DRC is off.  --stats,    -st     Display image statistics  Displays the exposure, analogue and digital gains, and AWB settings used.  --awbgains, -awbg  Sets blue and red gains (as floating point numbers) to be applied when  -awb -off  is set e.g. -awbg 1.5,1.2  --mode, -md  Sets a specified sensor mode, disabling the automatic selection. Possible values depend on the version of the Camera Module being used:   Version 1.x (OV5647)     Mode  Size  Aspect Ratio  Frame rates  FOV  Binning      0  automatic selection        1  1920x1080  16:9  1-30fps  Partial  None    2  2592x1944  4:3  1-15fps  Full  None    3  2592x1944  4:3  0.1666-1fps  Full  None    4  1296x972  4:3  1-42fps  Full  2x2    5  1296x730  16:9  1-49fps  Full  2x2    6  640x480  4:3  42.1-60fps  Full  2x2 plus skip    7  640x480  4:3  60.1-90fps  Full  2x2 plus skip     Version 2.x (IMX219)     Mode  Size  Aspect Ratio  Frame rates  FOV  Binning      0  automatic selection        1  1920x1080  16:9  0.1-30fps  Partial  None    2  3280x2464  4:3  0.1-15fps  Full  None    3  3280x2464  4:3  0.1-15fps  Full  None    4  1640x1232  4:3  0.1-40fps  Full  2x2    5  1640x922  16:9  0.1-40fps  Full  2x2    6  1280x720  16:9  40-90fps  Partial  2x2    7  640x480  4:3  40-90fps  Partial  2x2         --camselect,    -cs  Selects which camera to use on a multi-camera system. Use 0 or 1.      --annotate, -a      Enable/set annotate flags or text  Adds some text and/or metadata to the picture.  Metadata is indicated using a bitmask notation, so add them together to show multiple parameters. For example, 12 will show time(4) and date(8), since 4+8=12.  Text may include date/time placeholders by using the '%' character, as used by  strftime .     Value  Meaning  Example Output      -a 4  Time  20:09:33    -a 8  Date  10/28/15    -a 12  4+8=12 Show the date(4) and time(8)  20:09:33 10/28/15    -a 16  Shutter Settings     -a 32  CAF Settings     -a 64  Gain Settings     -a 128  Lens Settings     -a 256  Motion Settings     -a 512  Frame Number     -a 1024  Black Background     -a \"ABC %Y-%m-%d %X\"  Show some text  ABC %Y-%m-%d %X    -a 4 -a \"ABC %Y-%m-%d %X\"  Show custom  formatted  date/time  ABC 2015-10-28 20:09:33    -a 8 -a \"ABC %Y-%m-%d %X\"  Show custom  formatted  date/time  ABC 2015-10-28 20:09:33     --annotateex,   -ae     Set extra annotation parameters  Specifies annotation size, text colour, and background colour. Colours are in hex YUV format.  Size ranges from 6 - 160; default is 32. Asking for an invalid size should give you the default.     Example  Explanation      -ae 32,0xff,0x808000 -a \"Annotation text\"  gives size 32 white text on black background    -ae 10,0x00,0x8080FF -a \"Annotation text\"  gives size 10 black text on white background",
            "title": "Camera control options"
        },
        {
            "location": "/raspbian/applications/camera/index.html#application-specific-settings",
            "text": "",
            "title": "Application-specific settings"
        },
        {
            "location": "/raspbian/applications/camera/index.html#raspistill",
            "text": "--width,    -w      Set image width <size>\n\n--height,   -h      Set image height <size>\n\n--quality,  -q      Set JPEG quality <0 to 100>  Quality 100 is almost completely uncompressed. 75 is a good all-round value.  --raw,  -r      Add raw Bayer data to JPEG metadata  This option inserts the raw Bayer data from the camera into the JPEG metadata.  --output,   -o      Output filename <filename>  Specifies the output filename. If not specified, no file is saved. If the filename is '-', then all output is sent to stdout.  --latest,   -l      Link latest frame to filename <filename>  Makes a file system link under this name to the latest frame.  --verbose,  -v      Output verbose information during run  Outputs debugging/information messages during the program run.  --timeout,  -t      Time before the camera takes picture and shuts down  The program will run for this length of time, then take the capture (if output is specified). If not specified, this is set to 5 seconds.  --timelapse,    -tl     time-lapse mode  The specific value is the time between shots in milliseconds. Note that you should specify  %04d  at the point in the filename where you want a frame count number to appear. So, for example, the code below will produce a capture every 2 seconds, over a total period of 30s, named  image0001.jpg ,  image0002.jpg  and so on, through to  image0015.jpg .   -t 30000 -tl 2000 -o image%04d.jpg  Note that the  %04d  indicates a 4-digit number, with leading zeroes added to make the required number of digits. So, for example,   %08d  would result in an 8-digit number.  If a time-lapse value of 0 is entered, the application will take pictures as fast as possible. Note that there's an minimum enforced pause of 30ms between captures to ensure that exposure calculations can be made.  --thumb,    -th     Set thumbnail parameters (x:y:quality)  Allows specification of the thumbnail image inserted into the JPEG file. If not specified, defaults are a size of 64x48 at quality 35.  if  --thumb none  is specified, no thumbnail information will be placed in the file. This reduces the file size slightly.  --demo, -d      Run a demo mode <milliseconds>  This options cycles through the range of camera options. No capture is taken, and the demo will end at the end of the timeout period, irrespective of whether all the options have been cycled. The time between cycles should be specified as a millisecond value.  --encoding, -e      Encoding to use for output file  Valid options are  jpg ,  bmp ,  gif , and  png . Note that unaccelerated image types (GIF, PNG, BMP) will take much longer to save than jpg, which is hardware accelerated. Also note that the filename suffix is completely ignored when deciding the encoding of a file.  --exif, -x      EXIF tag to apply to captures (format as 'key=value')  Allows the insertion of specific EXIF tags into the JPEG image. You can have up to 32 EXIF tag entries. This is useful for tasks like adding GPS metadata. For example, to set the longitude:  --exif GPS.GPSLongitude=5/1,10/1,15/1  would set the longitude to 5 degs, 10 minutes, 15 seconds. See EXIF documentation for more details on the range of tags available; the supported tags are as follows:  IFD0.<   or\nIFD1.<\nImageWidth, ImageLength, BitsPerSample, Compression, PhotometricInterpretation, ImageDescription, Make, Model, StripOffsets, Orientation, SamplesPerPixel, RowsPerString, StripByteCounts, XResolution, YResolution, PlanarConfiguration, ResolutionUnit, TransferFunction, Software, DateTime, Artist, WhitePoint, PrimaryChromaticities, JPEGInterchangeFormat, JPEGInterchangeFormatLength, YCbCrCoefficients, YCbCrSubSampling, YCbCrPositioning, ReferenceBlackWhite, Copyright>\n\nEXIF.<\nExposureTime, FNumber, ExposureProgram, SpectralSensitivity, ISOSpeedRatings, OECF, ExifVersion, DateTimeOriginal, DateTimeDigitized, ComponentsConfiguration, CompressedBitsPerPixel, ShutterSpeedValue, ApertureValue, BrightnessValue, ExposureBiasValue, MaxApertureValue, SubjectDistance, MeteringMode, LightSource, Flash, FocalLength, SubjectArea, MakerNote, UserComment, SubSecTime, SubSecTimeOriginal, SubSecTimeDigitized, FlashpixVersion, ColorSpace, PixelXDimension, PixelYDimension, RelatedSoundFile, FlashEnergy, SpatialFrequencyResponse, FocalPlaneXResolution, FocalPlaneYResolution, FocalPlaneResolutionUnit, SubjectLocation, ExposureIndex, SensingMethod, FileSource, SceneType, CFAPattern, CustomRendered, ExposureMode, WhiteBalance, DigitalZoomRatio, FocalLengthIn35mmFilm, SceneCaptureType, GainControl, Contrast, Saturation, Sharpness, DeviceSettingDescription, SubjectDistanceRange, ImageUniqueID>\n\nGPS.<\nGPSVersionID, GPSLatitudeRef, GPSLatitude, GPSLongitudeRef, GPSLongitude, GPSAltitudeRef, GPSAltitude, GPSTimeStamp, GPSSatellites, GPSStatus, GPSMeasureMode, GPSDOP, GPSSpeedRef, GPSSpeed, GPSTrackRef, GPSTrack, GPSImgDirectionRef, GPSImgDirection, GPSMapDatum, GPSDestLatitudeRef, GPSDestLatitude, GPSDestLongitudeRef, GPSDestLongitude, GPSDestBearingRef, GPSDestBearing, GPSDestDistanceRef, GPSDestDistance, GPSProcessingMethod, GPSAreaInformation, GPSDateStamp, GPSDifferential>\n\nEINT.<\nInteroperabilityIndex, InteroperabilityVersion, RelatedImageFileFormat, RelatedImageWidth, RelatedImageLength>  Note that a small subset of these tags will be set automatically by the camera system, but will be overridden by any EXIF options on the command line.  Setting  --exif none  will prevent any EXIF information being stored in the file. This reduces the file size slightly.  --fullpreview,  -fp     Full preview mode  This runs the preview window using the full resolution capture mode. Maximum frames per second in this mode is 15fps, and the preview will have the same field of view as the capture. Captures should happen more quickly, as no mode change should be required. This feature is currently under development.  --keypress, -k      Keypress mode  The camera is run for the requested time ( -t ), and a capture can be initiated throughout that time by pressing the Enter key. Pressing X then Enter will exit the application before the timeout is reached. If the timeout is set to 0, the camera will run indefinitely until the user presses X then Enter. Using the verbose option ( -v ) will display a prompt asking for user input, otherwise no prompt is displayed.  --signal,   -s      Signal mode  The camera is run for the requested time ( -t ), and a capture can be initiated throughout that time by sending a  USR1  signal to the camera process. This can be done using the  kill  command. You can find the camera process ID using the  pgrep raspistill  command.  kill -USR1 <process id of raspistill>",
            "title": "raspistill"
        },
        {
            "location": "/raspbian/applications/camera/index.html#raspistillyuv",
            "text": "Many of the options for  raspistillyuv  are the same as those for  raspistill . This section shows the differences.  Unsupported options:  --exif, --encoding, --thumb, --raw, --quality  Extra options :  --rgb,  -rgb        Save uncompressed data as RGB888  This option forces the image to be saved as RGB data with 8 bits per channel, rather than YUV420.  Note that the image buffers saved in  raspistillyuv  are padded to a horizontal size divisible by 32, so there may be unused bytes at the end of each line. Buffers are also padded vertically to be divisible by 16, and in the YUV mode, each plane of Y,U,V is padded in this way.",
            "title": "raspistillyuv"
        },
        {
            "location": "/raspbian/applications/camera/index.html#raspivid",
            "text": "--width,    -w      Set image width <size>  Width of resulting video. This should be between 64 and 1920.  --height,   -h      Set image height <size>  Height of resulting video. This should be between 64 and 1080.  --bitrate,  -b      Set bitrate  Use bits per second, so 10Mbits/s would be  -b 10000000 . For H264, 1080p30 a high quality bitrate would be 15Mbits/s or more. Maximum bitrate is 25Mbits/s ( -b 25000000 ), but much over 17Mbits/s won't show noticeable improvement at 1080p30.  --output,   -o      Output filename <filename>  Specify the output filename. If not specified, no file is saved. If the filename is '-', then all output is sent to stdout.  --verbose,  -v      Output verbose information during run  Outputs debugging/information messages during the program run.  --timeout,  -t      Time before the camera takes picture and shuts down  The program will run for this length of time, then take the capture (if output is specified). If not specified, this is set to 5 seconds. Setting 0 will mean the application will run continuously until stopped with Ctrl-C.  --demo, -d      Run a demo mode <milliseconds>  This options cycles through the range of camera options. No capture is done, and the demo will end at the end of the timeout period, irrespective of whether all the options have been cycled. The time between cycles should be specified as a millisecond value.  --framerate,    -fps        Specify the frames per second to record  At present, the minimum frame rate allowed is 2fps, and the maximum is 30fps. This is likely to change in the future.  --penc, -e      Display preview image after encoding  Switch on an option to display the preview after compression. This will show any compression artefacts in the preview window. In normal operation, the preview will show the camera output prior to being compressed. This option is not guaranteed to work in future releases.  --intra,    -g      Specify the intra refresh period (key frame rate/GoP)  Sets the intra refresh period (GoP) rate for the recorded video. H264 video uses a complete frame (I-frame) every intra refresh period, from which subsequent frames are based. This option specifies the number of frames between each I-frame. Larger numbers here will reduce the size of the resulting video, and smaller numbers make the stream less error-prone.  --qp,   -qp     Set quantisation parameter  Sets the initial quantisation parameter for the stream. Varies from approximately 10 to 40, and will greatly affect the quality of the recording. Higher values reduce quality and decrease file size. Combine this setting with a bitrate of 0 to set a completely variable bitrate.  --profile,  -pf     Specify H264 profile to use for encoding  Sets the H264 profile to be used for the encoding. Options are:   baseline  main  high   --inline,   -ih     Insert PPS, SPS headers  Forces the stream to include PPS and SPS headers on every I-frame. Needed for certain streaming cases e.g. Apple HLS. These headers are small, so don't greatly increase the file size.  --timed,    -td     Do timed switches between capture and pause  This options allows the video capture to be paused and restarted at particular time intervals. Two values are required: the on time and the off time. On time is the amount of time the video is captured, and off time is the amount it is paused. The total time of the recording is defined by the  timeout  option. Note that the recording may take slightly over the timeout setting depending on the on and off times.  For example:  raspivid -o test.h264 -t 25000 -timed 2500,5000  will record for a period of 25 seconds. The recording will be over a timeframe consisting of 2500ms (2.5s) segments with 5000ms (5s) gaps, repeating over the 20s. So the entire recording will actually be only 10s long, since 4 segments of 2.5s = 10s separated by 5s gaps. So:  2.5 record \u2013 5 pause - 2.5 record \u2013 5 pause - 2.5 record \u2013 5 pause \u2013 2.5 record  gives a total recording period of 25s, but only 10s of actual recorded footage.  --keypress, -k      Toggle between record and pause on Enter keypress  On each press of the Enter key, the recording will be paused or restarted. Pressing X then Enter will stop recording and close the application. Note that the timeout value will be used to signal the end of recording, but is only checked after each Enter keypress; so if the system is waiting for a keypress, even if the timeout has expired, it will still wait for the keypress before exiting.  --signal,   -s      Toggle between record and pause according to SIGUSR1  Sending a  USR1  signal to the  raspivid  process will toggle between recording and paused. This can be done using the  kill  command, as below. You can find the  raspivid  process ID using  pgrep raspivid .  kill -USR1 <process id of raspivid>  Note that the timeout value will be used to indicate the end of recording, but is only checked after each receipt of the  SIGUSR1  signal; so if the system is waiting for a signal, even if the timeout has expired, it will still wait for the signal before exiting.  --initial,  -i      Define initial state on startup  Define whether the camera will start paused or will immediately start recording. Options are  record  or  pause . Note that if you are using a simple timeout, and  initial  is set to  pause , no output will be recorded.  --segment,  -sg     Segment the stream into multiple files  Rather than creating a single file, the file is split into segments of approximately the number of milliseconds specified. In order to provide different filenames, you should add   %04d  or similar at the point in the filename where you want a segment count number to appear e.g:  --segment 3000 -o video%04d.h264  will produce video clips of approximately 3000ms (3s) long, named  video0001.h264 ,  video0002.h264  etc. The clips should be seamless (no frame drops between clips), but the accuracy of each clip length will depend on the intraframe period, as the segments will always start on an I-frame. They will therefore always be equal or longer to the specified period.  --wrap, -wr     Set the maximum value for segment number  When outputting segments, this is the maximum the segment number can reach before it's reset to 1,  giving the ability to keep recording segments, but overwriting the oldest one. So if set to 4, in the segment example above, the files produced will be  video0001.h264 ,  video0002.h264 ,  video0003.h264 , and  video0004.h264 . Once  video0004.h264  is recorded, the count will reset to 1, and  video0001.h264  will be overwritten.  --start,    -sn     Set the initial segment number  When outputting segments, this is the initial segment number, giving the ability to resume a previous recording from a given segment. The default value is 1.",
            "title": "raspivid"
        },
        {
            "location": "/raspbian/applications/camera/index.html#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/raspbian/applications/camera/index.html#still-captures",
            "text": "By default, captures are done at the highest resolution supported by the sensor. This can be changed using the  -w  and  -h  command line options.  Take a default capture after 2s (times are specified in milliseconds) on the viewfinder, saving in  image.jpg :  raspistill -t  2000  -o image.jpg  Take a capture at a different resolution:  raspistill -t  2000  -o image.jpg -w  640  -h  480   Reduce the quality considerably to reduce file size:  raspistill -t  2000  -o image.jpg -q  5   Force the preview to appear at coordinate 100,100, with width 300 pixels and height 200 pixels:  raspistill -t  2000  -o image.jpg -p  100 ,100,300,200  Disable preview entirely:  raspistill -t  2000  -o image.jpg -n  Save the image as a PNG file (lossless compression, but slower than JPEG). Note that the filename suffix is ignored when choosing the image encoding:  raspistill -t  2000  -o image.png \u2013e png  Add some EXIF information to the JPEG. This sets the Artist tag name to Boris, and the GPS altitude to 123.5m. Note that if setting GPS tags you should set as a minimum GPSLatitude, GPSLatitudeRef, GPSLongitude, GPSLongitudeRef, GPSAltitude, and GPSAltitudeRef:  raspistill -t  2000  -o image.jpg -x IFD0.Artist = Boris -x GPS.GPSAltitude = 1235 /10  Set an emboss image effect:  raspistill -t  2000  -o image.jpg -ifx emboss  Set the U and V channels of the YUV image to specific values (128:128 produces a greyscale image):  raspistill -t  2000  -o image.jpg -cfx  128 :128  Run preview for 2s, with no saved image:  raspistill -t  2000   Take a time-lapse picture, every 10 seconds for 10 minutes (10 minutes = 600000ms), naming the files  image_num_001_today.jpg ,  image_num_002_today.jpg  and so on, with the latest picture also available under the name  latest.jpg :  raspistill -t  600000  -tl  10000  -o image_num_%03d_today.jpg -l latest.jpg  Take a picture and send the image data to stdout:  raspistill -t  2000  -o -  Take a picture and send the image data to a file:  raspistill -t  2000  -o - > my_file.jpg  Run the camera forever, taking a picture when Enter is pressed:  raspistill -t  0  -k -o my_pics%02d.jpg",
            "title": "Still captures"
        },
        {
            "location": "/raspbian/applications/camera/index.html#video-captures",
            "text": "Image size and preview settings are the same as for stills capture. Default size for video recording is 1080p (1920x1080).  Record a 5s clip with default settings (1080p30):  raspivid -t  5000  -o video.h264  Record a 5s clip at a specified bitrate (3.5Mbits/s):  raspivid -t  5000  -o video.h264 -b  3500000   Record a 5s clip at a specified framerate (5fps):  raspivid -t  5000  -o video.h264 -f  5   Encode a 5s camera stream and send the image data to stdout:  raspivid -t  5000  -o -  Encode a 5s camera stream and send the image data to a file:  raspivid -t  5000  -o - > my_file.h264",
            "title": "Video captures"
        },
        {
            "location": "/raspbian/applications/camera/index.html#shell-error-codes",
            "text": "The applications described here will return a standard error code to the shell on completion. Possible error codes are:     C Define  Code  Description      EX_OK  0  Application ran successfully    EX_USAGE  64  Bad command line parameter    EX_SOFTWARE  70  Software or camera error     130  Application terminated by Ctrl-C",
            "title": "Shell error codes"
        },
        {
            "location": "/raspbian/applications/omxplayer/index.html",
            "text": "OMXPlayer: An accelerated command line media player\n\n\nInstalled on Raspbian is a command line media player, called OMXPlayer. This is HW accelerated, and can play back many popular audio and video file formats.\n\n\nOMXPlayer was developed by the Kodi project's Edgar Hucek.\n\n\nOMXPlayer uses the OpenMAX (omx) hardware acceleration interface (API) which is the officially supported media API on the Raspberry Pi.\n\n\nBasic usage\n\n\nThe simplest command line is \nomxplayer <name of media file>\n. The media file can be audio or video or both. For the examples below, we used an H264 video file that is included with the standard Raspbian installation.\n\n\nomxplayer /opt/vc/src/hello_pi/hello_video/test.h264\n\n\n\n\n\nBy default the audio is sent to the analog port. If you are using a HDMI-equipped display device with speakers, you need to tell omxplayer to send the audio signal over the HDMI link.\n\n\nomxplayer -adev hdmi /opt/vc/src/hello_pi/hello_video/test.h264\n\n\n\n\n\nWhen displaying video, the whole display will be used as output. You can specify which part of the display you want the video to be on using the window option.\n\n\nomxplayer --win 0,0,640,480 /opt/vc/src/hello_pi/hello_video/test.h264\n\n\n\n\n\nYou can also specify which part of the video you want to be displayed: this is called a crop window. This portion of the video will be scaled up to match the display, unless you also use the window option.\n\n\nomxplayer --crop 100,100,300,300 /opt/vc/src/hello_pi/hello_video/test.h264\n\n\n\n\n\nIf you are using the Raspberry Pi Foundation's touchscreen display, and you want to use it for video output, use the display option to specify which display to use. \nn\n is 5 for HDMI, 4 for the touchscreen.\n\n\nomxplayer --display n /opt/vc/src/hello_pi/hello_video/test.h264\n\n\n\n\n\nOptions available during playback\n\n\nThere are a number of options available during playback, actioned by pressing the appropriate key. Not all options will be available on all files. The list of key bindings can be displayed using \nomxplayer --keys\n:\n\n\n    1           decrease speed\n    2           increase speed\n    <           rewind\n    >           fast forward\n    z           show info\n    j           previous audio stream\n    k           next audio stream\n    i           previous chapter\n    o           next chapter\n    n           previous subtitle stream\n    m           next subtitle stream\n    s           toggle subtitles\n    w           show subtitles\n    x           hide subtitles\n    d           decrease subtitle delay (- 250 ms)\n    f           increase subtitle delay (+ 250 ms)\n    q           exit omxplayer\n    p / space   pause/resume\n    -           decrease volume\n    + / =       increase volume\n    left arrow  seek -30 seconds\n    right arrow seek +30 seconds\n    down arrow  seek -600 seconds\n    up arrow    seek +600 seconds\n\n\n\n\n\nAll command line options\n\n\nThis is a full list of options available in the build from 23rd September 2016, displayed using \nomxplayer --help\n:\n\n\n -h  --help                  Print this help\n -v  --version               Print version info\n -k  --keys                  Print key bindings\n -n  --aidx  index           Audio stream index    : e.g. 1\n -o  --adev  device          Audio out device      : e.g. hdmi/local/both/alsa[:device]\n -i  --info                  Dump stream format and exit\n -I  --with-info             dump stream format before playback\n -s  --stats                 Pts and buffer stats\n -p  --passthrough           Audio passthrough\n -d  --deinterlace           Force deinterlacing\n     --nodeinterlace         Force no deinterlacing\n     --nativedeinterlace     let display handle interlace\n     --anaglyph type         convert 3d to anaglyph\n     --advanced[=0]          Enable/disable advanced deinterlace for HD videos (default enabled)\n -w  --hw                    Hw audio decoding\n -3  --3d mode               Switch tv into 3d mode (e.g. SBS/TB)\n -M  --allow-mvc             Allow decoding of both views of MVC stereo stream\n -y  --hdmiclocksync         Display refresh rate to match video (default)\n -z  --nohdmiclocksync       Do not adjust display refresh rate to match video\n -t  --sid index             Show subtitle with index\n -r  --refresh               Adjust framerate/resolution to video\n -g  --genlog                Generate log file\n -l  --pos n                 Start position (hh:mm:ss)\n -b  --blank[=0xAARRGGBB]    Set the video background color to black (or optional ARGB value)\n     --loop                  Loop file. Ignored if file not seekable\n     --no-boost-on-downmix   Don't boost volume when downmixing\n     --vol n                 set initial volume in millibels (default 0)\n     --amp n                 set initial amplification in millibels (default 0)\n     --no-osd                Do not display status information on screen\n     --no-keys               Disable keyboard input (prevents hangs for certain TTYs)\n     --subtitles path        External subtitles in UTF-8 srt format\n     --font path             Default: /usr/share/fonts/truetype/freefont/FreeSans.ttf\n     --italic-font path      Default: /usr/share/fonts/truetype/freefont/FreeSansOblique.ttf\n     --font-size size        Font size in 1/1000 screen height (default: 55)\n     --align left/center     Subtitle alignment (default: left)\n     --no-ghost-box          No semitransparent boxes behind subtitles\n     --lines n               Number of lines in the subtitle buffer (default: 3)\n     --win 'x1 y1 x2 y2'     Set position of video window\n --win x1,y1,x2,y2       Set position of video window\n --crop 'x1 y1 x2 y2'    Set crop area for input video\n --crop x1,y1,x2,y2      Set crop area for input video\n --aspect-mode type      Letterbox, fill, stretch. Default is stretch if win is specified, letterbox otherwise\n --audio_fifo  n         Size of audio output fifo in seconds\n --video_fifo  n         Size of video output fifo in MB\n --audio_queue n         Size of audio input queue in MB\n --video_queue n         Size of video input queue in MB\n --threshold   n         Amount of buffered data required to finish buffering [s]\n --timeout     n         Timeout for stalled file/network operations (default 10s)\n --orientation n         Set orientation of video (0, 90, 180 or 270)\n --fps n                 Set fps of video where timestamps are not present\n --live                  Set for live tv or vod type stream\n --layout                Set output speaker layout (e.g. 5.1)\n --dbus_name name        default: org.mpris.MediaPlayer2.omxplayer\n --key-config <file>     Uses key bindings in <file> instead of the default\n --alpha                 Set video transparency (0..255)\n --layer n               Set video render layer number (higher numbers are on top)\n --display n             Set display to output to\n --cookie 'cookie'       Send specified cookie as part of HTTP requests\n --user-agent 'ua'       Send specified User-Agent as part of HTTP requests\n --lavfdopts 'opts'      Options passed to libavformat, e.g. 'probesize:250000,...'\n --avdict 'opts'         Options passed to demuxer, e.g., 'rtsp_transport:tcp,...'",
            "title": "OMXPlayer: An accelerated command line media player"
        },
        {
            "location": "/raspbian/applications/omxplayer/index.html#omxplayer-an-accelerated-command-line-media-player",
            "text": "Installed on Raspbian is a command line media player, called OMXPlayer. This is HW accelerated, and can play back many popular audio and video file formats.  OMXPlayer was developed by the Kodi project's Edgar Hucek.  OMXPlayer uses the OpenMAX (omx) hardware acceleration interface (API) which is the officially supported media API on the Raspberry Pi.",
            "title": "OMXPlayer: An accelerated command line media player"
        },
        {
            "location": "/raspbian/applications/omxplayer/index.html#basic-usage",
            "text": "The simplest command line is  omxplayer <name of media file> . The media file can be audio or video or both. For the examples below, we used an H264 video file that is included with the standard Raspbian installation.  omxplayer /opt/vc/src/hello_pi/hello_video/test.h264  By default the audio is sent to the analog port. If you are using a HDMI-equipped display device with speakers, you need to tell omxplayer to send the audio signal over the HDMI link.  omxplayer -adev hdmi /opt/vc/src/hello_pi/hello_video/test.h264  When displaying video, the whole display will be used as output. You can specify which part of the display you want the video to be on using the window option.  omxplayer --win 0,0,640,480 /opt/vc/src/hello_pi/hello_video/test.h264  You can also specify which part of the video you want to be displayed: this is called a crop window. This portion of the video will be scaled up to match the display, unless you also use the window option.  omxplayer --crop 100,100,300,300 /opt/vc/src/hello_pi/hello_video/test.h264  If you are using the Raspberry Pi Foundation's touchscreen display, and you want to use it for video output, use the display option to specify which display to use.  n  is 5 for HDMI, 4 for the touchscreen.  omxplayer --display n /opt/vc/src/hello_pi/hello_video/test.h264",
            "title": "Basic usage"
        },
        {
            "location": "/raspbian/applications/omxplayer/index.html#options-available-during-playback",
            "text": "There are a number of options available during playback, actioned by pressing the appropriate key. Not all options will be available on all files. The list of key bindings can be displayed using  omxplayer --keys :      1           decrease speed\n    2           increase speed\n    <           rewind\n    >           fast forward\n    z           show info\n    j           previous audio stream\n    k           next audio stream\n    i           previous chapter\n    o           next chapter\n    n           previous subtitle stream\n    m           next subtitle stream\n    s           toggle subtitles\n    w           show subtitles\n    x           hide subtitles\n    d           decrease subtitle delay (- 250 ms)\n    f           increase subtitle delay (+ 250 ms)\n    q           exit omxplayer\n    p / space   pause/resume\n    -           decrease volume\n    + / =       increase volume\n    left arrow  seek -30 seconds\n    right arrow seek +30 seconds\n    down arrow  seek -600 seconds\n    up arrow    seek +600 seconds",
            "title": "Options available during playback"
        },
        {
            "location": "/raspbian/applications/omxplayer/index.html#all-command-line-options",
            "text": "This is a full list of options available in the build from 23rd September 2016, displayed using  omxplayer --help :   -h  --help                  Print this help\n -v  --version               Print version info\n -k  --keys                  Print key bindings\n -n  --aidx  index           Audio stream index    : e.g. 1\n -o  --adev  device          Audio out device      : e.g. hdmi/local/both/alsa[:device]\n -i  --info                  Dump stream format and exit\n -I  --with-info             dump stream format before playback\n -s  --stats                 Pts and buffer stats\n -p  --passthrough           Audio passthrough\n -d  --deinterlace           Force deinterlacing\n     --nodeinterlace         Force no deinterlacing\n     --nativedeinterlace     let display handle interlace\n     --anaglyph type         convert 3d to anaglyph\n     --advanced[=0]          Enable/disable advanced deinterlace for HD videos (default enabled)\n -w  --hw                    Hw audio decoding\n -3  --3d mode               Switch tv into 3d mode (e.g. SBS/TB)\n -M  --allow-mvc             Allow decoding of both views of MVC stereo stream\n -y  --hdmiclocksync         Display refresh rate to match video (default)\n -z  --nohdmiclocksync       Do not adjust display refresh rate to match video\n -t  --sid index             Show subtitle with index\n -r  --refresh               Adjust framerate/resolution to video\n -g  --genlog                Generate log file\n -l  --pos n                 Start position (hh:mm:ss)\n -b  --blank[=0xAARRGGBB]    Set the video background color to black (or optional ARGB value)\n     --loop                  Loop file. Ignored if file not seekable\n     --no-boost-on-downmix   Don't boost volume when downmixing\n     --vol n                 set initial volume in millibels (default 0)\n     --amp n                 set initial amplification in millibels (default 0)\n     --no-osd                Do not display status information on screen\n     --no-keys               Disable keyboard input (prevents hangs for certain TTYs)\n     --subtitles path        External subtitles in UTF-8 srt format\n     --font path             Default: /usr/share/fonts/truetype/freefont/FreeSans.ttf\n     --italic-font path      Default: /usr/share/fonts/truetype/freefont/FreeSansOblique.ttf\n     --font-size size        Font size in 1/1000 screen height (default: 55)\n     --align left/center     Subtitle alignment (default: left)\n     --no-ghost-box          No semitransparent boxes behind subtitles\n     --lines n               Number of lines in the subtitle buffer (default: 3)\n     --win 'x1 y1 x2 y2'     Set position of video window\n --win x1,y1,x2,y2       Set position of video window\n --crop 'x1 y1 x2 y2'    Set crop area for input video\n --crop x1,y1,x2,y2      Set crop area for input video\n --aspect-mode type      Letterbox, fill, stretch. Default is stretch if win is specified, letterbox otherwise\n --audio_fifo  n         Size of audio output fifo in seconds\n --video_fifo  n         Size of video output fifo in MB\n --audio_queue n         Size of audio input queue in MB\n --video_queue n         Size of video input queue in MB\n --threshold   n         Amount of buffered data required to finish buffering [s]\n --timeout     n         Timeout for stalled file/network operations (default 10s)\n --orientation n         Set orientation of video (0, 90, 180 or 270)\n --fps n                 Set fps of video where timestamps are not present\n --live                  Set for live tv or vod type stream\n --layout                Set output speaker layout (e.g. 5.1)\n --dbus_name name        default: org.mpris.MediaPlayer2.omxplayer\n --key-config <file>     Uses key bindings in <file> instead of the default\n --alpha                 Set video transparency (0..255)\n --layer n               Set video render layer number (higher numbers are on top)\n --display n             Set display to output to\n --cookie 'cookie'       Send specified cookie as part of HTTP requests\n --user-agent 'ua'       Send specified User-Agent as part of HTTP requests\n --lavfdopts 'opts'      Options passed to libavformat, e.g. 'probesize:250000,...'\n --avdict 'opts'         Options passed to demuxer, e.g., 'rtsp_transport:tcp,...'",
            "title": "All command line options"
        },
        {
            "location": "/remote-access/README/index.html",
            "text": "Remote Access\n\n\nSometimes you need to access a Raspberry Pi without connecting it to a monitor. Perhaps the Pi is embedded in something like a robot, or you may want to view some information from it from elsewhere. Maybe you simply don't have a spare monitor! You can find more information on accessing your Raspberry Pi remotely here. \n\n\nContents\n\n\n\n\nIP address\n\n\nHow to find your Raspberry Pi's IP address in order to connect to it\n\n\n\n\n\n\nAccess over Internet\n\n\nRemote access to the Pi over the internet using Weaved or Dataplicity\n\n\n\n\n\n\nVNC\n\n\nRemote access to the Pi's graphical interface, viewed in a window on another computer\n\n\n\n\n\n\nSSH\n\n\nAccess the command line of the Pi from another computer\n\n\n\n\n\n\nSFTP\n\n\nCopy files between your Pi and another computer using SFTP (Secure File Transfer Protocol)\n\n\n\n\n\n\nSCP\n\n\nCopy files between your Pi and another computer using SCP (Secure Copy Protocol)\n\n\n\n\n\n\nSSHFS\n\n\nCopy files between your Pi and another computer using SSHFS (Secure Shell Filesystem)\n\n\n\n\n\n\nrsync\n\n\nSynchronise folders between the Pi and another computer using \nrsync\n over SSH\n\n\n\n\n\n\nFTP\n\n\nCopy files between your Pi and another computer using FTP (File Transfer Protocol)\n\n\n\n\n\n\nWeb Server\n\n\nSet up a website or a web page to display some information about the Pi, using a web browser on another machine, on the network or on the internet.",
            "title": "Remote Access"
        },
        {
            "location": "/remote-access/README/index.html#remote-access",
            "text": "Sometimes you need to access a Raspberry Pi without connecting it to a monitor. Perhaps the Pi is embedded in something like a robot, or you may want to view some information from it from elsewhere. Maybe you simply don't have a spare monitor! You can find more information on accessing your Raspberry Pi remotely here.",
            "title": "Remote Access"
        },
        {
            "location": "/remote-access/README/index.html#contents",
            "text": "IP address  How to find your Raspberry Pi's IP address in order to connect to it    Access over Internet  Remote access to the Pi over the internet using Weaved or Dataplicity    VNC  Remote access to the Pi's graphical interface, viewed in a window on another computer    SSH  Access the command line of the Pi from another computer    SFTP  Copy files between your Pi and another computer using SFTP (Secure File Transfer Protocol)    SCP  Copy files between your Pi and another computer using SCP (Secure Copy Protocol)    SSHFS  Copy files between your Pi and another computer using SSHFS (Secure Shell Filesystem)    rsync  Synchronise folders between the Pi and another computer using  rsync  over SSH    FTP  Copy files between your Pi and another computer using FTP (File Transfer Protocol)    Web Server  Set up a website or a web page to display some information about the Pi, using a web browser on another machine, on the network or on the internet.",
            "title": "Contents"
        },
        {
            "location": "/remote-access/ftp/index.html",
            "text": "FTP\n\n\nFTP (File Transfer Protocol) can be used to transfer files between a Raspberry Pi and another computer. Although with default program \nsftp-server\n of Raspbian the users with sufficient privilege can transfer files or directories, access to the filesystem of the limited users is also required often. Follow the steps below to set up an FTP server:\n\n\nInstall Pure-FTPd\n\n\nFirst, install \nPure-FTPd\n using the following command line in Terminal:\n\n\nsudo apt-get install pure-ftpd\n\n\n\n\n\nBasic Configurations\n\n\nWe need to create a new user group named \nftpgroup\n and a new user named \nftpuser\n for FTP users, and make sure this \"user\" has \nno\n login privilege and \nno\n home directory:\n\n\nsudo groupadd ftpgroup\nsudo useradd ftpuser -g ftpgroup -s /sbin/nologin -d /dev/null\n\n\n\n\n\nFTP Home Directory, Virtual User, and User Group\n\n\nFor instance, make a new directory named \nFTP\n for the first user:\n\n\nsudo mkdir /home/pi/FTP\n\n\n\n\n\nMake sure the directory is accessible for \nftpuser\n:\n\n\nsudo chown -R ftpuser:ftpgroup /home/pi/FTP\n\n\n\n\n\nCreate a virtual user named \nupload\n, mapping the virtual user to \nftpuser\n and \nftpgroup\n, setting home directory \n/home/pi/FTP\n, and record password of the user in database:\n\n\nsudo pure-pw useradd upload -u ftpuser -g ftpgroup -d /home/pi/FTP -m\n\n\n\n\n\nA password of that virtual user will be required after this command line is entered. And next, set up a virtual user database by typing:\n\n\nsudo pure-pw mkdb\n\n\n\n\n\nLast but not least, define an authentication method by making a link of file \n/etc/pure-ftpd/conf/PureDB\n, the number \n60\n is only for demonstration, make it as small as necessary:\n\n\nsudo ln -s /etc/pure-ftpd/conf/PureDB /etc/pure-ftpd/auth/60puredb\n\n\n\n\n\nRestart the program:\n\n\nsudo service pure-ftpd restart\n\n\n\n\n\nTest it with an FTP client, like FileZilla.\n\n\nMore Detailed Configurations:\n\n\nThe configuration of Pure-FTPd is simple and intuitive. The administrator only needs to define the necessary settings by making files with option names, like \nChrootEveryone\n, and typing \nyes\n, then storing in the directory \n/etc/pure-ftpd/conf\n, if all FTP users are to be locked in their FTP home directory (\n/home/pi/FTP\n). Here are some recommended settings:\n\n\nsudo nano /etc/pure-ftpd/conf/ChrootEveryone\n\n\n\n\n\nType \nyes\n, and press \nCtrl + X\n, \nY\n, and Enter.\n\n\nLikewise,\n\n\nMake a file named \nNoAnonymous\n and type \nyes\n;\n\n\nMake a file named \nAnonymousCantUpload\n and type \nyes\n;\n\n\nMake a file named \nAnonymousCanCreateDirs\n and type \nno\n;\n\n\nMake a file named \nDisplayDotFiles\n and type \nno\n;\n\n\nMake a file named \nDontResolve\n and type \nyes\n;\n\n\nMake a file named \nProhibitDotFilesRead\n and type \nyes\n;\n\n\nMake a file named \nProhibitDotFilesWrite\n and type \nyes\n;\n\n\nMake a file named \nFSCharset\n and type\nUTF-8\n;\n\n\n...\n\n\nRestart \npure-ftpd\n again and apply the above settings.\n\n\nsudo service pure-ftpd restart\n\n\n\n\n\nFor more information of Pure-FTPd and documentation, please get on official website of \nPure-FTPd\n.",
            "title": "FTP"
        },
        {
            "location": "/remote-access/ftp/index.html#ftp",
            "text": "FTP (File Transfer Protocol) can be used to transfer files between a Raspberry Pi and another computer. Although with default program  sftp-server  of Raspbian the users with sufficient privilege can transfer files or directories, access to the filesystem of the limited users is also required often. Follow the steps below to set up an FTP server:",
            "title": "FTP"
        },
        {
            "location": "/remote-access/ftp/index.html#install-pure-ftpd",
            "text": "First, install  Pure-FTPd  using the following command line in Terminal:  sudo apt-get install pure-ftpd",
            "title": "Install Pure-FTPd"
        },
        {
            "location": "/remote-access/ftp/index.html#basic-configurations",
            "text": "We need to create a new user group named  ftpgroup  and a new user named  ftpuser  for FTP users, and make sure this \"user\" has  no  login privilege and  no  home directory:  sudo groupadd ftpgroup\nsudo useradd ftpuser -g ftpgroup -s /sbin/nologin -d /dev/null",
            "title": "Basic Configurations"
        },
        {
            "location": "/remote-access/ftp/index.html#ftp-home-directory-virtual-user-and-user-group",
            "text": "For instance, make a new directory named  FTP  for the first user:  sudo mkdir /home/pi/FTP  Make sure the directory is accessible for  ftpuser :  sudo chown -R ftpuser:ftpgroup /home/pi/FTP  Create a virtual user named  upload , mapping the virtual user to  ftpuser  and  ftpgroup , setting home directory  /home/pi/FTP , and record password of the user in database:  sudo pure-pw useradd upload -u ftpuser -g ftpgroup -d /home/pi/FTP -m  A password of that virtual user will be required after this command line is entered. And next, set up a virtual user database by typing:  sudo pure-pw mkdb  Last but not least, define an authentication method by making a link of file  /etc/pure-ftpd/conf/PureDB , the number  60  is only for demonstration, make it as small as necessary:  sudo ln -s /etc/pure-ftpd/conf/PureDB /etc/pure-ftpd/auth/60puredb  Restart the program:  sudo service pure-ftpd restart  Test it with an FTP client, like FileZilla.",
            "title": "FTP Home Directory, Virtual User, and User Group"
        },
        {
            "location": "/remote-access/ftp/index.html#more-detailed-configurations",
            "text": "The configuration of Pure-FTPd is simple and intuitive. The administrator only needs to define the necessary settings by making files with option names, like  ChrootEveryone , and typing  yes , then storing in the directory  /etc/pure-ftpd/conf , if all FTP users are to be locked in their FTP home directory ( /home/pi/FTP ). Here are some recommended settings:  sudo nano /etc/pure-ftpd/conf/ChrootEveryone  Type  yes , and press  Ctrl + X ,  Y , and Enter.  Likewise,  Make a file named  NoAnonymous  and type  yes ;  Make a file named  AnonymousCantUpload  and type  yes ;  Make a file named  AnonymousCanCreateDirs  and type  no ;  Make a file named  DisplayDotFiles  and type  no ;  Make a file named  DontResolve  and type  yes ;  Make a file named  ProhibitDotFilesRead  and type  yes ;  Make a file named  ProhibitDotFilesWrite  and type  yes ;  Make a file named  FSCharset  and type UTF-8 ;  ...  Restart  pure-ftpd  again and apply the above settings.  sudo service pure-ftpd restart  For more information of Pure-FTPd and documentation, please get on official website of  Pure-FTPd .",
            "title": "More Detailed Configurations:"
        },
        {
            "location": "/remote-access/ip-address/index.html",
            "text": "IP Address\n\n\nAny device connected to a Local Area Network is assigned an IP address.\n\n\nIn order to connect to your Raspberry Pi from another machine using \nSSH\n or \nVNC\n, you need to know the Pi's IP address. This is easy if you have a display connected, and there are a number of methods for finding it remotely from another machine on the network.\n\n\nUsing the Pi with a display\n\n\nIf you boot to the command line instead of the desktop, your IP address should be shown in the last few messages before the login prompt.\n\n\nUsing the terminal (boot to the command line or open a Terminal window from the desktop), simply type \nhostname -I\n which will reveal your Pi's IP address.\n\n\nUsing the Pi headless (without a display)\n\n\nIt is possible to find the IP address of your Pi without connecting to a screen using one of the following methods:\n\n\nRouter devices list\n\n\nIn a web browser navigate to your router's IP address e.g. \nhttp://192.168.1.1\n, which is usually printed on a label on your router; this will take you to a control panel. Then log in using your credentials, which is usually also printed on the router or sent to you in the accompanying paperwork. Browse to the list of connected devices or similar (all routers are different), and you should see some devices you recognise. Some devices are detected as PCs, tablets, phones, printers, etc. so you should recognise some and rule them out to figure out which is your Raspberry Pi. Also note the connection type; if your Pi is connected with a wire there should be fewer devices to choose from.\n\n\nResolving \nraspberrypi.local\n with mDNS\n\n\nOn Raspbian, \nmulticast DNS\n is supported out-of-the-box by the \nAvahi\n service.\n\n\nIf your device supports mDNS, you can reach your Raspberry Pi by using its hostname and the \n.local\n suffix.\nThe default hostname on a fresh Raspbian install is \nraspberrypi\n, so by default any Raspberry Pi running Raspbian responds to:\n\n\nping raspberrypi.local\n\n\n\n\n\nIf the Raspberry Pi is reachable, \nping\n will show its IP address:\n\n\nPING raspberrypi.local (192.168.1.131): 56 data bytes\n64 bytes from 192.168.1.131: icmp_seq=0 ttl=255 time=2.618 ms\n\n\n\n\n\nIf you change the system hostname of the Raspberry Pi (e.g., by editing \n/etc/hostname\n), Avahi will also change the \n.local\n mDNS address.\n\n\nIf you don't remember the hostname of the Raspberry Pi, but have a system with Avahi installed, you can browse all the hosts and services on the LAN with the \navahi-browse\n command.\n\n\nnmap command\n\n\nThe \nnmap\n command (Network Mapper) is a free and open-source tool for network discovery, available for Linux, macOS, and Windows.\n\n\n\n\n\n\nTo install on \nLinux\n, install the \nnmap\n package e.g. \napt-get install nmap\n.\n\n\n\n\n\n\nTo install on \nmacOS\n or \nWindows\n, see the \nnmap.org download page\n.\n\n\n\n\n\n\nTo use \nnmap\n to scan the devices on your network, you need to know the subnet you are connected to. First find your own IP address, in other words the one of the computer you're using to find your Pi's IP address:\n\n\n\n\nOn \nLinux\n, type \nhostname -I\n into a terminal window\n\n\nOn \nmacOS\n, go to \nSystem Preferences\n then \nNetwork\n and select your active network connection to view the IP address\n\n\nOn \nWindows\n, go to the Control Panel, then under \nNetwork and Sharing Center\n, click \nView network connections\n, select your active network connection and click \nView status of this connection\n to view the IP address\n\n\n\n\nNow you have the IP address of your computer, you will scan the whole subnet for other devices. For example, if your IP address is \n192.168.1.5\n, other devices will be at addresses like \n192.168.1.2\n, \n192.168.1.3\n, \n192.168.1.4\n, etc. The notation of this subnet range is \n192.168.1.0/24\n (this covers \n192.168.1.0\n to \n192.168.1.255\n).\n\n\nNow use the \nnmap\n command with the \n-sn\n flag (ping scan) on the whole subnet range. This may take a few seconds:\n\n\nnmap -sn \n192\n.168.1.0/24\n\n\n\n\n\nPing scan just pings all the IP addresses to see if they respond. For each device that responds to the ping, the output shows the hostname and IP address like so:\n\n\nStarting Nmap 6.40 ( http://nmap.org ) at 2014-03-10 12:46 GMT\nNmap scan report for hpprinter (192.168.1.2)\nHost is up (0.00044s latency).\nNmap scan report for Gordons-MBP (192.168.1.4)\nHost is up (0.0010s latency).\nNmap scan report for ubuntu (192.168.1.5)\nHost is up (0.0010s latency).\nNmap scan report for raspberrypi (192.168.1.8)\nHost is up (0.0030s latency).\nNmap done: 256 IP addresses (4 hosts up) scanned in 2.41 seconds\n\n\n\n\n\nHere you can see a device with hostname \nraspberrypi\n has IP address \n192.168.1.8\n.\n\n\nGetting the IP address of a Pi using your smartphone\n\n\nThe Fing app is a free network scanner for smartphones. It is available for \nAndroid\n and \niOS\n.\n\n\nYour phone and your Raspberry Pi have to be on the same network, so connect your phone to the correct wireless network.\n\n\nWhen you open the Fing app, touch the refresh button in the upper right-hand corner of the screen. After a few seconds you will get a list with all the devices connected to your network. Scroll down to the entry with the manufacturer \"Raspberry Pi\". You will see the IP address in the bottom left-hand corner, and the MAC address in the bottom right-hand corner of the entry.\n\n\nMore tools\n\n\nAlso see \nlsleases",
            "title": "IP Address"
        },
        {
            "location": "/remote-access/ip-address/index.html#ip-address",
            "text": "Any device connected to a Local Area Network is assigned an IP address.  In order to connect to your Raspberry Pi from another machine using  SSH  or  VNC , you need to know the Pi's IP address. This is easy if you have a display connected, and there are a number of methods for finding it remotely from another machine on the network.",
            "title": "IP Address"
        },
        {
            "location": "/remote-access/ip-address/index.html#using-the-pi-with-a-display",
            "text": "If you boot to the command line instead of the desktop, your IP address should be shown in the last few messages before the login prompt.  Using the terminal (boot to the command line or open a Terminal window from the desktop), simply type  hostname -I  which will reveal your Pi's IP address.",
            "title": "Using the Pi with a display"
        },
        {
            "location": "/remote-access/ip-address/index.html#using-the-pi-headless-without-a-display",
            "text": "It is possible to find the IP address of your Pi without connecting to a screen using one of the following methods:",
            "title": "Using the Pi headless (without a display)"
        },
        {
            "location": "/remote-access/ip-address/index.html#router-devices-list",
            "text": "In a web browser navigate to your router's IP address e.g.  http://192.168.1.1 , which is usually printed on a label on your router; this will take you to a control panel. Then log in using your credentials, which is usually also printed on the router or sent to you in the accompanying paperwork. Browse to the list of connected devices or similar (all routers are different), and you should see some devices you recognise. Some devices are detected as PCs, tablets, phones, printers, etc. so you should recognise some and rule them out to figure out which is your Raspberry Pi. Also note the connection type; if your Pi is connected with a wire there should be fewer devices to choose from.",
            "title": "Router devices list"
        },
        {
            "location": "/remote-access/ip-address/index.html#resolving-raspberrypilocal-with-mdns",
            "text": "On Raspbian,  multicast DNS  is supported out-of-the-box by the  Avahi  service.  If your device supports mDNS, you can reach your Raspberry Pi by using its hostname and the  .local  suffix.\nThe default hostname on a fresh Raspbian install is  raspberrypi , so by default any Raspberry Pi running Raspbian responds to:  ping raspberrypi.local  If the Raspberry Pi is reachable,  ping  will show its IP address:  PING raspberrypi.local (192.168.1.131): 56 data bytes\n64 bytes from 192.168.1.131: icmp_seq=0 ttl=255 time=2.618 ms  If you change the system hostname of the Raspberry Pi (e.g., by editing  /etc/hostname ), Avahi will also change the  .local  mDNS address.  If you don't remember the hostname of the Raspberry Pi, but have a system with Avahi installed, you can browse all the hosts and services on the LAN with the  avahi-browse  command.",
            "title": "Resolving raspberrypi.local with mDNS"
        },
        {
            "location": "/remote-access/ip-address/index.html#nmap-command",
            "text": "The  nmap  command (Network Mapper) is a free and open-source tool for network discovery, available for Linux, macOS, and Windows.    To install on  Linux , install the  nmap  package e.g.  apt-get install nmap .    To install on  macOS  or  Windows , see the  nmap.org download page .    To use  nmap  to scan the devices on your network, you need to know the subnet you are connected to. First find your own IP address, in other words the one of the computer you're using to find your Pi's IP address:   On  Linux , type  hostname -I  into a terminal window  On  macOS , go to  System Preferences  then  Network  and select your active network connection to view the IP address  On  Windows , go to the Control Panel, then under  Network and Sharing Center , click  View network connections , select your active network connection and click  View status of this connection  to view the IP address   Now you have the IP address of your computer, you will scan the whole subnet for other devices. For example, if your IP address is  192.168.1.5 , other devices will be at addresses like  192.168.1.2 ,  192.168.1.3 ,  192.168.1.4 , etc. The notation of this subnet range is  192.168.1.0/24  (this covers  192.168.1.0  to  192.168.1.255 ).  Now use the  nmap  command with the  -sn  flag (ping scan) on the whole subnet range. This may take a few seconds:  nmap -sn  192 .168.1.0/24  Ping scan just pings all the IP addresses to see if they respond. For each device that responds to the ping, the output shows the hostname and IP address like so:  Starting Nmap 6.40 ( http://nmap.org ) at 2014-03-10 12:46 GMT\nNmap scan report for hpprinter (192.168.1.2)\nHost is up (0.00044s latency).\nNmap scan report for Gordons-MBP (192.168.1.4)\nHost is up (0.0010s latency).\nNmap scan report for ubuntu (192.168.1.5)\nHost is up (0.0010s latency).\nNmap scan report for raspberrypi (192.168.1.8)\nHost is up (0.0030s latency).\nNmap done: 256 IP addresses (4 hosts up) scanned in 2.41 seconds  Here you can see a device with hostname  raspberrypi  has IP address  192.168.1.8 .",
            "title": "nmap command"
        },
        {
            "location": "/remote-access/ip-address/index.html#getting-the-ip-address-of-a-pi-using-your-smartphone",
            "text": "The Fing app is a free network scanner for smartphones. It is available for  Android  and  iOS .  Your phone and your Raspberry Pi have to be on the same network, so connect your phone to the correct wireless network.  When you open the Fing app, touch the refresh button in the upper right-hand corner of the screen. After a few seconds you will get a list with all the devices connected to your network. Scroll down to the entry with the manufacturer \"Raspberry Pi\". You will see the IP address in the bottom left-hand corner, and the MAC address in the bottom right-hand corner of the entry.",
            "title": "Getting the IP address of a Pi using your smartphone"
        },
        {
            "location": "/remote-access/ip-address/index.html#more-tools",
            "text": "Also see  lsleases",
            "title": "More tools"
        },
        {
            "location": "/remote-access/access-over-Internet/README/index.html",
            "text": "Access your Raspberry Pi over the internet\n\n\nYou can connect to your Raspberry Pi over the internet from another computer or a mobile device. There are a number of ways to do this, which we cover below.\n\n\nPort forwarding\n\n\nOne method is to set up port forwarding on your router. To do this, you must change the configuration of your router to forward all inbound traffic from the internet on a specific port to the local IP address of your Raspberry Pi. Most routers have this feature available. However, every router is different so you will need to consult your router's user manual for instructions. The settings can be tricky if your Pi is behind a firewall or if there is more than one router. One disadvantage of port forwarding is that it exposes a network port on your private LAN to the public internet. This is a known security vulnerability and must be managed carefully.\n\n\nAlternatives\n\n\nRather than using port forwarding, there are a number of alternative online services available. These provide varying levels of functionality - see their websites for more details.\n\n\n\n\nremot3.it\n, by Weaved Inc\n\n\nDataplicity\n\n\nYaler.net\n\n\nLosant\n\n\nRemote IoT",
            "title": "Access your Raspberry Pi over the internet"
        },
        {
            "location": "/remote-access/access-over-Internet/README/index.html#access-your-raspberry-pi-over-the-internet",
            "text": "You can connect to your Raspberry Pi over the internet from another computer or a mobile device. There are a number of ways to do this, which we cover below.",
            "title": "Access your Raspberry Pi over the internet"
        },
        {
            "location": "/remote-access/access-over-Internet/README/index.html#port-forwarding",
            "text": "One method is to set up port forwarding on your router. To do this, you must change the configuration of your router to forward all inbound traffic from the internet on a specific port to the local IP address of your Raspberry Pi. Most routers have this feature available. However, every router is different so you will need to consult your router's user manual for instructions. The settings can be tricky if your Pi is behind a firewall or if there is more than one router. One disadvantage of port forwarding is that it exposes a network port on your private LAN to the public internet. This is a known security vulnerability and must be managed carefully.",
            "title": "Port forwarding"
        },
        {
            "location": "/remote-access/access-over-Internet/README/index.html#alternatives",
            "text": "Rather than using port forwarding, there are a number of alternative online services available. These provide varying levels of functionality - see their websites for more details.   remot3.it , by Weaved Inc  Dataplicity  Yaler.net  Losant  Remote IoT",
            "title": "Alternatives"
        },
        {
            "location": "/remote-access/ssh/README/index.html",
            "text": "SSH (Secure Shell)\n\n\nYou can access the command line of a Raspberry Pi remotely from another computer or device on the same network using SSH.\n\n\nThe Raspberry Pi will act as a remote device: you can connect to it using a client on another machine. \n\n\nYou only have access to the command line, not the full desktop environment. For a full remote desktop, see \nVNC\n.\n\n\n1. Set up your local network and wireless connectivity\n\n\nMake sure your Raspberry Pi is properly set up and connected. If you are using wireless networking, this can be enabled via Pixel's \nuser interface\n, or using the \ncommand line\n. \n\n\nIf you are not using wireless connectivity, plug your Raspberry Pi directly into the router.\n\n\nYou will need to note down the IP address of your Pi in order to connect to it later. Using the \nifconfig\n command will display information about the current network status, including the IP address, or you can use \nhostname -I\n to display the IP addresses associated with the device.\n\n\n2. Enable SSH\n\n\nAs of the November 2016 release, Raspbian has the SSH server disabled by default. It can be enabled manually from the desktop:\n\n\n\n\nLaunch \nRaspberry Pi Configuration\n from the \nPreferences\n menu\n\n\nNavigate to the \nInterfaces\n tab\n\n\nSelect \nEnabled\n next to \nSSH\n\n\nClick \nOK\n\n\n\n\nAlternatively, \nraspi-config\n can be used in the terminal:\n\n\n\n\nEnter \nsudo raspi-config\n in a terminal window\n\n\nSelect \nInterfacing Options\n\n\nNavigate to and select \nSSH\n\n\nChoose \nYes\n \n\n\nSelect \nOk\n\n\nChoose \nFinish\n\n\n\n\nAlternatively, use \nsystemctl\n to start the service\n\n\nsudo systemctl enable ssh\nsudo systemctl start ssh\n\n\n\n\n\n3. Enable SSH on a headless Raspberry Pi (add file to SD card on another machine)\n\n\nFor headless setup, SSH can be enabled by placing a file named \nssh\n, without any extension, onto the boot partition of the SD card from another computer. When the Pi boots, it looks for the \nssh\n file. If it is found, SSH is enabled and the file is deleted. The content of the file does not matter; it could contain text, or nothing at all.\n\n\nIf you have loaded Raspbian onto a blank SD card, you will have two partitions. The first one, which is the smaller one, is the boot partition. Place the file into this one.\n\n\n4. Set up your client\n\n\nSSH is built into Linux distributions and Mac OS. For Windows and mobile devices, third-party SSH clients are available. See the following guides for using SSH with the OS on your computer or device:\n\n\n\n\nLinux & Mac OS\n\n\nWindows\n\n\niOS\n\n\nAndroid",
            "title": "SSH (Secure Shell)"
        },
        {
            "location": "/remote-access/ssh/README/index.html#ssh-secure-shell",
            "text": "You can access the command line of a Raspberry Pi remotely from another computer or device on the same network using SSH.  The Raspberry Pi will act as a remote device: you can connect to it using a client on another machine.   You only have access to the command line, not the full desktop environment. For a full remote desktop, see  VNC .",
            "title": "SSH (Secure Shell)"
        },
        {
            "location": "/remote-access/ssh/README/index.html#1-set-up-your-local-network-and-wireless-connectivity",
            "text": "Make sure your Raspberry Pi is properly set up and connected. If you are using wireless networking, this can be enabled via Pixel's  user interface , or using the  command line .   If you are not using wireless connectivity, plug your Raspberry Pi directly into the router.  You will need to note down the IP address of your Pi in order to connect to it later. Using the  ifconfig  command will display information about the current network status, including the IP address, or you can use  hostname -I  to display the IP addresses associated with the device.",
            "title": "1. Set up your local network and wireless connectivity"
        },
        {
            "location": "/remote-access/ssh/README/index.html#2-enable-ssh",
            "text": "As of the November 2016 release, Raspbian has the SSH server disabled by default. It can be enabled manually from the desktop:   Launch  Raspberry Pi Configuration  from the  Preferences  menu  Navigate to the  Interfaces  tab  Select  Enabled  next to  SSH  Click  OK   Alternatively,  raspi-config  can be used in the terminal:   Enter  sudo raspi-config  in a terminal window  Select  Interfacing Options  Navigate to and select  SSH  Choose  Yes    Select  Ok  Choose  Finish   Alternatively, use  systemctl  to start the service  sudo systemctl enable ssh\nsudo systemctl start ssh",
            "title": "2. Enable SSH"
        },
        {
            "location": "/remote-access/ssh/README/index.html#3-enable-ssh-on-a-headless-raspberry-pi-add-file-to-sd-card-on-another-machine",
            "text": "For headless setup, SSH can be enabled by placing a file named  ssh , without any extension, onto the boot partition of the SD card from another computer. When the Pi boots, it looks for the  ssh  file. If it is found, SSH is enabled and the file is deleted. The content of the file does not matter; it could contain text, or nothing at all.  If you have loaded Raspbian onto a blank SD card, you will have two partitions. The first one, which is the smaller one, is the boot partition. Place the file into this one.",
            "title": "3. Enable SSH on a headless Raspberry Pi (add file to SD card on another machine)"
        },
        {
            "location": "/remote-access/ssh/README/index.html#4-set-up-your-client",
            "text": "SSH is built into Linux distributions and Mac OS. For Windows and mobile devices, third-party SSH clients are available. See the following guides for using SSH with the OS on your computer or device:   Linux & Mac OS  Windows  iOS  Android",
            "title": "4. Set up your client"
        },
        {
            "location": "/remote-access/ssh/android/index.html",
            "text": "SSH using Android\n\n\nTo use SSH on your mobile device you need to download a client. There are several different good quality clients available, such as \nTermius\n, \nJuiceSSH\n, and \nConnectbot\n. For this tutorial we will use Termius, because it is a popular cross-platform SSH client. The process will be similar for other clients. \n\n\n1. Add your Raspberry Pi as a host\n\n\nDownload Termius from \nGoogle Play\n, if you haven't installed it already. Click to open the app.\n\n\nThe app should open showing \u2018No Hosts\u2019. To get started, you should tap the blue \n+\n button in the lower left corner. Then tap \u2018New Host\u2019. \n\n\n\n\nEnter an \nalias\n, such as Raspberry Pi. Then enter the IP address under \nhostname\n. Fill in the \nusername\n and \npassword\n and hit the tick \n\u2713\n in the top right corner. \n\n\nIf you do not know the IP address, type \nhostname -I\n in the command line on the Raspberry Pi. See \nhere\n for more ways to find your IP address. The default login for Raspbian is \npi\n with the password \nraspberry\n.\n\n\n2. Connect\n\n\nWhen you have saved the new host, you will be sent back to the \u2018Hosts\u2019 screen. There, you will find the new entry. Make sure your mobile device has wireless connectivity turned on, and that it is connected to the same network as your Raspberry Pi.\n\n\nTap the new entry once. When the connection works, you will see a \nsecurity warning\n. Don\u2019t worry: everything is fine. Click \u2018Connect\u2019. You will only see this warning the first time Termius connects to a Pi that it hasn\u2019t seen before.\n\n\n\n\nYou should now see the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.\n\n\npi@raspberrypi ~ $\n\n\n\n\n\nYou can type \nexit\n to close the terminal window.\n\n\n\n\nIf a dialogue saying \nConnection failed Connecting to 192.xxx.xxx.xxx port 22\n appears, it is likely that you have entered an incorrect IP address. If the IP address is correct, wireless connectivity on your mobile device might be turned off; the Raspberry Pi might be turned off; or the Raspberry Pi and your mobile device may be connected to different networks.\n\n\n3. Modify an entry, troubleshooting, and more\n\n\nA connection might be unsuccessful for various reasons. The most likely reasons are that your device or Raspberry Pi are \nnot connected properly\n; \nSSH is disabled\n; there is a typo in your code, or the IP address or credentials have changed. In the latter cases, you will need to update the host.\n\n\nTo do this, go to the Hosts screen, and tap and hold the relevant entry. In the top right corner, new functions will pop up. Tap the pencil icon. A new screen titled 'Edit Host' will appear.",
            "title": "SSH using Android"
        },
        {
            "location": "/remote-access/ssh/android/index.html#ssh-using-android",
            "text": "To use SSH on your mobile device you need to download a client. There are several different good quality clients available, such as  Termius ,  JuiceSSH , and  Connectbot . For this tutorial we will use Termius, because it is a popular cross-platform SSH client. The process will be similar for other clients.",
            "title": "SSH using Android"
        },
        {
            "location": "/remote-access/ssh/android/index.html#1-add-your-raspberry-pi-as-a-host",
            "text": "Download Termius from  Google Play , if you haven't installed it already. Click to open the app.  The app should open showing \u2018No Hosts\u2019. To get started, you should tap the blue  +  button in the lower left corner. Then tap \u2018New Host\u2019.    Enter an  alias , such as Raspberry Pi. Then enter the IP address under  hostname . Fill in the  username  and  password  and hit the tick  \u2713  in the top right corner.   If you do not know the IP address, type  hostname -I  in the command line on the Raspberry Pi. See  here  for more ways to find your IP address. The default login for Raspbian is  pi  with the password  raspberry .",
            "title": "1. Add your Raspberry Pi as a host"
        },
        {
            "location": "/remote-access/ssh/android/index.html#2-connect",
            "text": "When you have saved the new host, you will be sent back to the \u2018Hosts\u2019 screen. There, you will find the new entry. Make sure your mobile device has wireless connectivity turned on, and that it is connected to the same network as your Raspberry Pi.  Tap the new entry once. When the connection works, you will see a  security warning . Don\u2019t worry: everything is fine. Click \u2018Connect\u2019. You will only see this warning the first time Termius connects to a Pi that it hasn\u2019t seen before.   You should now see the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.  pi@raspberrypi ~ $  You can type  exit  to close the terminal window.   If a dialogue saying  Connection failed Connecting to 192.xxx.xxx.xxx port 22  appears, it is likely that you have entered an incorrect IP address. If the IP address is correct, wireless connectivity on your mobile device might be turned off; the Raspberry Pi might be turned off; or the Raspberry Pi and your mobile device may be connected to different networks.",
            "title": "2. Connect"
        },
        {
            "location": "/remote-access/ssh/android/index.html#3-modify-an-entry-troubleshooting-and-more",
            "text": "A connection might be unsuccessful for various reasons. The most likely reasons are that your device or Raspberry Pi are  not connected properly ;  SSH is disabled ; there is a typo in your code, or the IP address or credentials have changed. In the latter cases, you will need to update the host.  To do this, go to the Hosts screen, and tap and hold the relevant entry. In the top right corner, new functions will pop up. Tap the pencil icon. A new screen titled 'Edit Host' will appear.",
            "title": "3. Modify an entry, troubleshooting, and more"
        },
        {
            "location": "/remote-access/ssh/ios/index.html",
            "text": "SSH USING iOS\n\n\nTo use SSH on your mobile device you need to download a client. There are several good quality clients available, such as \nTermius\n, \nPrompt 2\n, and  \nCathode\n. \n\n\nFor this tutorial we will use Termius, because it is a popular cross-platform SSH client. The process will be similar for other clients. \n\n\n1. Add your Raspberry Pi as a host.\n\n\nDownload Termius from \niTunes\n, if you haven\u2019t installed it yet. Click to open the app.\n\n\nA prompt asking you to allow notifications will pop up. You should click \u2018Allow\u2019 (recommended). Now follow the instruction on the screen: \nStart by adding a new host\n. Tap \nNew Host\n and a new window will pop up.\n\n\n\n\nEnter an \nalias\n, such as \u2018Raspberry Pi\u2019. Then enter the IP address under \nhostname\n. Complete the \nusername\n and \npassword\n fields and hit \u2018save\u2019 in the top right corner. \n\n\nIf you do not know the IP address, type \nhostname -I\n in the command line on the Raspberry Pi. See \nhere\n for more ways to find your IP address. The default login for Raspbian is \npi\n with the password \nraspberry\n.\n\n\n2. Connect\n\n\nWhen you have saved the new host, you will be sent back to the \u2018Hosts\u2019 screen. There you will find the new entry. Make sure your mobile device has wireless connectivity turned on, and is connected to the same network as your Raspberry Pi.\n\n\nTap the new entry once. When the connection works, you will see a \nsecurity warning\n. Don\u2019t worry, everything is fine! Click \u2018Continue\u2019. You will only see this warning the first time Termius connects to a Raspberry Pi that it hasn\u2019t seen before.\n\n\n\n\nYou should now have the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.\n\n\npi@raspberrypi ~ $\n\n\n\n\n\nYou can type \nexit\n to close the terminal window.\n\n\n\n\nIf a red exclamation mark appears, this indicates that something has gone wrong. Tap the exclamation mark to see the error description. \u2018Connection establishment time out\u2019 indicates that you have probably entered an incorrect IP address. If the IP address is correct, wireless connectivity on your mobile device might be turned off; the Raspberry Pi might be turned off; or the Raspberry Pi and your mobile device might be connected to different networks.\n\n\n3. Modify an entry, troubleshooting, and more\n\n\nA connection might be unsuccessful for various reasons. It is likely that your device or Raspberry Pi is \nnot connected properly\n; \nSSH is disabled\n; there is a typo in your code; or the IP address or credentials have changed. In the latter cases, you will need to update the host.\n\n\nTo do so, go to the \u2018Hosts\u2019 screen, swipe left on the host you need to edit, and new functions will appear. Tap edit. A new screen titled \u2018Edit Host\u2019 will pop up.",
            "title": "Ios"
        },
        {
            "location": "/remote-access/ssh/ios/index.html#ssh-using-ios",
            "text": "To use SSH on your mobile device you need to download a client. There are several good quality clients available, such as  Termius ,  Prompt 2 , and   Cathode .   For this tutorial we will use Termius, because it is a popular cross-platform SSH client. The process will be similar for other clients.",
            "title": "SSH USING iOS"
        },
        {
            "location": "/remote-access/ssh/ios/index.html#1-add-your-raspberry-pi-as-a-host",
            "text": "Download Termius from  iTunes , if you haven\u2019t installed it yet. Click to open the app.  A prompt asking you to allow notifications will pop up. You should click \u2018Allow\u2019 (recommended). Now follow the instruction on the screen:  Start by adding a new host . Tap  New Host  and a new window will pop up.   Enter an  alias , such as \u2018Raspberry Pi\u2019. Then enter the IP address under  hostname . Complete the  username  and  password  fields and hit \u2018save\u2019 in the top right corner.   If you do not know the IP address, type  hostname -I  in the command line on the Raspberry Pi. See  here  for more ways to find your IP address. The default login for Raspbian is  pi  with the password  raspberry .",
            "title": "1. Add your Raspberry Pi as a host."
        },
        {
            "location": "/remote-access/ssh/ios/index.html#2-connect",
            "text": "When you have saved the new host, you will be sent back to the \u2018Hosts\u2019 screen. There you will find the new entry. Make sure your mobile device has wireless connectivity turned on, and is connected to the same network as your Raspberry Pi.  Tap the new entry once. When the connection works, you will see a  security warning . Don\u2019t worry, everything is fine! Click \u2018Continue\u2019. You will only see this warning the first time Termius connects to a Raspberry Pi that it hasn\u2019t seen before.   You should now have the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.  pi@raspberrypi ~ $  You can type  exit  to close the terminal window.   If a red exclamation mark appears, this indicates that something has gone wrong. Tap the exclamation mark to see the error description. \u2018Connection establishment time out\u2019 indicates that you have probably entered an incorrect IP address. If the IP address is correct, wireless connectivity on your mobile device might be turned off; the Raspberry Pi might be turned off; or the Raspberry Pi and your mobile device might be connected to different networks.",
            "title": "2. Connect"
        },
        {
            "location": "/remote-access/ssh/ios/index.html#3-modify-an-entry-troubleshooting-and-more",
            "text": "A connection might be unsuccessful for various reasons. It is likely that your device or Raspberry Pi is  not connected properly ;  SSH is disabled ; there is a typo in your code; or the IP address or credentials have changed. In the latter cases, you will need to update the host.  To do so, go to the \u2018Hosts\u2019 screen, swipe left on the host you need to edit, and new functions will appear. Tap edit. A new screen titled \u2018Edit Host\u2019 will pop up.",
            "title": "3. Modify an entry, troubleshooting, and more"
        },
        {
            "location": "/remote-access/ssh/passwordless/index.html",
            "text": "Passwordless SSH access\n\n\nIt is possible to configure your Pi to allow your computer to access it without providing a password each time you try to connect. To do this you need to generate an SSH key:\n\n\nCheck for existing SSH keys\n\n\nFirst, check whether there are already keys on the computer you are using to connect to the Raspberry Pi:\n\n\nls ~/.ssh\n\n\n\n\n\nIf you see files named \nid_rsa.pub\n or \nid_dsa.pub\n you have keys set up already, so you can skip the generating keys step (or delete these files with \nrm id*\n and make new keys).\n\n\nGenerate new SSH keys\n\n\nTo generate new SSH keys enter the following command (Choose a sensible hostname such as \n<YOURNAME>@<YOURDEVICE>\n where we have used \neben@pi\n):\n\n\nssh-keygen -t rsa -C eben@pi\n\n\n\n\n\nYou can also use a more descriptive comment using quotes if you have spaces, e.g. \nssh-keygen -t rsa -C \"Raspberry Pi #123\"\n\n\nUpon entering this command, you'll be asked where to save the key. We suggest you save it in the default location (\n/home/pi/.ssh/id_rsa\n) by just hitting \nEnter\n.\n\n\nYou'll also be asked to enter a passphrase. This is extra security which will make the key unusable without your passphrase, so if someone else copied your key, they could not impersonate you to gain access. If you choose to use a passphrase, type it here and press \nEnter\n, then type it again when prompted. Leave the field empty for no passphrase.\n\n\nNow you should see the files \nid_rsa\n and \nid_rsa.pub\n in your \n.ssh\n directory in your home folder:\n\n\nls ~/.ssh\n\n\n\n\n\nauthorized_keys  id_rsa  id_rsa.pub  known_hosts\n\n\n\n\n\nThe \nid_rsa\n file is your private key. Keep this on your computer.\n\n\nThe \nid_rsa.pub\n file is your public key. This is what you put on machines you want to connect to. When the machine you try to connect to matches up your public and private key, it will allow you to connect.\n\n\nTake a look at your public key to see what it looks like:\n\n\ncat ~/.ssh/id_rsa.pub\n\n\n\n\n\nIt should be in the form:\n\n\nssh-rsa <REALLY LONG STRING OF RANDOM CHARACTERS> eben@pi\n\n\n\n\n\nCopy your public key to your Raspberry Pi\n\n\nIf your Pi does not have an .ssh directory you will need to set one up so that you can copy the key from your computer.\n\n\ncd ~\ninstall -d -m 700 ~/.ssh\n\n\n\n\n\nTo copy your public key to your Raspberry Pi, use the following command to append the public key to your \nauthorized_keys\n file on the Pi, sending it over SSH:\n\n\ncat ~/.ssh/id_rsa.pub | ssh <USERNAME>@<IP-ADDRESS> 'cat >> .ssh/authorized_keys'\n\n\n\n\n\nNote that this time you will have to authenticate with your password.\n\n\nNow try \nssh <USER>@<IP-ADDRESS>\n and you should connect without a password prompt.\n\n\nIf you see a message \"Agent admitted failure to sign using the key\" then add your RSA or DSA identities to the authentication agent \nssh-agent\n then execute the following command:  \n\n\nssh-add\n\n\n\n\n\nIf this did not work, delete your keys with \nrm ~/.ssh/id*\n and follow the instructions again.\n\n\nYou can also send files over SSH using the \nscp\n command (secure copy). See the \nSCP guide\n for more information.",
            "title": "Passwordless SSH access"
        },
        {
            "location": "/remote-access/ssh/passwordless/index.html#passwordless-ssh-access",
            "text": "It is possible to configure your Pi to allow your computer to access it without providing a password each time you try to connect. To do this you need to generate an SSH key:",
            "title": "Passwordless SSH access"
        },
        {
            "location": "/remote-access/ssh/passwordless/index.html#check-for-existing-ssh-keys",
            "text": "First, check whether there are already keys on the computer you are using to connect to the Raspberry Pi:  ls ~/.ssh  If you see files named  id_rsa.pub  or  id_dsa.pub  you have keys set up already, so you can skip the generating keys step (or delete these files with  rm id*  and make new keys).",
            "title": "Check for existing SSH keys"
        },
        {
            "location": "/remote-access/ssh/passwordless/index.html#generate-new-ssh-keys",
            "text": "To generate new SSH keys enter the following command (Choose a sensible hostname such as  <YOURNAME>@<YOURDEVICE>  where we have used  eben@pi ):  ssh-keygen -t rsa -C eben@pi  You can also use a more descriptive comment using quotes if you have spaces, e.g.  ssh-keygen -t rsa -C \"Raspberry Pi #123\"  Upon entering this command, you'll be asked where to save the key. We suggest you save it in the default location ( /home/pi/.ssh/id_rsa ) by just hitting  Enter .  You'll also be asked to enter a passphrase. This is extra security which will make the key unusable without your passphrase, so if someone else copied your key, they could not impersonate you to gain access. If you choose to use a passphrase, type it here and press  Enter , then type it again when prompted. Leave the field empty for no passphrase.  Now you should see the files  id_rsa  and  id_rsa.pub  in your  .ssh  directory in your home folder:  ls ~/.ssh  authorized_keys  id_rsa  id_rsa.pub  known_hosts  The  id_rsa  file is your private key. Keep this on your computer.  The  id_rsa.pub  file is your public key. This is what you put on machines you want to connect to. When the machine you try to connect to matches up your public and private key, it will allow you to connect.  Take a look at your public key to see what it looks like:  cat ~/.ssh/id_rsa.pub  It should be in the form:  ssh-rsa <REALLY LONG STRING OF RANDOM CHARACTERS> eben@pi",
            "title": "Generate new SSH keys"
        },
        {
            "location": "/remote-access/ssh/passwordless/index.html#copy-your-public-key-to-your-raspberry-pi",
            "text": "If your Pi does not have an .ssh directory you will need to set one up so that you can copy the key from your computer.  cd ~\ninstall -d -m 700 ~/.ssh  To copy your public key to your Raspberry Pi, use the following command to append the public key to your  authorized_keys  file on the Pi, sending it over SSH:  cat ~/.ssh/id_rsa.pub | ssh <USERNAME>@<IP-ADDRESS> 'cat >> .ssh/authorized_keys'  Note that this time you will have to authenticate with your password.  Now try  ssh <USER>@<IP-ADDRESS>  and you should connect without a password prompt.  If you see a message \"Agent admitted failure to sign using the key\" then add your RSA or DSA identities to the authentication agent  ssh-agent  then execute the following command:    ssh-add  If this did not work, delete your keys with  rm ~/.ssh/id*  and follow the instructions again.  You can also send files over SSH using the  scp  command (secure copy). See the  SCP guide  for more information.",
            "title": "Copy your public key to your Raspberry Pi"
        },
        {
            "location": "/remote-access/ssh/rsync/index.html",
            "text": "rsync\n\n\nYou can use the tool \nrsync\n to synchronise folders between computers. You might want to transfer some files from your desktop computer or laptop to your Pi, for example, and for them to be kept up to date, or you might want the pictures taken by your Pi transferred to your computer automatically.\n\n\nUsing \nrsync\n over SSH allows you to transfer files to your computer automatically.\n\n\nHere is an example of how to set up the sync of a folder of pictures on your Pi to your computer:\n\n\nOn your computer, create a folder called \ncamera\n:\n\n\nmkdir camera\n\n\n\n\n\nLook up the Pi's IP address by logging in to it and running \nhostname -I\n. In this example, the Pi is creating a timelapse by capturing a photo every minute, and saving the picture with a timestamp in the local folder \ncamera\n on its SD card.\n\n\nNow run the following command (substituting your own Pi's IP address):\n\n\nrsync\n \n-\navz\n \n-\ne\n \nssh\n \npi\n@192.168.1.10\n:\ncamera\n/\n \ncamera\n/\n\n\n\n\n\n\nThis will copy all files from the Pi's \ncamera\n folder to your computer's new \ncamera\n folder.\n\n\nIn order to keep the folders in sync, run this command in \ncron\n.",
            "title": "rsync"
        },
        {
            "location": "/remote-access/ssh/rsync/index.html#rsync",
            "text": "You can use the tool  rsync  to synchronise folders between computers. You might want to transfer some files from your desktop computer or laptop to your Pi, for example, and for them to be kept up to date, or you might want the pictures taken by your Pi transferred to your computer automatically.  Using  rsync  over SSH allows you to transfer files to your computer automatically.  Here is an example of how to set up the sync of a folder of pictures on your Pi to your computer:  On your computer, create a folder called  camera :  mkdir camera  Look up the Pi's IP address by logging in to it and running  hostname -I . In this example, the Pi is creating a timelapse by capturing a photo every minute, and saving the picture with a timestamp in the local folder  camera  on its SD card.  Now run the following command (substituting your own Pi's IP address):  rsync   - avz   - e   ssh   pi @192.168.1.10 : camera /   camera /   This will copy all files from the Pi's  camera  folder to your computer's new  camera  folder.  In order to keep the folders in sync, run this command in  cron .",
            "title": "rsync"
        },
        {
            "location": "/remote-access/ssh/scp/index.html",
            "text": "SCP (Secure Copy)\n\n\nscp\n is a command for sending files over SSH. This means you can copy files between computers, say from your Raspberry Pi to your desktop or laptop, or vice-versa.\n\n\nFirst of all, you'll need to know your Raspberry Pi's \nIP address\n.\n\n\nCopying files to your Raspberry Pi\n\n\nCopy the file \nmyfile.txt\n from your computer to the \npi\n user's home folder of your Raspberry Pi at the IP address \n192.168.1.3\n with the following command:\n\n\nscp myfile.txt pi@192.168.1.3:\n\n\n\n\n\nCopy the file to the \n/home/pi/project/\n directory on your Raspberry Pi (the \nproject\n folder must already exist):\n\n\nscp myfile.txt pi@192.168.1.3:project/\n\n\n\n\n\nCopying files from your Raspberry Pi\n\n\nCopy the file \nmyfile.txt\n from your Raspberry Pi to the current directory on your other computer:\n\n\nscp pi@192.168.1.3:myfile.txt .\n\n\n\n\n\nCopying multiple files\n\n\nCopy multiple files by separating them with spaces:\n\n\nscp myfile.txt myfile2.txt pi@192.168.1.3:\n\n\n\n\n\nAlternatively, use a wildcard to copy all files matching a particular search with:\n\n\nscp *.txt pi@192.168.1.3:\n\n\n\n\n\n(all files ending in \n.txt\n)\n\n\nscp m* pi@192.168.1.3:\n\n\n\n\n\n(all files starting with \nm\n)\n\n\nscp m*.txt pi@192.168.1.3:\n\n\n\n\n\n(all files starting with \nm\n and ending in \n.txt\n)\n\n\nFilenames with spaces\n\n\nNote that some of the examples above will not work for file names containing spaces. Names like this need to be encased in quotes:\n\n\nscp \n\"my file.txt\"\n pi@192.168.1.3:",
            "title": "SCP (Secure Copy)"
        },
        {
            "location": "/remote-access/ssh/scp/index.html#scp-secure-copy",
            "text": "scp  is a command for sending files over SSH. This means you can copy files between computers, say from your Raspberry Pi to your desktop or laptop, or vice-versa.  First of all, you'll need to know your Raspberry Pi's  IP address .",
            "title": "SCP (Secure Copy)"
        },
        {
            "location": "/remote-access/ssh/scp/index.html#copying-files-to-your-raspberry-pi",
            "text": "Copy the file  myfile.txt  from your computer to the  pi  user's home folder of your Raspberry Pi at the IP address  192.168.1.3  with the following command:  scp myfile.txt pi@192.168.1.3:  Copy the file to the  /home/pi/project/  directory on your Raspberry Pi (the  project  folder must already exist):  scp myfile.txt pi@192.168.1.3:project/",
            "title": "Copying files to your Raspberry Pi"
        },
        {
            "location": "/remote-access/ssh/scp/index.html#copying-files-from-your-raspberry-pi",
            "text": "Copy the file  myfile.txt  from your Raspberry Pi to the current directory on your other computer:  scp pi@192.168.1.3:myfile.txt .",
            "title": "Copying files from your Raspberry Pi"
        },
        {
            "location": "/remote-access/ssh/scp/index.html#copying-multiple-files",
            "text": "Copy multiple files by separating them with spaces:  scp myfile.txt myfile2.txt pi@192.168.1.3:  Alternatively, use a wildcard to copy all files matching a particular search with:  scp *.txt pi@192.168.1.3:  (all files ending in  .txt )  scp m* pi@192.168.1.3:  (all files starting with  m )  scp m*.txt pi@192.168.1.3:  (all files starting with  m  and ending in  .txt )",
            "title": "Copying multiple files"
        },
        {
            "location": "/remote-access/ssh/scp/index.html#filenames-with-spaces",
            "text": "Note that some of the examples above will not work for file names containing spaces. Names like this need to be encased in quotes:  scp  \"my file.txt\"  pi@192.168.1.3:",
            "title": "Filenames with spaces"
        },
        {
            "location": "/remote-access/ssh/sftp/index.html",
            "text": "SFTP\n\n\nThe SSH File Transfer Protocol is a network protocol that provides file access, file transfer, and file management functionalities over SSH.\n\n\nBy using SFTP you can easily change, browse and edit files on your Raspberry Pi. SFTP is easier to setup than \nFTP\n as Raspbian has SSH enabled by default.\n\n\nFileZilla\n\n\nDownload the latest FileZilla Client version for your operating system from \nfilezilla-project.org\n.\n\n\nLaunch FileZilla and go to \nFile > Site manager\n.\n\n\nFill in the \nIP address\n, user name and password (by default the user name is \npi\n and the password \nraspberry\n) of your Raspberry Pi in the dialog and choose \nSFTP\n as the protocol.\n\n\nClick \nConnect\n and you will see the home folder of the user.\n\n\nUbuntu using Nautilus\n\n\nOpen Nautilus on the client machine\n\n\nSelect \nFile > Connect to Server\n\n\nType\n:\n \nSSH\n\n\nServer\n:\n \n<\nThe\n \nPi\n'\ns\n \nIP\n \naddress\n>\n\n\nPort\n:\n \n22\n \n(\ndefault\n)\n\n\nUser\n \nname\n:\n \npi\n \n(\ndefault\n)\n\n\nPassword\n:\n \nraspberry\n \n(\ndefault\n)\n\n\n\n\n\n\nChrome OS file manager (tested on Acer Chromebook)\n\n\nOpen the Chromebook's file manager app.\n\n\nScroll to the bottom of the file tree in the left panel.\n\n\nClick \nAdd new services\n\n\nSelect and click\nSFTP file system\n\n\n\n\n\nIn the dialog box that opens, enter:\n\n\nThe IP address or\nThe hostname (default is `raspberrypi`)\nEnter port 22 (Not the one shown next to the IP address on your pi)\nAdd user `pi` and the password (default is `raspberry`)\n\n\n\n\n\nYou may encounter another dialog box for security; if you do, click \nAllow\n or \nAccept\n.",
            "title": "SFTP"
        },
        {
            "location": "/remote-access/ssh/sftp/index.html#sftp",
            "text": "The SSH File Transfer Protocol is a network protocol that provides file access, file transfer, and file management functionalities over SSH.  By using SFTP you can easily change, browse and edit files on your Raspberry Pi. SFTP is easier to setup than  FTP  as Raspbian has SSH enabled by default.",
            "title": "SFTP"
        },
        {
            "location": "/remote-access/ssh/sftp/index.html#filezilla",
            "text": "Download the latest FileZilla Client version for your operating system from  filezilla-project.org .  Launch FileZilla and go to  File > Site manager .  Fill in the  IP address , user name and password (by default the user name is  pi  and the password  raspberry ) of your Raspberry Pi in the dialog and choose  SFTP  as the protocol.  Click  Connect  and you will see the home folder of the user.",
            "title": "FileZilla"
        },
        {
            "location": "/remote-access/ssh/sftp/index.html#ubuntu-using-nautilus",
            "text": "Open Nautilus on the client machine  Select  File > Connect to Server  Type :   SSH  Server :   < The   Pi ' s   IP   address >  Port :   22   ( default )  User   name :   pi   ( default )  Password :   raspberry   ( default )",
            "title": "Ubuntu using Nautilus"
        },
        {
            "location": "/remote-access/ssh/sftp/index.html#chrome-os-file-manager-tested-on-acer-chromebook",
            "text": "Open the Chromebook's file manager app.  Scroll to the bottom of the file tree in the left panel.  Click  Add new services  Select and click\nSFTP file system  In the dialog box that opens, enter:  The IP address or\nThe hostname (default is `raspberrypi`)\nEnter port 22 (Not the one shown next to the IP address on your pi)\nAdd user `pi` and the password (default is `raspberry`)  You may encounter another dialog box for security; if you do, click  Allow  or  Accept .",
            "title": "Chrome OS file manager (tested on Acer Chromebook)"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html",
            "text": "SSHFS (SSH Filesystem)\n\n\nSSHFS allows you to mount a Raspberry Pi's files over an SSH session.\n\n\nInstall\n\n\nLinux\n\n\nInstall SSHFS on your computer with:\n\n\nsudo apt-get install sshfs\n\n\n\n\n\n(This assumes you are using a Debian-based system)\n\n\nMac\n\n\nSee \nosxfuse\n\n\nUsage\n\n\nFirst, create a directory on your host computer:\n\n\nmkdir pi\n\n\n\n\n\nThen mount the Raspberry Pi's filesystem to this location:\n\n\nsshfs pi@192.168.1.3: pi\n\n\n\n\n\nNow enter this directory as if it is a regular folder; you should be able to see and access the contents of the Raspberry Pi:\n\n\ncd\n pi\nls\n\n\n\n\n\nYou can also browse the Pi's filesystem using your computer's file manager (including drag-and-drop to copy files between devices), and use your computer's applications (text editors, image processing tools, and so on) to edit files directly on the Pi.",
            "title": "SSHFS (SSH Filesystem)"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html#sshfs-ssh-filesystem",
            "text": "SSHFS allows you to mount a Raspberry Pi's files over an SSH session.",
            "title": "SSHFS (SSH Filesystem)"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html#install",
            "text": "",
            "title": "Install"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html#linux",
            "text": "Install SSHFS on your computer with:  sudo apt-get install sshfs  (This assumes you are using a Debian-based system)",
            "title": "Linux"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html#mac",
            "text": "See  osxfuse",
            "title": "Mac"
        },
        {
            "location": "/remote-access/ssh/sshfs/index.html#usage",
            "text": "First, create a directory on your host computer:  mkdir pi  Then mount the Raspberry Pi's filesystem to this location:  sshfs pi@192.168.1.3: pi  Now enter this directory as if it is a regular folder; you should be able to see and access the contents of the Raspberry Pi:  cd  pi\nls  You can also browse the Pi's filesystem using your computer's file manager (including drag-and-drop to copy files between devices), and use your computer's applications (text editors, image processing tools, and so on) to edit files directly on the Pi.",
            "title": "Usage"
        },
        {
            "location": "/remote-access/ssh/unix/index.html",
            "text": "SSH using Linux or Mac OS\n\n\nYou can use SSH to connect to your Raspberry Pi from a Linux computer, a Mac, or another Raspberry Pi, without installing additional software.\n\n\nYou will need to know your Raspberry Pi's IP address to connect to it. To find this, type \nhostname -I\n from your Raspberry Pi terminal.\n\n\nIf you are running the Pi without a screen (headless), you can also look at the device list on your router or use a tool like \nnmap\n, which is described in detail in our \nIP Address\n document.\n\n\nTo connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace \n<IP>\n with the IP address of the Raspberry Pi. Use \nCtrl + Shift + V\n to paste in the terminal.\n\n\nssh pi@<IP>\n\n\n\n\n\nIf you receive a \nconnection timed out\n error it is likely that you have entered the wrong IP address for the Raspberry Pi.\n\n\nWhen the connection works you will see a security/authenticity warning. Type \nyes\n to continue. You will only see this warning the first time you connect.\n\n\nIn the event your Pi has taken the IP address of a device to which your computer has connected before (even if this was on another network), you may be given a warning and asked to clear the record from your list of known devices. Following this instruction and trying the \nssh\n command again should be successful.\n\n\nNext you will be prompted for the password for the \npi\n login: on Raspbian the default password is \nraspberry\n. You should now be able to see the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.\n\n\nIf you have set up another user on the Raspberry Pi, you can connect to it in the same way, replacing the username with your own, e.g. \neben@192.168.1.5\n\n\npi@raspberrypi ~ $\n\n\n\n\n\nYou are now connected to the Pi remotely, and can execute commands.\n\n\nX-forwarding\n\n\nYou can also forward your X session over SSH, to allow the use of graphical applications, by using the \n-Y\n flag:\n\n\nssh -Y pi@192.168.1.5\n\n\n\n\n\nNote that \nX11 is no longer present on Macs with OSX\n, so you will have to \ndownload\n and install it.\n\n\nNow you are on the command line as before, but you have the ability to open up graphical windows. For example, typing:\n\n\nidle3 \n&\n\n\n\n\n\n\nwill open up the Python editor IDLE in a graphical window.\n\n\nTyping:\n\n\nscratch \n&\n\n\n\n\n\n\nwill open up Scratch.\n\n\nFor further documentation on the \nssh\n command just enter \nman ssh\n into the Terminal.\n\n\nTo configure your Pi to allow passwordless SSH access with a public/private key pair, see the \npasswordless SSH\n guide.",
            "title": "SSH using Linux or Mac OS"
        },
        {
            "location": "/remote-access/ssh/unix/index.html#ssh-using-linux-or-mac-os",
            "text": "You can use SSH to connect to your Raspberry Pi from a Linux computer, a Mac, or another Raspberry Pi, without installing additional software.  You will need to know your Raspberry Pi's IP address to connect to it. To find this, type  hostname -I  from your Raspberry Pi terminal.  If you are running the Pi without a screen (headless), you can also look at the device list on your router or use a tool like  nmap , which is described in detail in our  IP Address  document.  To connect to your Pi from a different computer, copy and paste the following command into the terminal window but replace  <IP>  with the IP address of the Raspberry Pi. Use  Ctrl + Shift + V  to paste in the terminal.  ssh pi@<IP>  If you receive a  connection timed out  error it is likely that you have entered the wrong IP address for the Raspberry Pi.  When the connection works you will see a security/authenticity warning. Type  yes  to continue. You will only see this warning the first time you connect.  In the event your Pi has taken the IP address of a device to which your computer has connected before (even if this was on another network), you may be given a warning and asked to clear the record from your list of known devices. Following this instruction and trying the  ssh  command again should be successful.  Next you will be prompted for the password for the  pi  login: on Raspbian the default password is  raspberry . You should now be able to see the Raspberry Pi prompt, which will be identical to the one found on the Raspberry Pi itself.  If you have set up another user on the Raspberry Pi, you can connect to it in the same way, replacing the username with your own, e.g.  eben@192.168.1.5  pi@raspberrypi ~ $  You are now connected to the Pi remotely, and can execute commands.",
            "title": "SSH using Linux or Mac OS"
        },
        {
            "location": "/remote-access/ssh/unix/index.html#x-forwarding",
            "text": "You can also forward your X session over SSH, to allow the use of graphical applications, by using the  -Y  flag:  ssh -Y pi@192.168.1.5  Note that  X11 is no longer present on Macs with OSX , so you will have to  download  and install it.  Now you are on the command line as before, but you have the ability to open up graphical windows. For example, typing:  idle3  &   will open up the Python editor IDLE in a graphical window.  Typing:  scratch  &   will open up Scratch.  For further documentation on the  ssh  command just enter  man ssh  into the Terminal.  To configure your Pi to allow passwordless SSH access with a public/private key pair, see the  passwordless SSH  guide.",
            "title": "X-forwarding"
        },
        {
            "location": "/remote-access/ssh/windows/index.html",
            "text": "SSH using Windows\n\n\nOn Windows you will need to download an SSH client. The most commonly used client is called PuTTY, and can be downloaded from \ngreenend.org.uk\n\n\nLook for \nputty.exe\n under the heading \nFor Windows on Intel x86\n. \n\n\n1. Add your Raspberry Pi as a host\n\n\nPuTTY does not include an installer package: it is a stand-alone \n.exe\n file. When you run it, you will see the configuration screen below:\n\n\n\n\nType the IP address of the Pi into the \nHost Name\n field and click the \nOpen\n button. If nothing happens when you click the \nOpen\n button, and you eventually see a message saying \nNetwork error: Connection timed out\n, it is likely that you have entered the wrong IP address for the Pi.\n\n\nIf you do not know the IP address, type \nhostname -I\n in the Raspberry Pi command line. There are more ways to find your IP address \nhere\n.\n\n\n2. Connect\n\n\nWhen the connection works you will see the security warning shown below. You can safely ignore it, and click the 'Yes' button. You will only see this warning the first time PuTTY connects to a Raspberry Pi that it has not seen before.\n\n\n\n\nYou will now see the usual login prompt. Log in with the same username and password you would use on the Pi itself. The default login for Raspbian is \npi\n with the password \nraspberry\n.\n\n\nYou should now have the Raspberry Pi prompt which will be identical to the one found on the Raspberry Pi itself.\n\n\npi@raspberrypi ~ $\n\n\n\n\n\n\n\nYou can type \nexit\n to close the PuTTY window.\n\n\n3. Modification, troubleshooting, and more\n\n\nNext time you use PuTTY, look for the \nSaved Sessions\n section in the bottom half of the configuration screen. If you use this, we recommend switching to the \nConnection\n page in the left hand tree, and setting the \nSeconds between keepalives\n value to \n30\n. Then switch back to the \nSession\n page in the tree before you click \nSave\n. Using this setting allows you to leave a PuTTY window open for long periods of time with no activity, without the Pi timing out and disconnecting you.\n\n\nA connection might be unsuccessful for various reasons. It is most likely that your device or Raspberry Pi are \nnot connected properly\n; \nSSH is disabled\n; there is a typo in your code; or the IP address or credentials have changed. In the latter cases, you will need to update the host. For instructions on how to update a host, and for further PuTTY documentation, please see the \nPuTTY docs\n.",
            "title": "SSH using Windows"
        },
        {
            "location": "/remote-access/ssh/windows/index.html#ssh-using-windows",
            "text": "On Windows you will need to download an SSH client. The most commonly used client is called PuTTY, and can be downloaded from  greenend.org.uk  Look for  putty.exe  under the heading  For Windows on Intel x86 .",
            "title": "SSH using Windows"
        },
        {
            "location": "/remote-access/ssh/windows/index.html#1-add-your-raspberry-pi-as-a-host",
            "text": "PuTTY does not include an installer package: it is a stand-alone  .exe  file. When you run it, you will see the configuration screen below:   Type the IP address of the Pi into the  Host Name  field and click the  Open  button. If nothing happens when you click the  Open  button, and you eventually see a message saying  Network error: Connection timed out , it is likely that you have entered the wrong IP address for the Pi.  If you do not know the IP address, type  hostname -I  in the Raspberry Pi command line. There are more ways to find your IP address  here .",
            "title": "1. Add your Raspberry Pi as a host"
        },
        {
            "location": "/remote-access/ssh/windows/index.html#2-connect",
            "text": "When the connection works you will see the security warning shown below. You can safely ignore it, and click the 'Yes' button. You will only see this warning the first time PuTTY connects to a Raspberry Pi that it has not seen before.   You will now see the usual login prompt. Log in with the same username and password you would use on the Pi itself. The default login for Raspbian is  pi  with the password  raspberry .  You should now have the Raspberry Pi prompt which will be identical to the one found on the Raspberry Pi itself.  pi@raspberrypi ~ $   You can type  exit  to close the PuTTY window.",
            "title": "2. Connect"
        },
        {
            "location": "/remote-access/ssh/windows/index.html#3-modification-troubleshooting-and-more",
            "text": "Next time you use PuTTY, look for the  Saved Sessions  section in the bottom half of the configuration screen. If you use this, we recommend switching to the  Connection  page in the left hand tree, and setting the  Seconds between keepalives  value to  30 . Then switch back to the  Session  page in the tree before you click  Save . Using this setting allows you to leave a PuTTY window open for long periods of time with no activity, without the Pi timing out and disconnecting you.  A connection might be unsuccessful for various reasons. It is most likely that your device or Raspberry Pi are  not connected properly ;  SSH is disabled ; there is a typo in your code; or the IP address or credentials have changed. In the latter cases, you will need to update the host. For instructions on how to update a host, and for further PuTTY documentation, please see the  PuTTY docs .",
            "title": "3. Modification, troubleshooting, and more"
        },
        {
            "location": "/remote-access/vnc/README/index.html",
            "text": "VNC (Virtual Network Computing)\n\n\nSometimes it is not convenient to work directly on the Raspberry Pi. Maybe you would like to work on it from another device by remote control.\n\n\nVNC is a graphical desktop sharing system that allows you to remotely control the desktop interface of one computer (running VNC Server) from another computer or mobile device (running VNC Viewer). VNC Viewer transmits the keyboard and either mouse or touch events to VNC Server, and receives updates to the screen in return.\n\n\nYou will see the desktop of the Raspberry Pi inside a window on your computer or mobile device. You'll be able to control it as though you were working on the Raspberry Pi itself.\n\n\n\n\nVNC Connect from RealVNC is included with Raspbian. It consists of both VNC Server, which allows you to control your Raspberry Pi remotely, and VNC Viewer, which allows you to control desktop computers remotely from your Raspberry Pi should you want to.\n\n\nYou must enable VNC Server before you can use it: instructions for this are given below. By default, VNC Server gives you remote access to the graphical desktop that is running on your Raspberry Pi, as though you were sitting in front of it.\n\n\nHowever, you can also use VNC Server to gain graphical remote access to your Raspberry Pi if it is headless or not running a graphical desktop. For more information on this, see \nCreating a virtual desktop\n, further below. \n\n\nEnabling VNC Server\n\n\nOn your Raspberry Pi, run the following commands to make sure you have the latest version of VNC Connect:\n\n\nsudo apt-get update\nsudo apt-get install realvnc-vnc-server realvnc-vnc-viewer\n\n\n\n\n\nNow enable VNC Server. You can do this graphically or at the command line.\n\n\nEnabling VNC Server graphically\n\n\n\n\n\n\nOn your Raspberry Pi, boot into the graphical desktop.\n\n\n\n\n\n\nSelect \nMenu > Preferences > Raspberry Pi Configuration > Interfaces\n. \n\n\n\n\n\n\nEnsure \nVNC\n is \nEnabled\n. \n\n\n\n\n\n\nEnabling VNC Server at the command line\n\n\nYou can enable VNC Server at the command line using \nraspi-config\n:\n\n\nsudo raspi-config\n\n\n\n\n\nNow, enable VNC Server by doing the following:\n\n\n\n\n\n\nNavigate to \nInterfacing Options\n.\n\n\n\n\n\n\nScroll down and select \nVNC > Yes\n.\n\n\n\n\n\n\nConnecting to your Raspberry Pi with VNC Viewer\n\n\nThere are two ways to connect to your Raspberry Pi. You can use either or both, depending on what works best for you.\n\n\nEstablishing a direct connection\n\n\nDirect connections are quick and simple providing you're joined to the same private local network as your Raspberry Pi. For example, this might be a wired or wireless network at home, at school, or in the office).\n\n\n\n\n\n\nOn your Raspberry Pi (using a terminal window or via SSH) use \nthese instructions\n or run \nifconfig\n to discover your private IP address. \n\n\n\n\n\n\nOn the device you'll use to take control, download VNC Viewer. For best results, use the \ncompatible app\n from RealVNC. \n\n\n\n\n\n\nEnter your Raspberry Pi's private IP address into VNC Viewer:\n\n\n\n\n\n\n\n\nEstablishing a cloud connection\n\n\nYou are entitled to use RealVNC's cloud service for free, provided that remote access is for educational or non-commercial purposes only.\n\n\nCloud connections are convenient and encrypted end-to-end. They are highly recommended for connecting to your Raspberry Pi over the internet. There's no firewall or router reconfiguration, and you don't need to know the IP address of your Raspberry Pi, or provide a static one.\n\n\n\n\n\n\nSign up for a RealVNC account \nhere\n: it's free and it only takes a few seconds.\n\n\n\n\n\n\nOn your Raspberry Pi, sign in to VNC Server using your new RealVNC account credentials:\n\n\n\n\n\n\n\n\n\n\n\n\nOn the device you'll use to take control, download VNC Viewer. You \nmust\n use the \ncompatible app\n from RealVNC.\n\n\n\n\n\n\nSign in to VNC Viewer using the same RealVNC account credentials, and then either tap or click to connect to your Raspberry Pi:\n\n\n\n\n\n\n\n\nAuthenticating to VNC Server\n\n\nTo complete either a direct or cloud connection, you must authenticate to VNC Server. \n\n\nIf you're connecting from the \ncompatible VNC Viewer app\n from RealVNC, enter the user name and password you normally use to log in to your user account on the Raspberry Pi. By default, these credentials are \npi\n and \nraspberry\n.\n\n\nIf you're connecting from a non-RealVNC Viewer app, you'll first need to downgrade VNC Server's authentication scheme, specify a password unique to VNC Server, and then enter that instead.\n\n If you are in front of your Raspberry Pi and can see its screen, open the VNC Server dialog on your Raspberry Pi, select \nMenu > Options > Security\n, and choose \nVNC password\n from the \nAuthentication\n dropdown.\n\n \nOr\n if you're configuring your Raspberry Pi remotely from the command line, then to make the changes for Service Mode (the default configuration for the Raspberry Pi):\n  * Open the \n/root/.vnc/config.d/vncserver-x11\n config file.\n  * Replace \nAuthentication=SystemAuth\n with \nAuthentication=VncAuth\n and save the file.\n  * In the command line, run \nsudo vncpasswd -service\n. This  will prompt you to set a password, and will insert it for you in the right config file for VNC Server running in Service Mode.\n  * Restart VNC Server.\n\n\nPlaying Minecraft and other directly rendered apps remotely\n\n\nYou can remotely access apps which use a directly rendered overlay, such as Minecraft, the text console, the Raspberry Pi Camera Module, and more.\n\n\n\n\nTo turn this feature on:\n\n\n\n\n\n\nOn your Raspberry Pi, open the VNC Server dialog. \n\n\n\n\n\n\nNavigate to \nMenu > Options > Troubleshooting\n and select \nEnable experimental direct capture mode\n.\n\n\n\n\n\n\nOn the device you'll use to take control, run VNC Viewer and connect.\n\n\n\n\n\n\nNote:\n existing connections must be restarted in order for these changes to take effect.\n\n\nPlease note that direct screen capture is an experimental feature. If you're connecting from a desktop computer and mouse movements seem erratic, try pressing \nF8\n to open the VNC Viewer shortcut menu and selecting \nRelative Pointer Motion\n.\n\n\nIf performance seems impaired, try \nthese troubleshooting steps\n, or \nlet RealVNC know\n.\n\n\nCreating a virtual desktop\n\n\nIf your Raspberry Pi is headless (i.e. not plugged into a monitor) or controlling a robot, it is unlikely to be running a graphical desktop.\n\n\nVNC Server can create a \nvirtual desktop\n for you, giving you graphical remote access on demand. This virtual desktop exists only in your Raspberry Pi's memory:\n\n\n\n\nTo create and connect to a virtual desktop: \n\n\n\n\n\n\nOn your Raspberry Pi (using Terminal or via SSH), run \nvncserver\n. Make note of the IP address/display number that VNC Server will print to your Terminal (e.g. \n192.167.5.149:1\n).\n\n\n\n\n\n\nOn the device you'll use to take control, enter this information into \nVNC Viewer\n.\n\n\n\n\n\n\nTo destroy a virtual desktop, run the following command: \n\n\nvncserver -kill :<display-number>\n\n\n\n\n\nThis will also stop any existing connections to this virtual desktop.",
            "title": "VNC (Virtual Network Computing)"
        },
        {
            "location": "/remote-access/vnc/README/index.html#vnc-virtual-network-computing",
            "text": "Sometimes it is not convenient to work directly on the Raspberry Pi. Maybe you would like to work on it from another device by remote control.  VNC is a graphical desktop sharing system that allows you to remotely control the desktop interface of one computer (running VNC Server) from another computer or mobile device (running VNC Viewer). VNC Viewer transmits the keyboard and either mouse or touch events to VNC Server, and receives updates to the screen in return.  You will see the desktop of the Raspberry Pi inside a window on your computer or mobile device. You'll be able to control it as though you were working on the Raspberry Pi itself.   VNC Connect from RealVNC is included with Raspbian. It consists of both VNC Server, which allows you to control your Raspberry Pi remotely, and VNC Viewer, which allows you to control desktop computers remotely from your Raspberry Pi should you want to.  You must enable VNC Server before you can use it: instructions for this are given below. By default, VNC Server gives you remote access to the graphical desktop that is running on your Raspberry Pi, as though you were sitting in front of it.  However, you can also use VNC Server to gain graphical remote access to your Raspberry Pi if it is headless or not running a graphical desktop. For more information on this, see  Creating a virtual desktop , further below.",
            "title": "VNC (Virtual Network Computing)"
        },
        {
            "location": "/remote-access/vnc/README/index.html#enabling-vnc-server",
            "text": "On your Raspberry Pi, run the following commands to make sure you have the latest version of VNC Connect:  sudo apt-get update\nsudo apt-get install realvnc-vnc-server realvnc-vnc-viewer  Now enable VNC Server. You can do this graphically or at the command line.",
            "title": "Enabling VNC Server"
        },
        {
            "location": "/remote-access/vnc/README/index.html#enabling-vnc-server-graphically",
            "text": "On your Raspberry Pi, boot into the graphical desktop.    Select  Menu > Preferences > Raspberry Pi Configuration > Interfaces .     Ensure  VNC  is  Enabled .",
            "title": "Enabling VNC Server graphically"
        },
        {
            "location": "/remote-access/vnc/README/index.html#enabling-vnc-server-at-the-command-line",
            "text": "You can enable VNC Server at the command line using  raspi-config :  sudo raspi-config  Now, enable VNC Server by doing the following:    Navigate to  Interfacing Options .    Scroll down and select  VNC > Yes .",
            "title": "Enabling VNC Server at the command line"
        },
        {
            "location": "/remote-access/vnc/README/index.html#connecting-to-your-raspberry-pi-with-vnc-viewer",
            "text": "There are two ways to connect to your Raspberry Pi. You can use either or both, depending on what works best for you.",
            "title": "Connecting to your Raspberry Pi with VNC Viewer"
        },
        {
            "location": "/remote-access/vnc/README/index.html#establishing-a-direct-connection",
            "text": "Direct connections are quick and simple providing you're joined to the same private local network as your Raspberry Pi. For example, this might be a wired or wireless network at home, at school, or in the office).    On your Raspberry Pi (using a terminal window or via SSH) use  these instructions  or run  ifconfig  to discover your private IP address.     On the device you'll use to take control, download VNC Viewer. For best results, use the  compatible app  from RealVNC.     Enter your Raspberry Pi's private IP address into VNC Viewer:",
            "title": "Establishing a direct connection"
        },
        {
            "location": "/remote-access/vnc/README/index.html#establishing-a-cloud-connection",
            "text": "You are entitled to use RealVNC's cloud service for free, provided that remote access is for educational or non-commercial purposes only.  Cloud connections are convenient and encrypted end-to-end. They are highly recommended for connecting to your Raspberry Pi over the internet. There's no firewall or router reconfiguration, and you don't need to know the IP address of your Raspberry Pi, or provide a static one.    Sign up for a RealVNC account  here : it's free and it only takes a few seconds.    On your Raspberry Pi, sign in to VNC Server using your new RealVNC account credentials:       On the device you'll use to take control, download VNC Viewer. You  must  use the  compatible app  from RealVNC.    Sign in to VNC Viewer using the same RealVNC account credentials, and then either tap or click to connect to your Raspberry Pi:",
            "title": "Establishing a cloud connection"
        },
        {
            "location": "/remote-access/vnc/README/index.html#authenticating-to-vnc-server",
            "text": "To complete either a direct or cloud connection, you must authenticate to VNC Server.   If you're connecting from the  compatible VNC Viewer app  from RealVNC, enter the user name and password you normally use to log in to your user account on the Raspberry Pi. By default, these credentials are  pi  and  raspberry .  If you're connecting from a non-RealVNC Viewer app, you'll first need to downgrade VNC Server's authentication scheme, specify a password unique to VNC Server, and then enter that instead.  If you are in front of your Raspberry Pi and can see its screen, open the VNC Server dialog on your Raspberry Pi, select  Menu > Options > Security , and choose  VNC password  from the  Authentication  dropdown.   Or  if you're configuring your Raspberry Pi remotely from the command line, then to make the changes for Service Mode (the default configuration for the Raspberry Pi):\n  * Open the  /root/.vnc/config.d/vncserver-x11  config file.\n  * Replace  Authentication=SystemAuth  with  Authentication=VncAuth  and save the file.\n  * In the command line, run  sudo vncpasswd -service . This  will prompt you to set a password, and will insert it for you in the right config file for VNC Server running in Service Mode.\n  * Restart VNC Server.",
            "title": "Authenticating to VNC Server"
        },
        {
            "location": "/remote-access/vnc/README/index.html#playing-minecraft-and-other-directly-rendered-apps-remotely",
            "text": "You can remotely access apps which use a directly rendered overlay, such as Minecraft, the text console, the Raspberry Pi Camera Module, and more.   To turn this feature on:    On your Raspberry Pi, open the VNC Server dialog.     Navigate to  Menu > Options > Troubleshooting  and select  Enable experimental direct capture mode .    On the device you'll use to take control, run VNC Viewer and connect.    Note:  existing connections must be restarted in order for these changes to take effect.  Please note that direct screen capture is an experimental feature. If you're connecting from a desktop computer and mouse movements seem erratic, try pressing  F8  to open the VNC Viewer shortcut menu and selecting  Relative Pointer Motion .  If performance seems impaired, try  these troubleshooting steps , or  let RealVNC know .",
            "title": "Playing Minecraft and other directly rendered apps remotely"
        },
        {
            "location": "/remote-access/vnc/README/index.html#creating-a-virtual-desktop",
            "text": "If your Raspberry Pi is headless (i.e. not plugged into a monitor) or controlling a robot, it is unlikely to be running a graphical desktop.  VNC Server can create a  virtual desktop  for you, giving you graphical remote access on demand. This virtual desktop exists only in your Raspberry Pi's memory:   To create and connect to a virtual desktop:     On your Raspberry Pi (using Terminal or via SSH), run  vncserver . Make note of the IP address/display number that VNC Server will print to your Terminal (e.g.  192.167.5.149:1 ).    On the device you'll use to take control, enter this information into  VNC Viewer .    To destroy a virtual desktop, run the following command:   vncserver -kill :<display-number>  This will also stop any existing connections to this virtual desktop.",
            "title": "Creating a virtual desktop"
        },
        {
            "location": "/remote-access/web-server/README/index.html",
            "text": "Setting up a web server on a Raspberry Pi\n\n\nYou can use a web server on a Raspberry Pi to host a full website (locally on your network or globally on the internet), or just use it to display some information you wish to share to other machines on your network.\n\n\nVarious web servers are available, with different advantages for usage:\n\n\n\n\nApache\n\n\nNGINX",
            "title": "Setting up a web server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/README/index.html#setting-up-a-web-server-on-a-raspberry-pi",
            "text": "You can use a web server on a Raspberry Pi to host a full website (locally on your network or globally on the internet), or just use it to display some information you wish to share to other machines on your network.  Various web servers are available, with different advantages for usage:   Apache  NGINX",
            "title": "Setting up a web server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/apache/index.html",
            "text": "Setting up an Apache Web Server on a Raspberry Pi\n\n\nApache is a popular web server application you can install on the Raspberry Pi to allow it to serve web pages.\n\n\nOn its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP.\n\n\nInstall Apache\n\n\nFirst install the \napache2\n package by typing the following command in to the Terminal:\n\n\nsudo apt-get install apache2 -y\n\n\n\n\n\nTest the web server\n\n\nBy default, Apache puts a test HTML file in the web folder. This default web page is served when you browse to \nhttp://localhost/\n on the Pi itself, or \nhttp://192.168.1.10\n (whatever the Pi's IP address is) from another computer on the network. To find the Pi's IP address, type \nhostname -I\n at the command line (or read more about finding your \nIP address\n).\n\n\nBrowse to the default web page either on the Pi or from another computer on the network and you should see the following:\n\n\n\n\nThis means you have Apache working!\n\n\nChanging the default web page\n\n\nThis default web page is just a HTML file on the filesystem. It is located at \n/var/www/html/index.html\n.\n\n\nNote: The directory was \n/var/www\n in Raspbian Wheezy but is now \n/var/www/html\n in Raspbian Jessie\n\n\nNavigate to this directory in a terminal window and have a look at what's inside:\n\n\ncd /var/www/html\nls -al\n\n\n\n\n\nThis will show you:\n\n\ntotal \n12\n\ndrwxr-xr-x  \n2\n root root \n4096\n Jan  \n8\n \n01\n:29 .\ndrwxr-xr-x \n12\n root root \n4096\n Jan  \n8\n \n01\n:28 ..\n-rw-r--r--  \n1\n root root  \n177\n Jan  \n8\n \n01\n:29 index.html\n\n\n\n\n\nThis shows that by default there is one file in \n/var/www/html/\n called \nindex.html\nand it is owned by the \nroot\n user (as is the enclosing folder). In order to edit the file, you need to change its ownership to your own username. Change the owner of the file (the default \npi\n user is assumed here) using \nsudo chown pi: index.html\n.\n\n\nYou can now try editing this file and then refreshing the browser to see the web page change.\n\n\nYour own website\n\n\nIf you know HTML you can put your own HTML files and other assets in this directory and serve them as a website on your local network.\n\n\nAdditional - install PHP\n\n\nTo allow your Apache server to process PHP files, you'll need to install the latest version of PHP and the PHP module for Apache. Type the following command to install these:\n\n\nsudo apt-get install php libapache2-mod-php -y\n\n\n\n\n\nNow remove the \nindex.html\n file:\n\n\nsudo rm index.html\n\n\n\n\n\nand create the file \nindex.php\n:\n\n\nsudo leafpad index.php\n\n\n\n\n\nNote: Leafpad is a graphical editor. Alternatively, use \nnano\n if you're restricted to the command line\n\n\nPut some PHP content in it:\n\n\n<?php\n \necho\n \n\"hello world\"\n;\n \n?>\n\n\n\n\n\n\nNow save and refresh your browser. You should see \"hello world\". This is not dynamic but still served by PHP. Try something dynamic:\n\n\n<?php\n \necho\n \ndate\n(\n'Y-m-d H:i:s'\n);\n \n?>\n\n\n\n\n\n\nor show your PHP info:\n\n\n<?php\n \nphpinfo\n();\n \n?>\n\n\n\n\n\n\nFurther - WordPress\n\n\nNow you have Apache and PHP installed you can progress to setting up a WordPress site on your Pi. Continue to \nWordPress usage\n.",
            "title": "Setting up an Apache Web Server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#setting-up-an-apache-web-server-on-a-raspberry-pi",
            "text": "Apache is a popular web server application you can install on the Raspberry Pi to allow it to serve web pages.  On its own, Apache can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP.",
            "title": "Setting up an Apache Web Server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#install-apache",
            "text": "First install the  apache2  package by typing the following command in to the Terminal:  sudo apt-get install apache2 -y",
            "title": "Install Apache"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#test-the-web-server",
            "text": "By default, Apache puts a test HTML file in the web folder. This default web page is served when you browse to  http://localhost/  on the Pi itself, or  http://192.168.1.10  (whatever the Pi's IP address is) from another computer on the network. To find the Pi's IP address, type  hostname -I  at the command line (or read more about finding your  IP address ).  Browse to the default web page either on the Pi or from another computer on the network and you should see the following:   This means you have Apache working!",
            "title": "Test the web server"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#changing-the-default-web-page",
            "text": "This default web page is just a HTML file on the filesystem. It is located at  /var/www/html/index.html .  Note: The directory was  /var/www  in Raspbian Wheezy but is now  /var/www/html  in Raspbian Jessie  Navigate to this directory in a terminal window and have a look at what's inside:  cd /var/www/html\nls -al  This will show you:  total  12 \ndrwxr-xr-x   2  root root  4096  Jan   8   01 :29 .\ndrwxr-xr-x  12  root root  4096  Jan   8   01 :28 ..\n-rw-r--r--   1  root root   177  Jan   8   01 :29 index.html  This shows that by default there is one file in  /var/www/html/  called  index.html and it is owned by the  root  user (as is the enclosing folder). In order to edit the file, you need to change its ownership to your own username. Change the owner of the file (the default  pi  user is assumed here) using  sudo chown pi: index.html .  You can now try editing this file and then refreshing the browser to see the web page change.",
            "title": "Changing the default web page"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#your-own-website",
            "text": "If you know HTML you can put your own HTML files and other assets in this directory and serve them as a website on your local network.",
            "title": "Your own website"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#additional-install-php",
            "text": "To allow your Apache server to process PHP files, you'll need to install the latest version of PHP and the PHP module for Apache. Type the following command to install these:  sudo apt-get install php libapache2-mod-php -y  Now remove the  index.html  file:  sudo rm index.html  and create the file  index.php :  sudo leafpad index.php  Note: Leafpad is a graphical editor. Alternatively, use  nano  if you're restricted to the command line  Put some PHP content in it:  <?php   echo   \"hello world\" ;   ?>   Now save and refresh your browser. You should see \"hello world\". This is not dynamic but still served by PHP. Try something dynamic:  <?php   echo   date ( 'Y-m-d H:i:s' );   ?>   or show your PHP info:  <?php   phpinfo ();   ?>",
            "title": "Additional - install PHP"
        },
        {
            "location": "/remote-access/web-server/apache/index.html#further-wordpress",
            "text": "Now you have Apache and PHP installed you can progress to setting up a WordPress site on your Pi. Continue to  WordPress usage .",
            "title": "Further - WordPress"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html",
            "text": "Setting up an NGINX web server on a Raspberry Pi\n\n\nNGINX (pronounced \nengine x\n) is a popular lightweight web server application you can install on the Raspberry Pi to allow it to serve web pages.\n\n\nLike Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP.\n\n\nInstall NGINX\n\n\nFirst install the \nnginx\n package by typing the following command in to the Terminal:\n\n\nsudo apt-get install nginx\n\n\n\n\n\nand start the server with:\n\n\nsudo /etc/init.d/nginx start\n\n\n\n\n\nTest the web server\n\n\nBy default, NGINX puts a test HTML file in the web folder. This default web page is served when you browse to \nhttp://localhost/\n on the Pi itself, or \nhttp://192.168.1.10\n (whatever the Pi's IP address is) from another computer on the network. To find the Pi's IP address, type \nhostname -I\n at the command line (or read more about finding your \nIP address\n).\n\n\nBrowse to the default web page either on the Pi or from another computer on the network and you should see the following:\n\n\n\n\nChanging the default web page\n\n\nNGINX defaults its web page location to \n/var/www/html\n on Raspbian. Navigate to this folder and edit or replace index.nginx-debian.html as you like. You can confirm the default page location at \n/etc/nginx/sites-available\n on the line which starts with 'root', should you need to.\n\n\nAdditional - Install PHP\n\n\nsudo apt-get install php-fpm\n\n\n\n\n\nEnable PHP in NGINX\n\n\ncd\n /etc/nginx\nsudo nano sites-enabled/default\n\n\n\n\n\nfind the line\n\n\nindex index.html index.htm;\n\n\n\n\n\nroughly around line 25 (Press \nCTRL + C\n in nano to see the current line number)\n\n\nAdd \nindex.php\n after \nindex\n to look like this:\n\n\nindex index.php index.html index.htm;\n\n\n\n\n\nScroll down until you find a section with the following content:\n\n\n# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n#\n# location ~ \\.php$ {\n\n\n\n\n\nEdit by removing the \n#\n characters on the following lines:\n\n\nlocation\n \n~\n \n\\\n.\nphp\n$\n \n{\n\n    \ninclude\n \nsnippets/fastcgi-php.conf\n;\n\n    \nfastcgi_pass\n \nunix\n:\n/\nvar\n/\nrun\n/\nphp5-fpm\n.\nsock\n;\n\n\n}\n\n\n\n\n\n\nIt should look like this:\n\n\n        \n#\n \npass\n \nthe\n \nPHP\n \nscripts\n \nto\n \nFastCGI\n \nserver\n \nlistening\n \non\n \n127\n.\n0\n.\n0\n.\n1\n:\n9000\n\n        \n#\n\n        \nlocation\n \n~\n \n\\\n.\nphp\n$\n \n{\n\n                \ninclude\n \nsnippets/fastcgi-php.conf\n;\n\n\n                \n#\n \nWith\n \nphp5-cgi\n \nalone\n:\n\n        \n#\n       \nfastcgi_pass\n \n127.0.0.1\n:\n9000\n;\n\n                \n#\n \nWith\n \nphp5-fpm\n:\n\n                \nfastcgi_pass\n \nunix\n:/\nvar\n/\nrun\n/\nphp5-fpm\n.\nsock\n;\n\n        \n}\n\n\n\n\n\n\nReload the configuration file\n\n\nsudo /etc/init.d/nginx reload\n\n\n\n\n\nTest PHP\n\n\nRename \nindex.nginx-debian.html\n to \nindex.php\n:\n\n\ncd\n /var/www/html/\nsudo mv index.nginx-debian.html index.php\n\n\n\n\n\nOpen \nindex.php\n with a text editor:\n\n\nsudo nano index.php\n\n\n\n\n\nAdd some dynamic PHP content by replacing the current content:\n\n\n<?php\n \necho\n \nphpinfo\n();\n \n?>\n\n\n\n\n\n\nSave and refresh your browser. You should see a page with the PHP version, logo and current configuration settings.",
            "title": "Setting up an NGINX web server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#setting-up-an-nginx-web-server-on-a-raspberry-pi",
            "text": "NGINX (pronounced  engine x ) is a popular lightweight web server application you can install on the Raspberry Pi to allow it to serve web pages.  Like Apache, NGINX can serve HTML files over HTTP, and with additional modules can serve dynamic web pages using scripting languages such as PHP.",
            "title": "Setting up an NGINX web server on a Raspberry Pi"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#install-nginx",
            "text": "First install the  nginx  package by typing the following command in to the Terminal:  sudo apt-get install nginx  and start the server with:  sudo /etc/init.d/nginx start",
            "title": "Install NGINX"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#test-the-web-server",
            "text": "By default, NGINX puts a test HTML file in the web folder. This default web page is served when you browse to  http://localhost/  on the Pi itself, or  http://192.168.1.10  (whatever the Pi's IP address is) from another computer on the network. To find the Pi's IP address, type  hostname -I  at the command line (or read more about finding your  IP address ).  Browse to the default web page either on the Pi or from another computer on the network and you should see the following:",
            "title": "Test the web server"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#changing-the-default-web-page",
            "text": "NGINX defaults its web page location to  /var/www/html  on Raspbian. Navigate to this folder and edit or replace index.nginx-debian.html as you like. You can confirm the default page location at  /etc/nginx/sites-available  on the line which starts with 'root', should you need to.",
            "title": "Changing the default web page"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#additional-install-php",
            "text": "sudo apt-get install php-fpm",
            "title": "Additional - Install PHP"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#enable-php-in-nginx",
            "text": "cd  /etc/nginx\nsudo nano sites-enabled/default  find the line  index index.html index.htm;  roughly around line 25 (Press  CTRL + C  in nano to see the current line number)  Add  index.php  after  index  to look like this:  index index.php index.html index.htm;  Scroll down until you find a section with the following content:  # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n#\n# location ~ \\.php$ {  Edit by removing the  #  characters on the following lines:  location   ~   \\ . php $   { \n     include   snippets/fastcgi-php.conf ; \n     fastcgi_pass   unix : / var / run / php5-fpm . sock ;  }   It should look like this:           #   pass   the   PHP   scripts   to   FastCGI   server   listening   on   127 . 0 . 0 . 1 : 9000 \n         # \n         location   ~   \\ . php $   { \n                 include   snippets/fastcgi-php.conf ; \n\n                 #   With   php5-cgi   alone : \n         #         fastcgi_pass   127.0.0.1 : 9000 ; \n                 #   With   php5-fpm : \n                 fastcgi_pass   unix :/ var / run / php5-fpm . sock ; \n         }   Reload the configuration file  sudo /etc/init.d/nginx reload",
            "title": "Enable PHP in NGINX"
        },
        {
            "location": "/remote-access/web-server/nginx/index.html#test-php",
            "text": "Rename  index.nginx-debian.html  to  index.php :  cd  /var/www/html/\nsudo mv index.nginx-debian.html index.php  Open  index.php  with a text editor:  sudo nano index.php  Add some dynamic PHP content by replacing the current content:  <?php   echo   phpinfo ();   ?>   Save and refresh your browser. You should see a page with the PHP version, logo and current configuration settings.",
            "title": "Test PHP"
        },
        {
            "location": "/setup/README/index.html",
            "text": "Setup\n\n\nA guide to setting up your Raspberry Pi\n\n\nWhat you will need\n\n\nEssential (for general use)\n\n\n\n\nSD Card\n\n\nWe recommend an 8GB class 4 SD card, ideally preinstalled with \nNOOBS\n.\n\n\n\n\n\n\nDisplay and connectivity cable\n\n\nAny HDMI/DVI monitor and any TV should work as a display for the Pi. For best results, use one with HDMI input, but other connections are available for older devices.\n\n\n\n\n\n\nKeyboard and mouse\n\n\nAny standard USB keyboard and mouse will work with your Raspberry Pi.\n\n\nWireless keyboards and mice will work if already paired.\n\n\nFor keyboard layout configuration options see \nraspi-config\n.\n\n\n\n\n\n\nPower supply\n\n\nThe Pi is powered by a USB Micro power supply (like most standard mobile phone chargers).\n\n\nYou'll need a good-quality power supply that can supply at least 2A at 5V for the Model 3B, or 700mA at 5V for the earlier, lower powered models.\n\n\nLow current (~700mA) power supplies will work for basic usage, but are likely to cause the Pi to reboot if it draws too much power.\n\n\n\n\n\n\n\n\nOptional\n\n\n\n\nEthernet (network) cable [Model B/B+/2/3 only]\n\n\nAn Ethernet cable is used to connect your Pi to a local network and the internet.\n\n\n\n\n\n\nUSB wireless dongle\n\n\nAlternatively, you can connect to a wireless network using a USB wireless dongle, which will require configuration.\n\n\n\n\n\n\nAudio lead\n\n\nAudio can be played through speakers or headphones using a standard 3.5mm jack.\n\n\nWithout an HDMI cable, an audio lead is necessary to produce sound.\n\n\nNo separate audio lead is necessary if you're using an HDMI cable to connect to a monitor with speakers, as audio can be played directly through the display; but it is possible to connect one if you prefer to have the audio played through other speakers - this requires \nconfiguration\n.\n\n\n\n\n\n\n\n\nTroubleshooting\n\n\nFor any issues during setup, search \nthe forums\n for a solution. If you cannot find one, please post your problem, providing as much detail as possible.",
            "title": "Setup"
        },
        {
            "location": "/setup/README/index.html#setup",
            "text": "A guide to setting up your Raspberry Pi",
            "title": "Setup"
        },
        {
            "location": "/setup/README/index.html#what-you-will-need",
            "text": "",
            "title": "What you will need"
        },
        {
            "location": "/setup/README/index.html#essential-for-general-use",
            "text": "SD Card  We recommend an 8GB class 4 SD card, ideally preinstalled with  NOOBS .    Display and connectivity cable  Any HDMI/DVI monitor and any TV should work as a display for the Pi. For best results, use one with HDMI input, but other connections are available for older devices.    Keyboard and mouse  Any standard USB keyboard and mouse will work with your Raspberry Pi.  Wireless keyboards and mice will work if already paired.  For keyboard layout configuration options see  raspi-config .    Power supply  The Pi is powered by a USB Micro power supply (like most standard mobile phone chargers).  You'll need a good-quality power supply that can supply at least 2A at 5V for the Model 3B, or 700mA at 5V for the earlier, lower powered models.  Low current (~700mA) power supplies will work for basic usage, but are likely to cause the Pi to reboot if it draws too much power.",
            "title": "Essential (for general use)"
        },
        {
            "location": "/setup/README/index.html#optional",
            "text": "Ethernet (network) cable [Model B/B+/2/3 only]  An Ethernet cable is used to connect your Pi to a local network and the internet.    USB wireless dongle  Alternatively, you can connect to a wireless network using a USB wireless dongle, which will require configuration.    Audio lead  Audio can be played through speakers or headphones using a standard 3.5mm jack.  Without an HDMI cable, an audio lead is necessary to produce sound.  No separate audio lead is necessary if you're using an HDMI cable to connect to a monitor with speakers, as audio can be played directly through the display; but it is possible to connect one if you prefer to have the audio played through other speakers - this requires  configuration .",
            "title": "Optional"
        },
        {
            "location": "/setup/README/index.html#troubleshooting",
            "text": "For any issues during setup, search  the forums  for a solution. If you cannot find one, please post your problem, providing as much detail as possible.",
            "title": "Troubleshooting"
        },
        {
            "location": "/setup/monitor-connection/index.html",
            "text": "Monitor Connection\n\n\nFor regular use, you'll want to plug the Raspberry Pi in to a visual display: a monitor or a TV.\n\n\nHDMI Port\n\n\nThe Raspberry Pi has an HDMI port which you can connect directly to a monitor or TV with an HDMI cable. This is the easiest solution; some modern monitors and TVs have HDMI ports, some do not, but there are other options.\n\n\n\n\nDVI\n\n\nFor monitors with a DVI port, you can use an HDMI-to-DVI cable, or an HDMI cable with a DVI adapter. Note that the DVI standard does not support audio.\n\n\n   \n\n\nVGA\n\n\nFor monitors with VGA only, you can use an HDMI-to-VGA adapter. Note that VGA does not support audio.\n\n\n   \n\n\nComposite Port\n\n\nAll models of Raspberry Pi have a composite out port for connecting to analog devices, but the type of connector varies depending on the model. The original Raspberry Pi used an RCA connector, and a standard RCA composite video lead will work. Others models (Raspberry Pi B+ and later) combine the audio out and composite out on to the same 3.5mm jackplug. This requires a particular type of lead, with audio left on the tip, audio right on ring 1, ground on ring 2, and video on the sleeve. This is the same as leads used on the Zune, and on Apple devices.\n\n\n   \n\n\nMore information on connecting to a monitor can be found in our \nlearning resources section\n.",
            "title": "Monitor Connection"
        },
        {
            "location": "/setup/monitor-connection/index.html#monitor-connection",
            "text": "For regular use, you'll want to plug the Raspberry Pi in to a visual display: a monitor or a TV.",
            "title": "Monitor Connection"
        },
        {
            "location": "/setup/monitor-connection/index.html#hdmi-port",
            "text": "The Raspberry Pi has an HDMI port which you can connect directly to a monitor or TV with an HDMI cable. This is the easiest solution; some modern monitors and TVs have HDMI ports, some do not, but there are other options.",
            "title": "HDMI Port"
        },
        {
            "location": "/setup/monitor-connection/index.html#dvi",
            "text": "For monitors with a DVI port, you can use an HDMI-to-DVI cable, or an HDMI cable with a DVI adapter. Note that the DVI standard does not support audio.",
            "title": "DVI"
        },
        {
            "location": "/setup/monitor-connection/index.html#vga",
            "text": "For monitors with VGA only, you can use an HDMI-to-VGA adapter. Note that VGA does not support audio.",
            "title": "VGA"
        },
        {
            "location": "/setup/monitor-connection/index.html#composite-port",
            "text": "All models of Raspberry Pi have a composite out port for connecting to analog devices, but the type of connector varies depending on the model. The original Raspberry Pi used an RCA connector, and a standard RCA composite video lead will work. Others models (Raspberry Pi B+ and later) combine the audio out and composite out on to the same 3.5mm jackplug. This requires a particular type of lead, with audio left on the tip, audio right on ring 1, ground on ring 2, and video on the sleeve. This is the same as leads used on the Zune, and on Apple devices.       More information on connecting to a monitor can be found in our  learning resources section .",
            "title": "Composite Port"
        },
        {
            "location": "/usage/README/index.html",
            "text": "Usage\n\n\nBasic examples to help you get started with some of the software available in Raspbian\n\n\nContents\n\n\n\n\nScratch\n\n\nScratch is a visual programming tool allowing the user to create animations and games with a drag-and-drop interface\n\n\n\n\n\n\nPython\n\n\nPython is a general purpose programming language that is easy to pick up and also very powerful\n\n\n\n\n\n\nSonic Pi\n\n\nWrite code to make music with Sonic Pi\n\n\n\n\n\n\nTerminal\n\n\nThe Linux terminal is a powerful tool for getting around the filesystem and issuing commands\n\n\n\n\n\n\nGPIO: Raspberry Pi Models A and B\n\n\nThe General Purpose Input/Output pins allow you to control and interact with the real world from Python, Scratch or other programming environments\n\n\n\n\n\n\nGPIO: Models A+, B+, Raspberry Pi 2 B and Raspberry Pi 3 B\n\n\nThe General Purpose Input/Output pins allow you to control and interact with the real world from Python, Scratch or other programming environments\n\n\n\n\n\n\nMinecraft\n\n\nA free version of Minecraft is available for the Pi, and this is the only edition that has a programming interface, meaning you can control Minecraft with Python code - and even interact with the real world through GPIO\n\n\n\n\n\n\nPython Games\n\n\nRaspbian ships with some ready made Python games for you to play on your Raspberry Pi - and why not browse the code, hack the games and learn to make your own?\n\n\n\n\n\n\nWordPress\n\n\nSet up a web server on your Raspberry Pi and install Wordpress, a content management and blogging system\n\n\n\n\n\n\nMathematica\n\n\nMathematica is an industry leading computational platform - available for free on Raspberry Pi\n\n\n\n\n\n\nCamera Module\n\n\nThe Raspberry Pi camera module is capable of taking full HD 1080p photo and video and can be controlled programmatically\n\n\nLibraries are available for:\n\n\nBash\n (Linux command line)\n\n\nPython\n\n\n\n\n\n\n\n\n\n\nWebcams\n\n\nUsing a standard USB webcam instead of the Raspberry Pi camera module\n\n\n\n\n\n\nKodi\n\n\nInstalling media centre software on your Raspberry Pi\n\n\n\n\n\n\nPlaying audio\n\n\nPlaying audio on your Raspberry Pi\n\n\n\n\n\n\nPlaying video\n\n\nPlaying video on your Raspberry Pi\n\n\n\n\n\n\nDemo programs\n\n\nA selection of examples to demonstrate the Pi's capabilities",
            "title": "Usage"
        },
        {
            "location": "/usage/README/index.html#usage",
            "text": "Basic examples to help you get started with some of the software available in Raspbian",
            "title": "Usage"
        },
        {
            "location": "/usage/README/index.html#contents",
            "text": "Scratch  Scratch is a visual programming tool allowing the user to create animations and games with a drag-and-drop interface    Python  Python is a general purpose programming language that is easy to pick up and also very powerful    Sonic Pi  Write code to make music with Sonic Pi    Terminal  The Linux terminal is a powerful tool for getting around the filesystem and issuing commands    GPIO: Raspberry Pi Models A and B  The General Purpose Input/Output pins allow you to control and interact with the real world from Python, Scratch or other programming environments    GPIO: Models A+, B+, Raspberry Pi 2 B and Raspberry Pi 3 B  The General Purpose Input/Output pins allow you to control and interact with the real world from Python, Scratch or other programming environments    Minecraft  A free version of Minecraft is available for the Pi, and this is the only edition that has a programming interface, meaning you can control Minecraft with Python code - and even interact with the real world through GPIO    Python Games  Raspbian ships with some ready made Python games for you to play on your Raspberry Pi - and why not browse the code, hack the games and learn to make your own?    WordPress  Set up a web server on your Raspberry Pi and install Wordpress, a content management and blogging system    Mathematica  Mathematica is an industry leading computational platform - available for free on Raspberry Pi    Camera Module  The Raspberry Pi camera module is capable of taking full HD 1080p photo and video and can be controlled programmatically  Libraries are available for:  Bash  (Linux command line)  Python      Webcams  Using a standard USB webcam instead of the Raspberry Pi camera module    Kodi  Installing media centre software on your Raspberry Pi    Playing audio  Playing audio on your Raspberry Pi    Playing video  Playing video on your Raspberry Pi    Demo programs  A selection of examples to demonstrate the Pi's capabilities",
            "title": "Contents"
        },
        {
            "location": "/usage/audio/README/index.html",
            "text": "Playing audio on the Raspberry Pi\n\n\nTo play an MP3 file, navigate to the location of the \n.mp3\n file in the terminal using \ncd\n and then type the following command: \n\n\nomxplayer example.mp3\n\n\n\n\n\nThis will play the audio file \nexample.mp3\n through either your monitor's built-in speakers or your headphones, connected via the headphone jack.\n\n\nIf you need an example file you can download one from here using the following command:\n\n\nwget http://rpf.io/lamp3 -O example.mp3 --no-check-certificate\n\n\n\n\n\nIf you cannot hear anything, make sure your headphones or speakers are connected correctly. Note that omxplayer doesn't use ALSA and so ignores the \naudio configuration\n set by \nraspi-config\n or \namixer\n.\n\n\nIf omxplayer's auto-detection of the correct audio output device fails, you can force output over HDMI with:\n\n\nomxplayer -o hdmi example.mp3\n\n\n\n\n\nAlternatively, you can force output over the headphone jack with:\n\n\nomxplayer -o \nlocal\n example.mp3\n\n\n\n\n\nYou can even force output over both the headphone jack and HDMI with:\n\n\nomxplayer -o both example.mp3",
            "title": "Playing audio on the Raspberry Pi"
        },
        {
            "location": "/usage/audio/README/index.html#playing-audio-on-the-raspberry-pi",
            "text": "To play an MP3 file, navigate to the location of the  .mp3  file in the terminal using  cd  and then type the following command:   omxplayer example.mp3  This will play the audio file  example.mp3  through either your monitor's built-in speakers or your headphones, connected via the headphone jack.  If you need an example file you can download one from here using the following command:  wget http://rpf.io/lamp3 -O example.mp3 --no-check-certificate  If you cannot hear anything, make sure your headphones or speakers are connected correctly. Note that omxplayer doesn't use ALSA and so ignores the  audio configuration  set by  raspi-config  or  amixer .  If omxplayer's auto-detection of the correct audio output device fails, you can force output over HDMI with:  omxplayer -o hdmi example.mp3  Alternatively, you can force output over the headphone jack with:  omxplayer -o  local  example.mp3  You can even force output over both the headphone jack and HDMI with:  omxplayer -o both example.mp3",
            "title": "Playing audio on the Raspberry Pi"
        },
        {
            "location": "/usage/camera/README/index.html",
            "text": "Camera Module\n\n\nThe Raspberry Pi camera module is capable of taking full HD 1080p photo and video and can be controlled programmatically.\n\n\nConnecting the camera\n\n\nThe flex cable inserts into the connector situated between the Ethernet and HDMI ports, with the silver connectors facing the HDMI port. The flex cable connector should be opened by pulling the tabs on the top of the connector upwards then towards the Ethernet port. The flex cable should be inserted firmly into the connector, with care taken not to bend the flex at too acute an angle. The top part of the connector should then be pushed towards the HDMI connector and down, while the flex cable is held in place.\n\n\nWatch the following video to see a demonstration of the camera being connected:\n\n\n\n\nThe camera may come with a small piece of translucent blue plastic film covering the lens. This is only present to protect the lens while it is being mailed to you, and needs to be removed by gently peeling it off.\n\n\nEnabling the camera\n\n\nOpen the \nraspi-config\n tool from the Terminal:\n\n\nsudo raspi-config\n\n\n\n\n\nSelect \nEnable camera\n and hit \nEnter\n, then go to \nFinish\n and you'll be prompted to reboot.\n\n\nUsing the camera\n\n\nLibraries for using the camera are available in:\n\n\n\n\nShell\n (Linux command line)\n\n\nPython\n\n\n\n\nSee detailed \ntechnical specs\n of the camera hardware and software.",
            "title": "Camera Module"
        },
        {
            "location": "/usage/camera/README/index.html#camera-module",
            "text": "The Raspberry Pi camera module is capable of taking full HD 1080p photo and video and can be controlled programmatically.",
            "title": "Camera Module"
        },
        {
            "location": "/usage/camera/README/index.html#connecting-the-camera",
            "text": "The flex cable inserts into the connector situated between the Ethernet and HDMI ports, with the silver connectors facing the HDMI port. The flex cable connector should be opened by pulling the tabs on the top of the connector upwards then towards the Ethernet port. The flex cable should be inserted firmly into the connector, with care taken not to bend the flex at too acute an angle. The top part of the connector should then be pushed towards the HDMI connector and down, while the flex cable is held in place.  Watch the following video to see a demonstration of the camera being connected:   The camera may come with a small piece of translucent blue plastic film covering the lens. This is only present to protect the lens while it is being mailed to you, and needs to be removed by gently peeling it off.",
            "title": "Connecting the camera"
        },
        {
            "location": "/usage/camera/README/index.html#enabling-the-camera",
            "text": "Open the  raspi-config  tool from the Terminal:  sudo raspi-config  Select  Enable camera  and hit  Enter , then go to  Finish  and you'll be prompted to reboot.",
            "title": "Enabling the camera"
        },
        {
            "location": "/usage/camera/README/index.html#using-the-camera",
            "text": "Libraries for using the camera are available in:   Shell  (Linux command line)  Python   See detailed  technical specs  of the camera hardware and software.",
            "title": "Using the camera"
        },
        {
            "location": "/usage/camera/python/README/index.html",
            "text": "Python picamera\n\n\npython-picamera\n is a pure Python interface to the Raspberry Pi camera module for Python 2.7 (or above) or Python 3.2 (or above). The library is written and maintained by \nDave Jones\n.\n\n\nAlso see the \ncamera setup\n page.\n\n\nEnable the camera\n\n\nRun \nsudo raspi-config\n and choose in the menu to enable the pi camera. A reboot is needed after this.\n\n\nInstallation\n\n\nThe \npython-picamera\n library is available in the Raspbian archives. Install with \napt\n:\n\n\nsudo apt-get update\nsudo apt-get install python-picamera\n\n\n\n\n\nAlternatively, the Python3 package is installed with \nsudo apt-get install python3-picamera\n. An offline version of the \ndocumentation\n is available with \nsudo apt-get install python-picamera-docs\n.\n\n\nUsage\n\n\nFirst, at the Python prompt or at the top of a Python script, enter:\n\n\nimport\n \npicamera\n\n\n\n\n\n\nThis will make the library available to the script. Now create an instance of the PiCamera class:\n\n\ncamera\n \n=\n \npicamera\n.\nPiCamera\n()\n\n\n\n\n\n\nAnd take a picture:\n\n\ncamera\n.\ncapture\n(\n'image.jpg'\n)\n\n\n\n\n\n\nHorizontal and Vertical flip\n\n\nLike with the \nraspistill\n command, you can apply a horizontal and vertical flip if your camera is positioned upside-down. This is done by changing the \nhflip\n and \nvflip\n properties directly:\n\n\ncamera\n.\nhflip\n \n=\n \nTrue\n\n\ncamera\n.\nvflip\n \n=\n \nTrue\n\n\n\n\n\n\nBe sure to use an upper case \nT\n in \nTrue\n as this is a keyword in Python.\n\n\nPreview\n\n\nYou can display a preview showing the camera feed on screen. Warning: this will overlay your Python session by default; if you have trouble stopping the preview, simply pressing \nCtrl+D\n to terminate the Python session is usually enough to restore the display:\n\n\ncamera\n.\nstart_preview\n()\n\n\n\n\n\n\nYou can use the \nstop_preview\n method to remove the preview overlay and restore the display:\n\n\ncamera\n.\nstop_preview\n()\n\n\n\n\n\n\nAlternatively, you can access the Pi using \nSSH\n from another computer, open a Python prompt and enter these commands, displaying the preview on the monitor connected to the Pi (not the computer you're connected from).\n\n\nCamera settings\n\n\nYou can change other camera configuration by editing property values, for example:\n\n\ncamera\n.\nbrightness\n \n=\n \n70\n\n\n\n\n\n\nThis will change the brightness setting from its default \n50\n to \n70\n (values between 0 and 100).\n\n\nOther settings are available. Here is a list with their default values:\n\n\ncamera\n.\nsharpness\n \n=\n \n0\n\n\ncamera\n.\ncontrast\n \n=\n \n0\n\n\ncamera\n.\nbrightness\n \n=\n \n50\n\n\ncamera\n.\nsaturation\n \n=\n \n0\n\n\ncamera\n.\nISO\n \n=\n \n0\n\n\ncamera\n.\nvideo_stabilization\n \n=\n \nFalse\n\n\ncamera\n.\nexposure_compensation\n \n=\n \n0\n\n\ncamera\n.\nexposure_mode\n \n=\n \n'auto'\n\n\ncamera\n.\nmeter_mode\n \n=\n \n'average'\n\n\ncamera\n.\nawb_mode\n \n=\n \n'auto'\n\n\ncamera\n.\nimage_effect\n \n=\n \n'none'\n\n\ncamera\n.\ncolor_effects\n \n=\n \nNone\n\n\ncamera\n.\nrotation\n \n=\n \n0\n\n\ncamera\n.\nhflip\n \n=\n \nFalse\n\n\ncamera\n.\nvflip\n \n=\n \nFalse\n\n\ncamera\n.\ncrop\n \n=\n \n(\n0.0\n,\n \n0.0\n,\n \n1.0\n,\n \n1.0\n)\n\n\n\n\n\n\nSleep\n\n\nYou can add pauses between commands using \nsleep\n from the \ntime\n module:\n\n\nimport\n \npicamera\n\n\nfrom\n \ntime\n \nimport\n \nsleep\n\n\n\ncamera\n \n=\n \npicamera\n.\nPiCamera\n()\n\n\n\ncamera\n.\ncapture\n(\n'image1.jpg'\n)\n\n\nsleep\n(\n5\n)\n\n\ncamera\n.\ncapture\n(\n'image2.jpg'\n)\n\n\n\n\n\n\nYou can also use \nsleep\n in a preview to adjust settings over time:\n\n\ncamera\n.\nstart_preview\n()\n\n\n\nfor\n \ni\n \nin\n \nrange\n(\n100\n):\n\n    \ncamera\n.\nbrightness\n \n=\n \ni\n\n    \nsleep\n(\n0.2\n)\n\n\n\n\n\n\nVideo recording\n\n\nRecord 5 seconds of video:\n\n\ncamera\n.\nstart_recording\n(\n'video.h264'\n)\n\n\nsleep\n(\n5\n)\n\n\ncamera\n.\nstop_recording\n()\n\n\n\n\n\n\nDocumentation\n\n\nFull documentation for \npython-picamera\n is available at \npicamera.readthedocs.org\n\n\nDevelopment\n\n\nThe \npython-picamera\n project is written and maintained by \nDave Jones\n and the source can be found at \ngithub.com/waveform80/picamera\n where you can open issues or contribute to the project.",
            "title": "Python picamera"
        },
        {
            "location": "/usage/camera/python/README/index.html#python-picamera",
            "text": "python-picamera  is a pure Python interface to the Raspberry Pi camera module for Python 2.7 (or above) or Python 3.2 (or above). The library is written and maintained by  Dave Jones .  Also see the  camera setup  page.",
            "title": "Python picamera"
        },
        {
            "location": "/usage/camera/python/README/index.html#enable-the-camera",
            "text": "Run  sudo raspi-config  and choose in the menu to enable the pi camera. A reboot is needed after this.",
            "title": "Enable the camera"
        },
        {
            "location": "/usage/camera/python/README/index.html#installation",
            "text": "The  python-picamera  library is available in the Raspbian archives. Install with  apt :  sudo apt-get update\nsudo apt-get install python-picamera  Alternatively, the Python3 package is installed with  sudo apt-get install python3-picamera . An offline version of the  documentation  is available with  sudo apt-get install python-picamera-docs .",
            "title": "Installation"
        },
        {
            "location": "/usage/camera/python/README/index.html#usage",
            "text": "First, at the Python prompt or at the top of a Python script, enter:  import   picamera   This will make the library available to the script. Now create an instance of the PiCamera class:  camera   =   picamera . PiCamera ()   And take a picture:  camera . capture ( 'image.jpg' )",
            "title": "Usage"
        },
        {
            "location": "/usage/camera/python/README/index.html#horizontal-and-vertical-flip",
            "text": "Like with the  raspistill  command, you can apply a horizontal and vertical flip if your camera is positioned upside-down. This is done by changing the  hflip  and  vflip  properties directly:  camera . hflip   =   True  camera . vflip   =   True   Be sure to use an upper case  T  in  True  as this is a keyword in Python.",
            "title": "Horizontal and Vertical flip"
        },
        {
            "location": "/usage/camera/python/README/index.html#preview",
            "text": "You can display a preview showing the camera feed on screen. Warning: this will overlay your Python session by default; if you have trouble stopping the preview, simply pressing  Ctrl+D  to terminate the Python session is usually enough to restore the display:  camera . start_preview ()   You can use the  stop_preview  method to remove the preview overlay and restore the display:  camera . stop_preview ()   Alternatively, you can access the Pi using  SSH  from another computer, open a Python prompt and enter these commands, displaying the preview on the monitor connected to the Pi (not the computer you're connected from).",
            "title": "Preview"
        },
        {
            "location": "/usage/camera/python/README/index.html#camera-settings",
            "text": "You can change other camera configuration by editing property values, for example:  camera . brightness   =   70   This will change the brightness setting from its default  50  to  70  (values between 0 and 100).  Other settings are available. Here is a list with their default values:  camera . sharpness   =   0  camera . contrast   =   0  camera . brightness   =   50  camera . saturation   =   0  camera . ISO   =   0  camera . video_stabilization   =   False  camera . exposure_compensation   =   0  camera . exposure_mode   =   'auto'  camera . meter_mode   =   'average'  camera . awb_mode   =   'auto'  camera . image_effect   =   'none'  camera . color_effects   =   None  camera . rotation   =   0  camera . hflip   =   False  camera . vflip   =   False  camera . crop   =   ( 0.0 ,   0.0 ,   1.0 ,   1.0 )",
            "title": "Camera settings"
        },
        {
            "location": "/usage/camera/python/README/index.html#sleep",
            "text": "You can add pauses between commands using  sleep  from the  time  module:  import   picamera  from   time   import   sleep  camera   =   picamera . PiCamera ()  camera . capture ( 'image1.jpg' )  sleep ( 5 )  camera . capture ( 'image2.jpg' )   You can also use  sleep  in a preview to adjust settings over time:  camera . start_preview ()  for   i   in   range ( 100 ): \n     camera . brightness   =   i \n     sleep ( 0.2 )",
            "title": "Sleep"
        },
        {
            "location": "/usage/camera/python/README/index.html#video-recording",
            "text": "Record 5 seconds of video:  camera . start_recording ( 'video.h264' )  sleep ( 5 )  camera . stop_recording ()",
            "title": "Video recording"
        },
        {
            "location": "/usage/camera/python/README/index.html#documentation",
            "text": "Full documentation for  python-picamera  is available at  picamera.readthedocs.org",
            "title": "Documentation"
        },
        {
            "location": "/usage/camera/python/README/index.html#development",
            "text": "The  python-picamera  project is written and maintained by  Dave Jones  and the source can be found at  github.com/waveform80/picamera  where you can open issues or contribute to the project.",
            "title": "Development"
        },
        {
            "location": "/usage/camera/raspicam/README/index.html",
            "text": "raspicam commands\n\n\nraspistill\n, \nraspivid\n and \nraspiyuv\n are command line tools for using the camera module.\n\n\nBasic usage\n\n\nSee guides for basic usage of each of the commands:\n\n\n\n\nraspistill\n\n\nCapturing still photographs with the camera module\n\n\n\n\n\n\nraspivid\n\n\nCapturing video with the camera module\n\n\n\n\n\n\nTime-lapse\n\n\nTaking pictures at regular intervals and stitching them together in to a video\n\n\n\n\n\n\nraspiyuv\n\n\nCapturing still photographs and generating raw unprocessed image files\n\n\n\n\n\n\n\n\nFull documentation\n\n\nFull documentation of the camera can be found at \nraspbian/applications/camera\n and \nhardware/camera\n.",
            "title": "raspicam commands"
        },
        {
            "location": "/usage/camera/raspicam/README/index.html#raspicam-commands",
            "text": "raspistill ,  raspivid  and  raspiyuv  are command line tools for using the camera module.",
            "title": "raspicam commands"
        },
        {
            "location": "/usage/camera/raspicam/README/index.html#basic-usage",
            "text": "See guides for basic usage of each of the commands:   raspistill  Capturing still photographs with the camera module    raspivid  Capturing video with the camera module    Time-lapse  Taking pictures at regular intervals and stitching them together in to a video    raspiyuv  Capturing still photographs and generating raw unprocessed image files",
            "title": "Basic usage"
        },
        {
            "location": "/usage/camera/raspicam/README/index.html#full-documentation",
            "text": "Full documentation of the camera can be found at  raspbian/applications/camera  and  hardware/camera .",
            "title": "Full documentation"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html",
            "text": "raspistill\n\n\nraspistill\n is the command line tool for capturing still photographs with the camera module.\n\n\nBasic usage of raspistill\n\n\nWith the camera module \nconnected and enabled\n, enter the following command in the Terminal to take a picture:\n\n\nraspistill -o cam.jpg\n\n\n\n\n\n\n\nIn this example the camera has been positioned upside-down. If the camera is placed in this position, the image must be flipped to appear the right way up.\n\n\nVertical Flip & Horizontal Flip\n\n\nWith the camera placed upside-down, the image must be rotated 180\u00b0 to be displayed correctly. The way to correct for this is to apply both a vertical and a horizontal flip by passing in the \n-vf\n and \n-hf\n flags:\n\n\nraspistill -vf -hf -o cam2.jpg\n\n\n\n\n\n\n\nNow the photo has been captured correctly.\n\n\nResolution\n\n\nThe camera module takes pictures at a resolution of \n2592 x 1944\n which is 5,038,848 pixels or 5 megapixels.\n\n\nFile size\n\n\nA photo taken with the camera module will be around 2.4MB. This is about 425 photos per GB.\n\n\nTaking 1 photo per minute would take up 1GB in about 7 hours. This is a rate of about 144MB per hour or 3.3GB per day.\n\n\nBash script\n\n\nYou can create a Bash script which takes a picture with the camera. To create a script, open up your editor of choice and write the following example code:\n\n\n#!/bin/bash\n\n\n\nDATE\n=\n$(\ndate +\n\"%Y-%m-%d_%H%M\"\n)\n\n\nraspistill -vf -hf -o /home/pi/camera/\n$DATE\n.jpg\n\n\n\n\n\nThis script will take a picture and name the file with a timestamp.\n\n\nYou'll also need to make sure the path exists by creating the \ncamera\n folder:\n\n\nmkdir camera\n\n\n\n\n\nSay we saved it as \ncamera.sh\n, we would first make the file executable:\n\n\nchmod +x camera.sh\n\n\n\n\n\nThen run with:\n\n\n./camera.sh\n\n\n\n\n\nMore options\n\n\nFor a full list of possible options, run \nraspistill\n with no arguments. To scroll, redirect stderr to stdout and pipe the output to \nless\n:\n\n\nraspistill \n2\n>\n&\n1\n \n|\n less\n\n\n\n\n\nUse the arrow keys to scroll and type \nq\n to exit.\n\n\nFull documentation\n\n\nFull documentation of the camera can be found at \nhardware/camera\n.",
            "title": "raspistill"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#raspistill",
            "text": "raspistill  is the command line tool for capturing still photographs with the camera module.",
            "title": "raspistill"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#basic-usage-of-raspistill",
            "text": "With the camera module  connected and enabled , enter the following command in the Terminal to take a picture:  raspistill -o cam.jpg   In this example the camera has been positioned upside-down. If the camera is placed in this position, the image must be flipped to appear the right way up.",
            "title": "Basic usage of raspistill"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#vertical-flip-horizontal-flip",
            "text": "With the camera placed upside-down, the image must be rotated 180\u00b0 to be displayed correctly. The way to correct for this is to apply both a vertical and a horizontal flip by passing in the  -vf  and  -hf  flags:  raspistill -vf -hf -o cam2.jpg   Now the photo has been captured correctly.",
            "title": "Vertical Flip &amp; Horizontal Flip"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#resolution",
            "text": "The camera module takes pictures at a resolution of  2592 x 1944  which is 5,038,848 pixels or 5 megapixels.",
            "title": "Resolution"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#file-size",
            "text": "A photo taken with the camera module will be around 2.4MB. This is about 425 photos per GB.  Taking 1 photo per minute would take up 1GB in about 7 hours. This is a rate of about 144MB per hour or 3.3GB per day.",
            "title": "File size"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#bash-script",
            "text": "You can create a Bash script which takes a picture with the camera. To create a script, open up your editor of choice and write the following example code:  #!/bin/bash  DATE = $( date + \"%Y-%m-%d_%H%M\" ) \n\nraspistill -vf -hf -o /home/pi/camera/ $DATE .jpg  This script will take a picture and name the file with a timestamp.  You'll also need to make sure the path exists by creating the  camera  folder:  mkdir camera  Say we saved it as  camera.sh , we would first make the file executable:  chmod +x camera.sh  Then run with:  ./camera.sh",
            "title": "Bash script"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#more-options",
            "text": "For a full list of possible options, run  raspistill  with no arguments. To scroll, redirect stderr to stdout and pipe the output to  less :  raspistill  2 > & 1   |  less  Use the arrow keys to scroll and type  q  to exit.",
            "title": "More options"
        },
        {
            "location": "/usage/camera/raspicam/raspistill/index.html#full-documentation",
            "text": "Full documentation of the camera can be found at  hardware/camera .",
            "title": "Full documentation"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html",
            "text": "raspivid\n\n\nraspivid\n is the command line tool for capturing video with the camera module.\n\n\nBasic usage of raspivid\n\n\nWith the camera module \nconnected and enabled\n, record a video using the following command:\n\n\nraspivid -o vid.h264\n\n\n\n\n\nRemember to use \n-hf\n and \n-vf\n to flip the image if required, like with \nraspistill\n\n\nThis will save a 5 second video file to the path given here as \nvid.h264\n (default length of time).\n\n\nSpecify length of video\n\n\nTo specify the length of the video taken, pass in the \n-t\n flag with a number of milliseconds. For example:\n\n\nraspivid -o video.h264 -t \n10000\n\n\n\n\n\n\nThis will record 10 seconds of video.\n\n\nMore options\n\n\nFor a full list of possible options, run \nraspivid\n with no arguments, or pipe this command through \nless\n and scroll through:\n\n\nraspivid \n2\n>\n&\n1\n \n|\n less\n\n\n\n\n\nUse the arrow keys to scroll and type \nq\n to exit.\n\n\nMP4 Video Format\n\n\nThe Pi captures video as a raw H264 video stream. Many media players will refuse to play it, or play it at an incorrect speed, unless it is \"wrapped\" in a suitable container format like MP4. The easiest way to obtain an MP4 file from the raspivid command is using MP4Box.\n\n\nInstall MP4Box with this command:\n\n\nsudo apt-get install -y gpac\n\n\n\n\n\nCapture your raw video with raspivid and wrap it in an MP4 container like this:\n\n\n# Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file:\n\nraspivid -t \n30000\n -w \n640\n -h \n480\n -fps \n25\n -b \n1200000\n -p \n0\n,0,640,480 -o pivideo.h264 \n\n# Wrap the raw video with an MP4 container: \n\nMP4Box -add pivideo.h264 pivideo.mp4\n\n# Remove the source raw file, leaving the remaining pivideo.mp4 file to play\n\nrm pivideo.h264\n\n\n\n\n\nAlternatively, wrap MP4 around your existing raspivid output, like this:\n\n\nMP4Box -add video.h264 video.mp4\n\n\n\n\n\nFull documentation\n\n\nFull documentation of the camera can be found at \nhardware/camera\n.",
            "title": "raspivid"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#raspivid",
            "text": "raspivid  is the command line tool for capturing video with the camera module.",
            "title": "raspivid"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#basic-usage-of-raspivid",
            "text": "With the camera module  connected and enabled , record a video using the following command:  raspivid -o vid.h264  Remember to use  -hf  and  -vf  to flip the image if required, like with  raspistill  This will save a 5 second video file to the path given here as  vid.h264  (default length of time).",
            "title": "Basic usage of raspivid"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#specify-length-of-video",
            "text": "To specify the length of the video taken, pass in the  -t  flag with a number of milliseconds. For example:  raspivid -o video.h264 -t  10000   This will record 10 seconds of video.",
            "title": "Specify length of video"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#more-options",
            "text": "For a full list of possible options, run  raspivid  with no arguments, or pipe this command through  less  and scroll through:  raspivid  2 > & 1   |  less  Use the arrow keys to scroll and type  q  to exit.",
            "title": "More options"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#mp4-video-format",
            "text": "The Pi captures video as a raw H264 video stream. Many media players will refuse to play it, or play it at an incorrect speed, unless it is \"wrapped\" in a suitable container format like MP4. The easiest way to obtain an MP4 file from the raspivid command is using MP4Box.  Install MP4Box with this command:  sudo apt-get install -y gpac  Capture your raw video with raspivid and wrap it in an MP4 container like this:  # Capture 30 seconds of raw video at 640x480 and 150kB/s bit rate into a pivideo.h264 file: \nraspivid -t  30000  -w  640  -h  480  -fps  25  -b  1200000  -p  0 ,0,640,480 -o pivideo.h264  # Wrap the raw video with an MP4 container:  \nMP4Box -add pivideo.h264 pivideo.mp4 # Remove the source raw file, leaving the remaining pivideo.mp4 file to play \nrm pivideo.h264  Alternatively, wrap MP4 around your existing raspivid output, like this:  MP4Box -add video.h264 video.mp4",
            "title": "MP4 Video Format"
        },
        {
            "location": "/usage/camera/raspicam/raspivid/index.html#full-documentation",
            "text": "Full documentation of the camera can be found at  hardware/camera .",
            "title": "Full documentation"
        },
        {
            "location": "/usage/camera/raspicam/raspiyuv/index.html",
            "text": "raspiyuv\n\n\nraspiyuv\n has the same set of features as \nraspistill\n but instead of outputting standard image files such as \n.jpg\ns, it generates raw unprocessed image files from the camera.\n\n\nFull documentation\n\n\nFull documentation of the camera can be found at \nhardware/camera\n.",
            "title": "raspiyuv"
        },
        {
            "location": "/usage/camera/raspicam/raspiyuv/index.html#raspiyuv",
            "text": "raspiyuv  has the same set of features as  raspistill  but instead of outputting standard image files such as  .jpg s, it generates raw unprocessed image files from the camera.",
            "title": "raspiyuv"
        },
        {
            "location": "/usage/camera/raspicam/raspiyuv/index.html#full-documentation",
            "text": "Full documentation of the camera can be found at  hardware/camera .",
            "title": "Full documentation"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html",
            "text": "Time-lapse\n\n\nTo create a time-lapse video, you simply configure the Raspberry Pi to take a picture at a regular interval, such as every minute, then use an application to stitch the pictures together into a video.\n\n\nThere are a couple of ways of doing this.\n\n\nUsing Raspistill's inbuilt time-lapse mode\n\n\nThe raspistill application has a built in time-lapse mode, using the \n--timelapse\n (or \n-tl\n) command line switch.\n\n\nThe value that follows the switch is the time between shots in milliseconds.\n\n\nraspistill -t 30000 -tl 2000 -o image%04d.jpg\n\n\n\n\n\nNote the \n%04d\n in the output filename: this indicates the point in the filename where you want a frame count number to appear. So, for example, the command above will produce a capture every two seconds (2000ms), over a total period of 30 seconds (30000ms), named image0001.jpg, image0002.jpg, and so on, through to image0015.jpg.\n\n\nThe \n%04d\n indicates a four-digit number, with leading zeroes added to make up the required number of digits. So, for example, \n%08d\n would result in an eight-digit number. You can miss out the \n0\n if you don't want leading zeroes.\n\n\nIf a timelapse value of 0 is entered, the application will take pictures as fast as possible. Note that there's an minimum enforced pause of approximately 30 milliseconds between captures to ensure that exposure calculations can be made.\n\n\nUsing cron\n\n\nA good way to automate taking a picture at a regular interval is using \ncron\n.\n\n\nOpen the cron table for editing:\n\n\ncrontab -e\n\n\n\n\n\nThis will either ask which editor you would like to use, or open in your default editor. Once you have the file open in an editor, add the following line to schedule taking a picture every minute (referring to the Bash script from the \nprevious page\n):\n\n\n* * * * * /home/pi/camera.sh 2>&1\n\n\n\n\n\nSave and exit and you should see the message:\n\n\ncrontab\n:\n \ninstalling\n \nnew\n \ncrontab\n\n\n\n\n\n\nEnsure your script does not save each picture taken with the same filename. This will overwrite the picture each time.\n\n\nStitching images together\n\n\nNow you'll need to stitch the photos together into a video.\n\n\nYou can do this on the Pi using \nmencoder\n but the processing will be slow. You may prefer to transfer the image files to your desktop computer or laptop and processing the video there.\n\n\nNavigate to the folder containing all your images and list the file names in to a text file. For example:\n\n\nls *.jpg > stills.txt\n\n\n\n\n\nOn the Raspberry Pi\n\n\nAlthough it will be slow (due to encoding in software rather than using the Raspberry Pi hardware acceleration), you can stitch your JPEG images together using various available tools. This documentation will use \navconv\n, which needs to be installed.\n\n\nsudo apt-get install libav-tools\n\n\n\n\n\nNow you can use the tools to convert your JPEG files in to an H264 video file.\n\n\navconv -r 10 -i image%04d.jpg -r 10 -vcodec libx264 -vf scale=1280:720 timelapse.mp4\n\n\n\n\n\nOn a Raspberry Pi 3, this can encode a little more than one frame per second. The performance of other Pi models will vary. The parameters used are:\n\n\n\n\n-r 10 Assume ten frames per second in input and output files.\n\n\n-i image%04.jpg The input file specification (to match the files produced during the capture).\n\n\n-vcodec libx264 Use the software x264 encoder.\n\n\n-vf scale=1280:720 Scale to 720p. You can also use 1920:1080, or lower resolutions, depending on your requirements. Note the Pi can only play back up to 1080p video, but if you are intending to play back at, for example, 4K, you could set that here.\n\n\ntimelapse.mp4 The name of the output file.\n\n\n\n\navconv\n has a comprehensive parameter set for varying encoding options and other settings. These can be listed using \navconv --help\n.\n\n\nOn another Linux computer\n\n\nYou can use the same instructions as for the Raspberry Pi, or an alternative package such as \nmencoder\n:\n\n\nsudo apt-get install mencoder\n\n\n\n\n\nNow run the following command:\n\n\nmencoder -nosound -ovc lavc -lavcopts vcodec=mpeg4:aspect=16/9:vbitrate=8000000 -vf scale=1920:1080 -o timelapse.avi -mf type=jpeg:fps=24 mf://@stills.txt\n\n\n\n\n\nOnce that's completed, you should have a video file called \ntimelapse.avi\n containing a time-lapse from your images.",
            "title": "Time-lapse"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#time-lapse",
            "text": "To create a time-lapse video, you simply configure the Raspberry Pi to take a picture at a regular interval, such as every minute, then use an application to stitch the pictures together into a video.  There are a couple of ways of doing this.",
            "title": "Time-lapse"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#using-raspistills-inbuilt-time-lapse-mode",
            "text": "The raspistill application has a built in time-lapse mode, using the  --timelapse  (or  -tl ) command line switch.  The value that follows the switch is the time between shots in milliseconds.  raspistill -t 30000 -tl 2000 -o image%04d.jpg  Note the  %04d  in the output filename: this indicates the point in the filename where you want a frame count number to appear. So, for example, the command above will produce a capture every two seconds (2000ms), over a total period of 30 seconds (30000ms), named image0001.jpg, image0002.jpg, and so on, through to image0015.jpg.  The  %04d  indicates a four-digit number, with leading zeroes added to make up the required number of digits. So, for example,  %08d  would result in an eight-digit number. You can miss out the  0  if you don't want leading zeroes.  If a timelapse value of 0 is entered, the application will take pictures as fast as possible. Note that there's an minimum enforced pause of approximately 30 milliseconds between captures to ensure that exposure calculations can be made.",
            "title": "Using Raspistill's inbuilt time-lapse mode"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#using-cron",
            "text": "A good way to automate taking a picture at a regular interval is using  cron .  Open the cron table for editing:  crontab -e  This will either ask which editor you would like to use, or open in your default editor. Once you have the file open in an editor, add the following line to schedule taking a picture every minute (referring to the Bash script from the  previous page ):  * * * * * /home/pi/camera.sh 2>&1  Save and exit and you should see the message:  crontab :   installing   new   crontab   Ensure your script does not save each picture taken with the same filename. This will overwrite the picture each time.",
            "title": "Using cron"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#stitching-images-together",
            "text": "Now you'll need to stitch the photos together into a video.  You can do this on the Pi using  mencoder  but the processing will be slow. You may prefer to transfer the image files to your desktop computer or laptop and processing the video there.  Navigate to the folder containing all your images and list the file names in to a text file. For example:  ls *.jpg > stills.txt",
            "title": "Stitching images together"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#on-the-raspberry-pi",
            "text": "Although it will be slow (due to encoding in software rather than using the Raspberry Pi hardware acceleration), you can stitch your JPEG images together using various available tools. This documentation will use  avconv , which needs to be installed.  sudo apt-get install libav-tools  Now you can use the tools to convert your JPEG files in to an H264 video file.  avconv -r 10 -i image%04d.jpg -r 10 -vcodec libx264 -vf scale=1280:720 timelapse.mp4  On a Raspberry Pi 3, this can encode a little more than one frame per second. The performance of other Pi models will vary. The parameters used are:   -r 10 Assume ten frames per second in input and output files.  -i image%04.jpg The input file specification (to match the files produced during the capture).  -vcodec libx264 Use the software x264 encoder.  -vf scale=1280:720 Scale to 720p. You can also use 1920:1080, or lower resolutions, depending on your requirements. Note the Pi can only play back up to 1080p video, but if you are intending to play back at, for example, 4K, you could set that here.  timelapse.mp4 The name of the output file.   avconv  has a comprehensive parameter set for varying encoding options and other settings. These can be listed using  avconv --help .",
            "title": "On the Raspberry Pi"
        },
        {
            "location": "/usage/camera/raspicam/timelapse/index.html#on-another-linux-computer",
            "text": "You can use the same instructions as for the Raspberry Pi, or an alternative package such as  mencoder :  sudo apt-get install mencoder  Now run the following command:  mencoder -nosound -ovc lavc -lavcopts vcodec=mpeg4:aspect=16/9:vbitrate=8000000 -vf scale=1920:1080 -o timelapse.avi -mf type=jpeg:fps=24 mf://@stills.txt  Once that's completed, you should have a video file called  timelapse.avi  containing a time-lapse from your images.",
            "title": "On another Linux computer"
        },
        {
            "location": "/usage/demos/README/index.html",
            "text": "Demo Programs\n\n\nHere are some example programs to demonstrate the Pi's capabilities.\n\n\n\n\nIn order to run these programs you need to be at the command line. Your Pi may boot to the command line (requiring you to enter \nstartx\n to get to the desktop); if so, go straight ahead. Otherwise, use the start button to log out of the desktop.\n\n\npi@raspberrypi ~ $\n\n\n\n\n\nThis (above) is the command prompt. It looks difficult to use, but try not to be afraid of it! A CLI or command line interface is actually a very quick and efficient way to use a computer.\n\n\nTo start, navigate to the \nhello_pi\n folder where all the demos are stored. Enter the command below to do this. \nTIP\n: You can use the \nTAB\n key for auto-complete as you enter commands.\n\n\ncd\n /opt/vc/src/hello_pi\n\n\n\n\n\nThe command prompt should now look like the text below. The blue part shows where you are in the file system of the Pi.\n\n\npi@raspberrypi /opt/vc/src/hello_pi $\n\n\n\n\n\nIf you enter \nls\n and press Enter, you\u2019ll see a list of folders; there is one for each demo. Before you can run them, though, they must be compiled. Don\u2019t worry if you don\u2019t understand what this is or why you need to do it; just follow the instructions for now, and we'll learn more about it later on.\n\n\nThere is a small shell script supplied in the \nhello_pi\n folder called rebuild.sh which will do the compiling for you. Enter the following command to run it; ignore the gobbledygook for now!\n\n\n./rebuild.sh\n\n\n\n\n\nA lot of text will scroll up the screen now, but for this exercise you can ignore it. It is just the output of the compiler as it works through the demo code. Wait for the command prompt to return before you continue.\n\n\nNow we\u2019re finally ready to run some demos!\n\n\nDemo programs:\n\n\n\n\nHello world\n\n\nHello video\n\n\nHello triangle\n\n\nHello fractal\n\n\nHello teapot\n\n\nHello audio\n\n\n\n\nTry more demos in the \nhello_pi\n folder!",
            "title": "Demo Programs"
        },
        {
            "location": "/usage/demos/README/index.html#demo-programs",
            "text": "Here are some example programs to demonstrate the Pi's capabilities.   In order to run these programs you need to be at the command line. Your Pi may boot to the command line (requiring you to enter  startx  to get to the desktop); if so, go straight ahead. Otherwise, use the start button to log out of the desktop.  pi@raspberrypi ~ $  This (above) is the command prompt. It looks difficult to use, but try not to be afraid of it! A CLI or command line interface is actually a very quick and efficient way to use a computer.  To start, navigate to the  hello_pi  folder where all the demos are stored. Enter the command below to do this.  TIP : You can use the  TAB  key for auto-complete as you enter commands.  cd  /opt/vc/src/hello_pi  The command prompt should now look like the text below. The blue part shows where you are in the file system of the Pi.  pi@raspberrypi /opt/vc/src/hello_pi $  If you enter  ls  and press Enter, you\u2019ll see a list of folders; there is one for each demo. Before you can run them, though, they must be compiled. Don\u2019t worry if you don\u2019t understand what this is or why you need to do it; just follow the instructions for now, and we'll learn more about it later on.  There is a small shell script supplied in the  hello_pi  folder called rebuild.sh which will do the compiling for you. Enter the following command to run it; ignore the gobbledygook for now!  ./rebuild.sh  A lot of text will scroll up the screen now, but for this exercise you can ignore it. It is just the output of the compiler as it works through the demo code. Wait for the command prompt to return before you continue.  Now we\u2019re finally ready to run some demos!  Demo programs:   Hello world  Hello video  Hello triangle  Hello fractal  Hello teapot  Hello audio   Try more demos in the  hello_pi  folder!",
            "title": "Demo Programs"
        },
        {
            "location": "/usage/demos/hello-audio/index.html",
            "text": "Hello Audio\n\n\nThis demo just demonstrates audio output. It plays a sine wave, which makes a kind of 'WOO WOO WOO' sound.\n\n\ncd\n ..\n\ncd\n hello_audio\nls\n\n\n\n\n\nNotice the green \n.bin\n file? Run it. Are you getting the hang of this now?\n\n\n./hello_audio.bin\n\n\n\n\n\nThis will play the sound over the headphone jack on the Pi. If you're using a HDMI monitor you can make it output over HDMI by adding a \n1\n to the command:\n\n\n./hello_audio.bin \n1\n\n\n\n\n\n\nThe demo will run forever until you quit. To exit the demo press \nCtrl + C\n.",
            "title": "Hello Audio"
        },
        {
            "location": "/usage/demos/hello-audio/index.html#hello-audio",
            "text": "This demo just demonstrates audio output. It plays a sine wave, which makes a kind of 'WOO WOO WOO' sound.  cd  .. cd  hello_audio\nls  Notice the green  .bin  file? Run it. Are you getting the hang of this now?  ./hello_audio.bin  This will play the sound over the headphone jack on the Pi. If you're using a HDMI monitor you can make it output over HDMI by adding a  1  to the command:  ./hello_audio.bin  1   The demo will run forever until you quit. To exit the demo press  Ctrl + C .",
            "title": "Hello Audio"
        },
        {
            "location": "/usage/demos/hello-fractal/index.html",
            "text": "Hello Fractal\n\n\nThis one displays two superimposed fractals, one on top of the other. You can move the mouse to change the shape of the fractal in real time. This is also intended to demonstrate OpenGL ES rendering. Some of you may recognise that this is the \nMandelbrot fractal\n.\n\n\n\n\ncd\n ..\n\ncd\n hello_triangle2\nls\n\n\n\n\n\nNotice the green \n.bin\n file? OK, run it!\n\n\n./hello_triangle2.bin\n\n\n\n\n\nNow move the mouse around, and you\u2019ll see the fractal changing. See if you can get it to form a perfect circle; it\u2019s a little tricky, but it can be done. To exit the demo press \nCtrl + C\n.",
            "title": "Hello Fractal"
        },
        {
            "location": "/usage/demos/hello-fractal/index.html#hello-fractal",
            "text": "This one displays two superimposed fractals, one on top of the other. You can move the mouse to change the shape of the fractal in real time. This is also intended to demonstrate OpenGL ES rendering. Some of you may recognise that this is the  Mandelbrot fractal .   cd  .. cd  hello_triangle2\nls  Notice the green  .bin  file? OK, run it!  ./hello_triangle2.bin  Now move the mouse around, and you\u2019ll see the fractal changing. See if you can get it to form a perfect circle; it\u2019s a little tricky, but it can be done. To exit the demo press  Ctrl + C .",
            "title": "Hello Fractal"
        },
        {
            "location": "/usage/demos/hello-teapot/index.html",
            "text": "Hello Teapot\n\n\nThis displays a spinning teapot with the video clip from \nhello_video\n texture-mapped onto its surface. It's pretty impressive! You may recognise the teapot model if you\u2019re familiar with a piece of software called [Blender] (https://en.wikipedia.org/wiki/Blender_(software)). This demonstrates OpenGL ES rendering and video decoding/playback at the same time.\n\n\n\n\ncd\n ..\n\ncd\n hello_teapot\nls\n\n\n\n\n\nNotice the green \n.bin\n file? OK, run it!\n\n\n./hello_teapot.bin\n\n\n\n\n\nYou may receive the following error when you try to run this demo:  \n\n\nNote: ensure you have sufficient gpu_mem configured\neglCreateImageKHR:  failed to create image \nfor\n buffer 0x1 target \n12465\n error 0x300c\neglCreateImageKHR failed.\n\n\n\n\n\nDon\u2019t worry though; if you see this error, you just need to alter one configuration setting to make it work.  \n\n\nThe error means the GPU (graphics processing unit) does not have enough memory to run the demo. It\u2019s the GPU that does all the heavy lifting when drawing 3D graphics to the screen, a bit like the graphics card in a gaming PC. The Raspberry Pi shares its memory/RAM between the CPU and GPU, and by default is configured to only give 64 MB of RAM to the GPU. If we increase this to 128 MB that should fix the problem.\n\n\nTo do that, you'll need to enter the following command:\n\n\nsudo raspi-config\n\n\n\n\n\nThis will open up a menu on a blue background. Perform the following actions:\n\n\n\n\nGo to Advanced Options.\n\n\nGo to Memory Split.\n\n\nDelete \n64\n and enter \n128\n instead. Press \nenter\n.\n\n\nGo down to Finish.\n\n\nClick Yes to reboot.\n\n\n\n\nAfter you have logged back in, enter the following command to get back to the \nhello_teapot\n demo:\n\n\ncd\n /opt/vc/src/hello_pi/hello_teapot\n\n\n\n\n\nNow try and run it again, and you should find it will work.\n\n\n./hello_teapot.bin\n\n\n\n\n\nThe demo will run forever until you quit. To exit the demo press \nCtrl + C\n.",
            "title": "Hello Teapot"
        },
        {
            "location": "/usage/demos/hello-teapot/index.html#hello-teapot",
            "text": "This displays a spinning teapot with the video clip from  hello_video  texture-mapped onto its surface. It's pretty impressive! You may recognise the teapot model if you\u2019re familiar with a piece of software called [Blender] (https://en.wikipedia.org/wiki/Blender_(software)). This demonstrates OpenGL ES rendering and video decoding/playback at the same time.   cd  .. cd  hello_teapot\nls  Notice the green  .bin  file? OK, run it!  ./hello_teapot.bin  You may receive the following error when you try to run this demo:    Note: ensure you have sufficient gpu_mem configured\neglCreateImageKHR:  failed to create image  for  buffer 0x1 target  12465  error 0x300c\neglCreateImageKHR failed.  Don\u2019t worry though; if you see this error, you just need to alter one configuration setting to make it work.    The error means the GPU (graphics processing unit) does not have enough memory to run the demo. It\u2019s the GPU that does all the heavy lifting when drawing 3D graphics to the screen, a bit like the graphics card in a gaming PC. The Raspberry Pi shares its memory/RAM between the CPU and GPU, and by default is configured to only give 64 MB of RAM to the GPU. If we increase this to 128 MB that should fix the problem.  To do that, you'll need to enter the following command:  sudo raspi-config  This will open up a menu on a blue background. Perform the following actions:   Go to Advanced Options.  Go to Memory Split.  Delete  64  and enter  128  instead. Press  enter .  Go down to Finish.  Click Yes to reboot.   After you have logged back in, enter the following command to get back to the  hello_teapot  demo:  cd  /opt/vc/src/hello_pi/hello_teapot  Now try and run it again, and you should find it will work.  ./hello_teapot.bin  The demo will run forever until you quit. To exit the demo press  Ctrl + C .",
            "title": "Hello Teapot"
        },
        {
            "location": "/usage/demos/hello-triangle/index.html",
            "text": "Hello Triangle\n\n\nThis displays a spinning cube with different images on each side. This is intended to demonstrate OpenGL ES rendering. OpenGL is an open-source programming library for working with 3D graphics.\n\n\nEnter the following commands to navigate to the \nhello_triangle\n folder and list its contents:\n\n\ncd\n ..\n\ncd\n hello_triangle\nls\n\n\n\n\n\nYou\u2019ll see again that one of the files is green; this is the executable file as before. This demo doesn\u2019t need any video input files like the previous one, so you can just go ahead and run the \n.bin\n file:\n\n\n./hello_triangle.bin\n\n\n\n\n\nThe demo will run forever until you decide to quit. To exit the demo press \nCtrl + C\n.",
            "title": "Hello Triangle"
        },
        {
            "location": "/usage/demos/hello-triangle/index.html#hello-triangle",
            "text": "This displays a spinning cube with different images on each side. This is intended to demonstrate OpenGL ES rendering. OpenGL is an open-source programming library for working with 3D graphics.  Enter the following commands to navigate to the  hello_triangle  folder and list its contents:  cd  .. cd  hello_triangle\nls  You\u2019ll see again that one of the files is green; this is the executable file as before. This demo doesn\u2019t need any video input files like the previous one, so you can just go ahead and run the  .bin  file:  ./hello_triangle.bin  The demo will run forever until you decide to quit. To exit the demo press  Ctrl + C .",
            "title": "Hello Triangle"
        },
        {
            "location": "/usage/demos/hello-video/index.html",
            "text": "Hello video\n\n\nThis will play a 15 second long full HD 1080p video clip with no sound. The intention here is to demonstrate video decode and playback capability. You\u2019ll see that the video is very smooth!\n\n\n\n\nEnter the following commands to navigate to the \nhello_video\n folder and list the files:\n\n\ncd\n ..\n\ncd\n hello_video\nls\n\n\n\n\n\nYou\u2019ll notice the \n.bin\n file again. This demo needs to be told what video clip to play when we run it, though, so this must be the \ntest.h264\n file (h264 is a type of video codec).\n\n\nYou'll need the \n./\n to specify the current directory again:\n\n\n./hello_video.bin test.h264\n\n\n\n\n\nYou should now see the video clip play. It is taken from the open source film [Big Buck Bunny] (https://en.wikipedia.org/wiki/Big_Buck_Bunny).",
            "title": "Hello video"
        },
        {
            "location": "/usage/demos/hello-video/index.html#hello-video",
            "text": "This will play a 15 second long full HD 1080p video clip with no sound. The intention here is to demonstrate video decode and playback capability. You\u2019ll see that the video is very smooth!   Enter the following commands to navigate to the  hello_video  folder and list the files:  cd  .. cd  hello_video\nls  You\u2019ll notice the  .bin  file again. This demo needs to be told what video clip to play when we run it, though, so this must be the  test.h264  file (h264 is a type of video codec).  You'll need the  ./  to specify the current directory again:  ./hello_video.bin test.h264  You should now see the video clip play. It is taken from the open source film [Big Buck Bunny] (https://en.wikipedia.org/wiki/Big_Buck_Bunny).",
            "title": "Hello video"
        },
        {
            "location": "/usage/demos/hello-world/index.html",
            "text": "Hello World Demo\n\n\nFirst, let's do a quick test that will ensure the previous compilation step worked correctly. This rather boring program will only display the text \nHello world!\n but if it works correctly then we know all the other demos should work too, and we can make more interesting programs run.\n\n\nEnter the following commands to go inside the \nhello_world\n folder and list the files:\n\n\ncd\n hello_world\nls\n\n\n\n\n\nYou\u2019ll notice the \n.bin\n file is shown in green; this is because it is an executable file. This means that it is the file we run to launch the program.\n\n\nUse the following command to run the demo. You need the \n./\n to specify the current directory; otherwise the Linux system folders will be searched for the filename you type.\n\n\n./hello_world.bin",
            "title": "Hello World Demo"
        },
        {
            "location": "/usage/demos/hello-world/index.html#hello-world-demo",
            "text": "First, let's do a quick test that will ensure the previous compilation step worked correctly. This rather boring program will only display the text  Hello world!  but if it works correctly then we know all the other demos should work too, and we can make more interesting programs run.  Enter the following commands to go inside the  hello_world  folder and list the files:  cd  hello_world\nls  You\u2019ll notice the  .bin  file is shown in green; this is because it is an executable file. This means that it is the file we run to launch the program.  Use the following command to run the demo. You need the  ./  to specify the current directory; otherwise the Linux system folders will be searched for the filename you type.  ./hello_world.bin",
            "title": "Hello World Demo"
        },
        {
            "location": "/usage/gpio/README/index.html",
            "text": "GPIO: Raspberry Pi Models A and B\n\n\nAn introduction to GPIO and physical computing on the Raspberry Pi\n\n\nOne powerful feature of the Raspberry Pi is the row of GPIO (general purpose input/output) pins along the edge of the board, next to the yellow video out socket.\n\n\n\n\nThese pins are a physical interface between the Pi and the outside world. At the simplest level, you can think of them as switches that you can turn on or off (input) or that the Pi can turn on or off (output). Seventeen of the 26 pins are GPIO pins; the others are power or ground pins.\n\n\n\n\nWhat are they for? What can I do with them?\n\n\nYou can program the pins to interact in amazing ways with the real world. Inputs don't have to come from a physical switch; it could be input from a sensor or a signal from another computer or device, for example. The output can also do anything, from turning on an LED to sending a signal or data to another device. If the Raspberry Pi is on a network, you can control devices that are attached to it from anywhere** and those devices can send data back. Connectivity and control of physical devices over the internet is a powerful and exciting thing, and the Raspberry Pi is ideal for this. There are lots of brilliant examples of physical computing on \nour blog\n.\n\n\nNote\n: Not \nliterally\n anywhere, of course. You need things like access to the network, a network capable computing device, and electricity. Please do not write to us to point this out. :)\n\n\nHow the GPIO pins work\n\n\nOutput\n\n\nWARNING\n: If you follow the instructions, then messing about with the GPIO is safe and fun. Randomly plugging wires and power sources into your Pi, however, may kill it. Bad things can also happen if you try to connect things to your Pi that use a lot of power; LEDs are fine, motors are not. If you are worried about this, then you might want to consider using a breakout board such as the \nPibrella\n until you are confident enough to use the GPIO directly.\n\n\nIgnoring the Pi for a moment, one of the simplest electrical circuits that you can build is a battery connected to a light source and a switch (the resistor is there to protect the LED):\n\n\n\n\nWhen we use a GPIO pin as an output, the Raspberry Pi replaces \nboth the switch and the battery\n in the above diagram. Each pin can turn on or off, or go HIGH or LOW in computing terms. When the pin is HIGH it outputs 3.3 volts (3v3); when the pin is LOW it is off.\n\n\nHere's the same circuit using the Raspberry Pi. The LED is connected to a GPIO pin (which can output +3v3) and a ground pin (which is 0v and acts like the negative terminal of the battery):\n\n\n\n\nThe next step is to write a program to tell the pin to go HIGH or LOW. Here's an example using \nPython\n (see Step 2), and here's how to do it in \nScratch\n.\n\n\nInput\n\n\nGPIO \noutputs\n are easy; they are on or off, HIGH or LOW, 3v3 or 0v. \nInputs\n are a bit trickier because of the way that digital devices work. Although it might seem reasonable just to connect a button across an input pin and a ground pin, the Pi can get confused as to whether the button is on or off. It might work properly, it might not. It's a bit like floating about in deep space; without a reference it would be hard to tell if you were going up or down, or even what up or down meant!\n\n\nThis is why you will see phrases like \"pull up\" and \"pull down\" in Raspberry Pi GPIO tutorials. It's a way of giving the input pin a reference so it knows for certain when an input is received.\n\n\nIf you'd like to have a go at using the GPIO as an input then have a look at our \nburping jelly baby\n and \nquick reaction game\n tutorials for Python, or a \nreaction game\n for Scratch.\n\n\nThe end of the guide. The start of something amazing\n\n\nWe hope that this has encouraged you to have a go at physical computing using the Pi's GPIO; it's really not as daunting as it looks. It all starts with a simple LED, but it can take you to incredible places. Do not underestimate the fun, creativity and sense of achievement you can get from a little computer and a bunch of pins. Have fun! And if you do make something cool please let us know. :)\n\n\n\n\nGlossary\n\n\nGPIO\n\n\nGeneral purpose input/output; in this specific case the pins on the Raspberry Pi and what you can do with them. So called because you can use them for all sorts of purposes; most can be used as either inputs or outputs, depending on your program.\n\n\nLED\n\n\nLight-emitting diode- a small, low-power light source used widely in electronics. Ideal as an introduction to physical computing on the Pi.\n\n\nPhysical computing\n\n\nComputing that involves tangible things connected to a computer, beyond standard input and output devices like keyboards and monitors. Think buttons, lights, robots, alarms, sensors, home automation, teddy bears called Babbage in near space and so on. We love physical computing because as well as being lots of fun, it's such a powerful teaching and learning tool and encourages creativity, problem solving, and collaboration. Computing \nbeyond the screen\n engages children of all ages, and you can make very cool stuff!\n\n\n\n\nAppendix 1. A note on pin numbering\n\n\nWhen programming the GPIO pins there are two different ways to refer to them: GPIO numbering and physical numbering. \n\n\nGPIO numbering\n\n\nThese are the GPIO pins as the computer sees them. The numbers don't make any sense to humans, they jump about all over the place, so there is no easy way to remember them. You will need a printed reference or a reference board that fits over the pins. \n\n\nPhysical numbering\n\n\nThe other way to refer to the pins is by simply counting across and down from pin 1 at the top left (nearest to the SD card). This is 'physical numbering' and it looks like this:\n\n\n\n\nWhich system should I use?\n\n\nBeginners and young children may find the physical numbering system simpler -- you simply count the pins. You'll still need a diagram like the one above to know which are GPIO pins, which are ground and which are power though. \n\n\nGenerally we recommend using the GPIO numbering. It's good practice and most resources use this system. Take your pick though -- as long as you use the same system within a program then all will be well. Note that pin numbering can also depend on what programming language you are using: Scratch GPIO, for example, uses physical pin numbers whereas in Python you can choose which to use.\n\n\nFor more details on the advanced capabilities of the GPIO pins see gadgetoid's \ninteractive pinout diagram\n.",
            "title": "GPIO: Raspberry Pi Models A and B"
        },
        {
            "location": "/usage/gpio/README/index.html#gpio-raspberry-pi-models-a-and-b",
            "text": "",
            "title": "GPIO: Raspberry Pi Models A and B"
        },
        {
            "location": "/usage/gpio/README/index.html#an-introduction-to-gpio-and-physical-computing-on-the-raspberry-pi",
            "text": "One powerful feature of the Raspberry Pi is the row of GPIO (general purpose input/output) pins along the edge of the board, next to the yellow video out socket.   These pins are a physical interface between the Pi and the outside world. At the simplest level, you can think of them as switches that you can turn on or off (input) or that the Pi can turn on or off (output). Seventeen of the 26 pins are GPIO pins; the others are power or ground pins.",
            "title": "An introduction to GPIO and physical computing on the Raspberry Pi"
        },
        {
            "location": "/usage/gpio/README/index.html#what-are-they-for-what-can-i-do-with-them",
            "text": "You can program the pins to interact in amazing ways with the real world. Inputs don't have to come from a physical switch; it could be input from a sensor or a signal from another computer or device, for example. The output can also do anything, from turning on an LED to sending a signal or data to another device. If the Raspberry Pi is on a network, you can control devices that are attached to it from anywhere** and those devices can send data back. Connectivity and control of physical devices over the internet is a powerful and exciting thing, and the Raspberry Pi is ideal for this. There are lots of brilliant examples of physical computing on  our blog .  Note : Not  literally  anywhere, of course. You need things like access to the network, a network capable computing device, and electricity. Please do not write to us to point this out. :)",
            "title": "What are they for? What can I do with them?"
        },
        {
            "location": "/usage/gpio/README/index.html#how-the-gpio-pins-work",
            "text": "",
            "title": "How the GPIO pins work"
        },
        {
            "location": "/usage/gpio/README/index.html#output",
            "text": "WARNING : If you follow the instructions, then messing about with the GPIO is safe and fun. Randomly plugging wires and power sources into your Pi, however, may kill it. Bad things can also happen if you try to connect things to your Pi that use a lot of power; LEDs are fine, motors are not. If you are worried about this, then you might want to consider using a breakout board such as the  Pibrella  until you are confident enough to use the GPIO directly.  Ignoring the Pi for a moment, one of the simplest electrical circuits that you can build is a battery connected to a light source and a switch (the resistor is there to protect the LED):   When we use a GPIO pin as an output, the Raspberry Pi replaces  both the switch and the battery  in the above diagram. Each pin can turn on or off, or go HIGH or LOW in computing terms. When the pin is HIGH it outputs 3.3 volts (3v3); when the pin is LOW it is off.  Here's the same circuit using the Raspberry Pi. The LED is connected to a GPIO pin (which can output +3v3) and a ground pin (which is 0v and acts like the negative terminal of the battery):   The next step is to write a program to tell the pin to go HIGH or LOW. Here's an example using  Python  (see Step 2), and here's how to do it in  Scratch .",
            "title": "Output"
        },
        {
            "location": "/usage/gpio/README/index.html#input",
            "text": "GPIO  outputs  are easy; they are on or off, HIGH or LOW, 3v3 or 0v.  Inputs  are a bit trickier because of the way that digital devices work. Although it might seem reasonable just to connect a button across an input pin and a ground pin, the Pi can get confused as to whether the button is on or off. It might work properly, it might not. It's a bit like floating about in deep space; without a reference it would be hard to tell if you were going up or down, or even what up or down meant!  This is why you will see phrases like \"pull up\" and \"pull down\" in Raspberry Pi GPIO tutorials. It's a way of giving the input pin a reference so it knows for certain when an input is received.  If you'd like to have a go at using the GPIO as an input then have a look at our  burping jelly baby  and  quick reaction game  tutorials for Python, or a  reaction game  for Scratch.",
            "title": "Input"
        },
        {
            "location": "/usage/gpio/README/index.html#the-end-of-the-guide-the-start-of-something-amazing",
            "text": "We hope that this has encouraged you to have a go at physical computing using the Pi's GPIO; it's really not as daunting as it looks. It all starts with a simple LED, but it can take you to incredible places. Do not underestimate the fun, creativity and sense of achievement you can get from a little computer and a bunch of pins. Have fun! And if you do make something cool please let us know. :)",
            "title": "The end of the guide. The start of something amazing"
        },
        {
            "location": "/usage/gpio/README/index.html#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/usage/gpio/README/index.html#gpio",
            "text": "General purpose input/output; in this specific case the pins on the Raspberry Pi and what you can do with them. So called because you can use them for all sorts of purposes; most can be used as either inputs or outputs, depending on your program.",
            "title": "GPIO"
        },
        {
            "location": "/usage/gpio/README/index.html#led",
            "text": "Light-emitting diode- a small, low-power light source used widely in electronics. Ideal as an introduction to physical computing on the Pi.",
            "title": "LED"
        },
        {
            "location": "/usage/gpio/README/index.html#physical-computing",
            "text": "Computing that involves tangible things connected to a computer, beyond standard input and output devices like keyboards and monitors. Think buttons, lights, robots, alarms, sensors, home automation, teddy bears called Babbage in near space and so on. We love physical computing because as well as being lots of fun, it's such a powerful teaching and learning tool and encourages creativity, problem solving, and collaboration. Computing  beyond the screen  engages children of all ages, and you can make very cool stuff!",
            "title": "Physical computing"
        },
        {
            "location": "/usage/gpio/README/index.html#appendix-1-a-note-on-pin-numbering",
            "text": "When programming the GPIO pins there are two different ways to refer to them: GPIO numbering and physical numbering.",
            "title": "Appendix 1. A note on pin numbering"
        },
        {
            "location": "/usage/gpio/README/index.html#gpio-numbering",
            "text": "These are the GPIO pins as the computer sees them. The numbers don't make any sense to humans, they jump about all over the place, so there is no easy way to remember them. You will need a printed reference or a reference board that fits over the pins.",
            "title": "GPIO numbering"
        },
        {
            "location": "/usage/gpio/README/index.html#physical-numbering",
            "text": "The other way to refer to the pins is by simply counting across and down from pin 1 at the top left (nearest to the SD card). This is 'physical numbering' and it looks like this:",
            "title": "Physical numbering"
        },
        {
            "location": "/usage/gpio/README/index.html#which-system-should-i-use",
            "text": "Beginners and young children may find the physical numbering system simpler -- you simply count the pins. You'll still need a diagram like the one above to know which are GPIO pins, which are ground and which are power though.   Generally we recommend using the GPIO numbering. It's good practice and most resources use this system. Take your pick though -- as long as you use the same system within a program then all will be well. Note that pin numbering can also depend on what programming language you are using: Scratch GPIO, for example, uses physical pin numbers whereas in Python you can choose which to use.  For more details on the advanced capabilities of the GPIO pins see gadgetoid's  interactive pinout diagram .",
            "title": "Which system should I use?"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html",
            "text": "GPIO: Models A+, B+, Raspberry Pi 2 B and Raspberry Pi 3 B\n\n\nAn introduction to GPIO and physical computing on the Raspberry Pi\n\n\nOne powerful feature of the Raspberry Pi is the row of GPIO (general purpose input/output) pins along the top edge of the board.\n\n\n\n\nThese pins are a physical interface between the Pi and the outside world. At the simplest level, you can think of them as switches that you can turn on or off (input) or that the Pi can turn on or off (output). Of the 40 pins, 26 are GPIO pins and the others are power or ground pins (plus two ID EEPROM pins which you should not play with unless you know your stuff!)\n\n\n\n\nNote that the numbering of the GPIO pins is rather weird. \nAppendix 1: A note on pin numbering\n  below explains why.\n\n\nWhat are they for? What can I do with them?\n\n\nYou can program the pins to interact in amazing ways with the real world. Inputs don't have to come from a physical switch; it could be input from a sensor or a signal from another computer or device, for example. The output can also do anything, from turning on an LED to sending a signal or data to another device. If the Raspberry Pi is on a network, you can control devices that are attached to it from anywhere** and those devices can send data back. Connectivity and control of physical devices over the internet is a powerful and exciting thing, and the Raspberry Pi is ideal for this. There are lots of brilliant examples of physical computing on \nour blog\n.\n\n\nNote\n: Not \nliterally\n anywhere, of course. You need things like access to the network, a network capable computing device, and electricity. Please do not write to us to point this out. :)\n\n\nHow the GPIO pins work\n\n\nOutput\n\n\nWARNING\n: If you follow the instructions, then messing about with the GPIO is safe and fun. Randomly plugging wires and power sources into your Pi, however, may kill it. Bad things can also happen if you try to connect things to your Pi that use a lot of power; LEDs are fine, motors are not. If you are worried about this, then you might want to consider using a breakout board such as the \nPibrella\n until you are confident enough to use the GPIO directly.\n\n\nIgnoring the Pi for a moment, one of the simplest electrical circuits that you can build is a battery connected to a light source and a switch (the resistor is there to protect the LED):\n\n\n\n\nWhen we use a GPIO pin as an output, the Raspberry Pi replaces \nboth the switch and the battery\n in the above diagram. Each pin can turn on or off, or go HIGH or LOW in computing terms. When the pin is HIGH it outputs 3.3 volts (3v3); when the pin is LOW it is off.\n\n\nHere's the same circuit using the Raspberry Pi. The LED is connected to a GPIO pin (which can output +3v3) and a ground pin (which is 0v and acts like the negative terminal of the battery):\n\n\n\n\nThe next step is to write a program to tell the pin to go HIGH or LOW. Here's an example using \nPython\n (see Step 2), and here's how to do it in \nScratch\n.\n\n\nInput\n\n\nGPIO \noutputs\n are easy; they are on or off, HIGH or LOW, 3v3 or 0v. \nInputs\n are a bit trickier because of the way that digital devices work. Although it might seem reasonable just to connect a button across an input pin and a ground pin, the Pi can get confused as to whether the button is on or off. It might work properly, it might not. It's a bit like floating about in deep space; without a reference it would be hard to tell if you were going up or down, or even what up or down meant!\n\n\nThis is why you will see phrases like \"pull up\" and \"pull down\" in Raspberry Pi GPIO tutorials. It's a way of giving the input pin a reference so it knows for certain when an input is received.\n\n\nIf you'd like to have a go at using the GPIO as an input then have a look at our \nburping jelly baby\n and \nquick reaction game\n tutorials for Python, or a \nreaction game\n for Scratch.\n\n\nThe end of the guide. The start of something amazing\n\n\nWe hope that this has encouraged you to have a go at physical computing using the Pi's GPIO; it's really not as daunting as it looks. It all starts with a simple LED, but it can take you to incredible places. Do not underestimate the fun, creativity and sense of achievement you can get from a little computer and a bunch of pins. Have fun! And if you do make something cool please let us know. :)\n\n\n\n\nGlossary\n\n\nGPIO\n\n\nGeneral purpose input/output; in this specific case the pins on the Raspberry Pi and what you can do with them. So called because you can use them for all sorts of purposes; most can be used as either inputs or outputs, depending on your program.\n\n\nLED\n\n\nLight-emitting diode- a small, low-power light source used widely in electronics. Ideal as an introduction to physical computing on the Pi.\n\n\nPhysical computing\n\n\nComputing that involves tangible things connected to a computer, beyond standard input and output devices like keyboards and monitors. Think buttons, lights, robots, alarms, sensors, home automation, teddy bears called Babbage in near space and so on. We love physical computing because as well as being lots of fun, it's such a powerful teaching and learning tool and encourages creativity, problem solving, and collaboration. Computing \nbeyond the screen\n engages children of all ages, and you can make very cool stuff!\n\n\n\n\nAppendix 1. A note on pin numbering\n\n\nWhen programming the GPIO pins there are two different ways to refer to them: GPIO numbering and physical numbering. \n\n\nGPIO numbering\n\n\nThese are the GPIO pins as the computer sees them. The numbers don't make any sense to humans, they jump about all over the place, so there is no easy way to remember them. You will need a printed reference or a reference board that fits over the pins. \n\n\nPhysical numbering\n\n\nThe other way to refer to the pins is by simply counting across and down from pin 1 at the top left (nearest to the SD card). This is 'physical numbering' and it looks like this:\n\n\n\n\nWhich system should I use?\n\n\nBeginners and young children may find the physical numbering system simpler -- you simply count the pins. You'll still need a diagram like the one above to know which are GPIO pins, which are ground and which are power though. \n\n\nGenerally we recommend using the GPIO numbering. It's good practice and most resources use this system. Take your pick though -- as long as you use the same system within a program then all will be well. Note that pin numbering can also depend on what programming language you are using: Scratch GPIO, for example, uses physical pin numbers whereas in Python you can choose which to use.\n\n\nFor more details on the advanced capabilities of the GPIO pins see gadgetoid's \ninteractive pinout diagram\n.",
            "title": "GPIO: Models A+, B+, Raspberry Pi 2 B and Raspberry Pi 3 B"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#gpio-models-a-b-raspberry-pi-2-b-and-raspberry-pi-3-b",
            "text": "",
            "title": "GPIO: Models A+, B+, Raspberry Pi 2 B and Raspberry Pi 3 B"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#an-introduction-to-gpio-and-physical-computing-on-the-raspberry-pi",
            "text": "One powerful feature of the Raspberry Pi is the row of GPIO (general purpose input/output) pins along the top edge of the board.   These pins are a physical interface between the Pi and the outside world. At the simplest level, you can think of them as switches that you can turn on or off (input) or that the Pi can turn on or off (output). Of the 40 pins, 26 are GPIO pins and the others are power or ground pins (plus two ID EEPROM pins which you should not play with unless you know your stuff!)   Note that the numbering of the GPIO pins is rather weird.  Appendix 1: A note on pin numbering   below explains why.",
            "title": "An introduction to GPIO and physical computing on the Raspberry Pi"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#what-are-they-for-what-can-i-do-with-them",
            "text": "You can program the pins to interact in amazing ways with the real world. Inputs don't have to come from a physical switch; it could be input from a sensor or a signal from another computer or device, for example. The output can also do anything, from turning on an LED to sending a signal or data to another device. If the Raspberry Pi is on a network, you can control devices that are attached to it from anywhere** and those devices can send data back. Connectivity and control of physical devices over the internet is a powerful and exciting thing, and the Raspberry Pi is ideal for this. There are lots of brilliant examples of physical computing on  our blog .  Note : Not  literally  anywhere, of course. You need things like access to the network, a network capable computing device, and electricity. Please do not write to us to point this out. :)",
            "title": "What are they for? What can I do with them?"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#how-the-gpio-pins-work",
            "text": "",
            "title": "How the GPIO pins work"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#output",
            "text": "WARNING : If you follow the instructions, then messing about with the GPIO is safe and fun. Randomly plugging wires and power sources into your Pi, however, may kill it. Bad things can also happen if you try to connect things to your Pi that use a lot of power; LEDs are fine, motors are not. If you are worried about this, then you might want to consider using a breakout board such as the  Pibrella  until you are confident enough to use the GPIO directly.  Ignoring the Pi for a moment, one of the simplest electrical circuits that you can build is a battery connected to a light source and a switch (the resistor is there to protect the LED):   When we use a GPIO pin as an output, the Raspberry Pi replaces  both the switch and the battery  in the above diagram. Each pin can turn on or off, or go HIGH or LOW in computing terms. When the pin is HIGH it outputs 3.3 volts (3v3); when the pin is LOW it is off.  Here's the same circuit using the Raspberry Pi. The LED is connected to a GPIO pin (which can output +3v3) and a ground pin (which is 0v and acts like the negative terminal of the battery):   The next step is to write a program to tell the pin to go HIGH or LOW. Here's an example using  Python  (see Step 2), and here's how to do it in  Scratch .",
            "title": "Output"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#input",
            "text": "GPIO  outputs  are easy; they are on or off, HIGH or LOW, 3v3 or 0v.  Inputs  are a bit trickier because of the way that digital devices work. Although it might seem reasonable just to connect a button across an input pin and a ground pin, the Pi can get confused as to whether the button is on or off. It might work properly, it might not. It's a bit like floating about in deep space; without a reference it would be hard to tell if you were going up or down, or even what up or down meant!  This is why you will see phrases like \"pull up\" and \"pull down\" in Raspberry Pi GPIO tutorials. It's a way of giving the input pin a reference so it knows for certain when an input is received.  If you'd like to have a go at using the GPIO as an input then have a look at our  burping jelly baby  and  quick reaction game  tutorials for Python, or a  reaction game  for Scratch.",
            "title": "Input"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#the-end-of-the-guide-the-start-of-something-amazing",
            "text": "We hope that this has encouraged you to have a go at physical computing using the Pi's GPIO; it's really not as daunting as it looks. It all starts with a simple LED, but it can take you to incredible places. Do not underestimate the fun, creativity and sense of achievement you can get from a little computer and a bunch of pins. Have fun! And if you do make something cool please let us know. :)",
            "title": "The end of the guide. The start of something amazing"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#glossary",
            "text": "",
            "title": "Glossary"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#gpio",
            "text": "General purpose input/output; in this specific case the pins on the Raspberry Pi and what you can do with them. So called because you can use them for all sorts of purposes; most can be used as either inputs or outputs, depending on your program.",
            "title": "GPIO"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#led",
            "text": "Light-emitting diode- a small, low-power light source used widely in electronics. Ideal as an introduction to physical computing on the Pi.",
            "title": "LED"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#physical-computing",
            "text": "Computing that involves tangible things connected to a computer, beyond standard input and output devices like keyboards and monitors. Think buttons, lights, robots, alarms, sensors, home automation, teddy bears called Babbage in near space and so on. We love physical computing because as well as being lots of fun, it's such a powerful teaching and learning tool and encourages creativity, problem solving, and collaboration. Computing  beyond the screen  engages children of all ages, and you can make very cool stuff!",
            "title": "Physical computing"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#appendix-1-a-note-on-pin-numbering",
            "text": "When programming the GPIO pins there are two different ways to refer to them: GPIO numbering and physical numbering.",
            "title": "Appendix 1. A note on pin numbering"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#gpio-numbering",
            "text": "These are the GPIO pins as the computer sees them. The numbers don't make any sense to humans, they jump about all over the place, so there is no easy way to remember them. You will need a printed reference or a reference board that fits over the pins.",
            "title": "GPIO numbering"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#physical-numbering",
            "text": "The other way to refer to the pins is by simply counting across and down from pin 1 at the top left (nearest to the SD card). This is 'physical numbering' and it looks like this:",
            "title": "Physical numbering"
        },
        {
            "location": "/usage/gpio-plus-and-raspi2/README/index.html#which-system-should-i-use",
            "text": "Beginners and young children may find the physical numbering system simpler -- you simply count the pins. You'll still need a diagram like the one above to know which are GPIO pins, which are ground and which are power though.   Generally we recommend using the GPIO numbering. It's good practice and most resources use this system. Take your pick though -- as long as you use the same system within a program then all will be well. Note that pin numbering can also depend on what programming language you are using: Scratch GPIO, for example, uses physical pin numbers whereas in Python you can choose which to use.  For more details on the advanced capabilities of the GPIO pins see gadgetoid's  interactive pinout diagram .",
            "title": "Which system should I use?"
        },
        {
            "location": "/usage/kodi/README/index.html",
            "text": "Using Kodi on the Raspberry Pi\n\n\nKodi is media centre software which runs on Raspberry Pi.\n\n\n\n\nTwo Kodi distributions are included in our easy operating system installer \nNOOBS\n: \nLibreELEC\n and \nOSMC\n.\n\n\nNOOBS\n\n\nFirst, install NOOBS on an SD card. Follow instructions on the \nNOOBS\n page.\n\n\nWith NOOBS on your SD card, you should be able to boot the Raspberry Pi to the NOOBS operating system selection screen:\n\n\n\n\nSelect \nLibreELEC\n or \nOSMC\n and press the \nInstall\n button.\n\n\nYou'll be prompted to confirm. This will delete any data on the SD card, so if you previously had Raspbian on it be sure to back up your files first. If you're sure, click \nYes\n to continue and start the installation. This will take some time; when it's complete NOOBS will show a window saying:\n\n\nOS(es) Installed Successfully\n\n\n\n\n\nClick \nOK\n and your Pi will reboot into the distribution you selected.\n\n\nUsing Kodi\n\n\nNow you've got your Kodi distribution installed, you can play media files, configure the system, and install add-ons to add more functionality.\n\n\nYou may be shown a Welcome screen, which will help you configure your setup and get started.\n\n\n\n\nPower\n\n\nYou can power your Pi the conventional way with a wall socket USB micro cable; alternatively, if your TV has a USB port you can connect the Pi directly with a USB micro cable. This means your Pi will be powered when the TV is turned on, and powered down when the TV is turned off.\n\n\nControl\n\n\nYou can use a keyboard and mouse with Kodi, buy a TV remote with a USB receiver, or even use a presentation clicker with directional buttons.\n\n\nYou can also use a Kodi app on your smartphone; search for \nKodi\n in your phone's app store. Once configured to connect to your Kodi Pi's IP address, you can use the on-screen remote control or browse the files from your phone and select what to play.\n\n\nPlaying video files\n\n\nYou can copy video files onto your Pi's SD card, or put them on a USB stick or external hard drive. To play these files, simply choose \nVIDEOS\n in the slider on the main screen, then \nFiles\n, and you should see your inserted media in the list of sources. Select your device and you should be able to navigate it like you would on a computer. Find the desired video file, select it and it will play.\n\n\nConnecting a network drive\n\n\nYou can connect to a network device such as a NAS (Network Attached Storage) on your local network by using a wired connection. Connect your Raspberry Pi to your router with an Ethernet cable. To connect to the device, select \nVIDEOS\n from the main screen and click \nAdd Videos...\n.\n\n\nThe \nAdd Video Source\n screen will be shown. Select \nBrowse\n and choose the type of connection. For a NAS, choose \nWindows network (SMB)\n; it will be using the Samba protocol, an open-source implementation of the Windows file share protocol. The device will show up if it can be found on the network. Add this device as a location and you'll be able to navigate its file system and play its media files.\n\n\nSettings\n\n\nKodi has a host of configurable options. You can change the screen resolution, choose a different skin, set up a screensaver, configure the file view, set localisation options, configure subtitles, and much more. Just go to \nSYSTEM\n and \nSettings\n from the main screen.\n\n\nAdd-ons\n\n\nAdd-ons provide extra functionality or enable connection to web services like YouTube.\n\n\nThe YouTube add-on showing search results:\n\n\n\n\nYou can configure add-ons from the settings menu; a selection is available for you to browse. Select one and you'll be prompted to install it. Each add-on has its own configurations.",
            "title": "Using Kodi on the Raspberry Pi"
        },
        {
            "location": "/usage/kodi/README/index.html#using-kodi-on-the-raspberry-pi",
            "text": "Kodi is media centre software which runs on Raspberry Pi.   Two Kodi distributions are included in our easy operating system installer  NOOBS :  LibreELEC  and  OSMC .",
            "title": "Using Kodi on the Raspberry Pi"
        },
        {
            "location": "/usage/kodi/README/index.html#noobs",
            "text": "First, install NOOBS on an SD card. Follow instructions on the  NOOBS  page.  With NOOBS on your SD card, you should be able to boot the Raspberry Pi to the NOOBS operating system selection screen:   Select  LibreELEC  or  OSMC  and press the  Install  button.  You'll be prompted to confirm. This will delete any data on the SD card, so if you previously had Raspbian on it be sure to back up your files first. If you're sure, click  Yes  to continue and start the installation. This will take some time; when it's complete NOOBS will show a window saying:  OS(es) Installed Successfully  Click  OK  and your Pi will reboot into the distribution you selected.",
            "title": "NOOBS"
        },
        {
            "location": "/usage/kodi/README/index.html#using-kodi",
            "text": "Now you've got your Kodi distribution installed, you can play media files, configure the system, and install add-ons to add more functionality.  You may be shown a Welcome screen, which will help you configure your setup and get started.",
            "title": "Using Kodi"
        },
        {
            "location": "/usage/kodi/README/index.html#power",
            "text": "You can power your Pi the conventional way with a wall socket USB micro cable; alternatively, if your TV has a USB port you can connect the Pi directly with a USB micro cable. This means your Pi will be powered when the TV is turned on, and powered down when the TV is turned off.",
            "title": "Power"
        },
        {
            "location": "/usage/kodi/README/index.html#control",
            "text": "You can use a keyboard and mouse with Kodi, buy a TV remote with a USB receiver, or even use a presentation clicker with directional buttons.  You can also use a Kodi app on your smartphone; search for  Kodi  in your phone's app store. Once configured to connect to your Kodi Pi's IP address, you can use the on-screen remote control or browse the files from your phone and select what to play.",
            "title": "Control"
        },
        {
            "location": "/usage/kodi/README/index.html#playing-video-files",
            "text": "You can copy video files onto your Pi's SD card, or put them on a USB stick or external hard drive. To play these files, simply choose  VIDEOS  in the slider on the main screen, then  Files , and you should see your inserted media in the list of sources. Select your device and you should be able to navigate it like you would on a computer. Find the desired video file, select it and it will play.",
            "title": "Playing video files"
        },
        {
            "location": "/usage/kodi/README/index.html#connecting-a-network-drive",
            "text": "You can connect to a network device such as a NAS (Network Attached Storage) on your local network by using a wired connection. Connect your Raspberry Pi to your router with an Ethernet cable. To connect to the device, select  VIDEOS  from the main screen and click  Add Videos... .  The  Add Video Source  screen will be shown. Select  Browse  and choose the type of connection. For a NAS, choose  Windows network (SMB) ; it will be using the Samba protocol, an open-source implementation of the Windows file share protocol. The device will show up if it can be found on the network. Add this device as a location and you'll be able to navigate its file system and play its media files.",
            "title": "Connecting a network drive"
        },
        {
            "location": "/usage/kodi/README/index.html#settings",
            "text": "Kodi has a host of configurable options. You can change the screen resolution, choose a different skin, set up a screensaver, configure the file view, set localisation options, configure subtitles, and much more. Just go to  SYSTEM  and  Settings  from the main screen.",
            "title": "Settings"
        },
        {
            "location": "/usage/kodi/README/index.html#add-ons",
            "text": "Add-ons provide extra functionality or enable connection to web services like YouTube.  The YouTube add-on showing search results:   You can configure add-ons from the settings menu; a selection is available for you to browse. Select one and you'll be prompted to install it. Each add-on has its own configurations.",
            "title": "Add-ons"
        },
        {
            "location": "/usage/mathematica/README/index.html",
            "text": "Mathematica & the Wolfram Language\n\n\nMathematica is a computational programming tool used in science, maths, computing and engineering first released in 1988. It is proprietary software that you can use for free on the Raspberry Pi and has been bundled with Raspbian and NOOBS since late 2013. Read the announcement on the Raspberry Pi blog: \nThe Wolfram Language and Mathematica on Raspberry Pi, for free\n.\n\n\nSee the \nGetting Started with Mathematica\n learning resource for instructions on using Mathematica.",
            "title": "Mathematica & the Wolfram Language"
        },
        {
            "location": "/usage/mathematica/README/index.html#mathematica-the-wolfram-language",
            "text": "Mathematica is a computational programming tool used in science, maths, computing and engineering first released in 1988. It is proprietary software that you can use for free on the Raspberry Pi and has been bundled with Raspbian and NOOBS since late 2013. Read the announcement on the Raspberry Pi blog:  The Wolfram Language and Mathematica on Raspberry Pi, for free .  See the  Getting Started with Mathematica  learning resource for instructions on using Mathematica.",
            "title": "Mathematica &amp; the Wolfram Language"
        },
        {
            "location": "/usage/minecraft/README/index.html",
            "text": "Minecraft Pi\n\n\nMinecraft is a popular sandbox open world building game. A free version of Minecraft is available for the Raspberry Pi; it also comes with a programming interface. This means you can write commands and scripts in Python code to build things in the game automatically. It's a great way to learn Python!\n\n\n\n\nSee the \nGetting Started with Minecraft Pi\n learning resource for instructions on using Minecraft Pi.",
            "title": "Minecraft Pi"
        },
        {
            "location": "/usage/minecraft/README/index.html#minecraft-pi",
            "text": "Minecraft is a popular sandbox open world building game. A free version of Minecraft is available for the Raspberry Pi; it also comes with a programming interface. This means you can write commands and scripts in Python code to build things in the game automatically. It's a great way to learn Python!   See the  Getting Started with Minecraft Pi  learning resource for instructions on using Minecraft Pi.",
            "title": "Minecraft Pi"
        },
        {
            "location": "/usage/python/README/index.html",
            "text": "Python\n\n\nPython is a wonderful and powerful programming language that's easy to use (easy to read \nand\n write) and with Raspberry Pi lets you connect your project to the real world.\n\n\n\n\nPython syntax is very clean, with an emphasis on readability and uses standard English keywords. Start by opening IDLE from the desktop.\n\n\nIDLE\n\n\nThe easiest introduction to Python is through IDLE, a Python development environment. Open IDLE from the Desktop or applications menu:\n\n\n\n\nIDLE gives you a REPL (Read-Evaluate-Print-Loop) which is a prompt you can enter Python commands in to. As it's a REPL you even get the output of commands printed to the screen without using \nprint\n.\n\n\nNote two versions of Python are available: Python 2 and Python 3. Python 3 is the newest version and is recommended, however Python 2 is available for legacy applications which do not support Python 3 yet. For the examples on this page you can use Python 2 or 3 (see \nPython 2 vs. Python 3\n).\n\n\nYou can use variables if you need to but you can even use it like a calculator. For example:\n\n\n>>>\n \n1\n \n+\n \n2\n\n\n3\n\n\n>>>\n \nname\n \n=\n \n\"Sarah\"\n\n\n>>>\n \n\"Hello \"\n \n+\n \nname\n\n\n'Hello Sarah'\n\n\n\n\n\n\nIDLE also has syntax highlighting built in and some support for autocompletion. You can look back on the history of the commands you've entered in the REPL with \nAlt + P\n (previous) and \nAlt + N\n (next).\n\n\nBasic Python usage\n\n\nHello world in Python:\n\n\nprint\n(\n\"Hello world\"\n)\n\n\n\n\n\n\nSimple as that!\n\n\nIndentation\n\n\nSome languages use curly braces \n{\n and \n}\n to wrap around lines of code which belong together, and leave it to the writer to indent these lines to appear visually nested. However, Python does not use curly braces but instead requires indentation for nesting. For example a \nfor\n loop in Python:\n\n\nfor\n \ni\n \nin\n \nrange\n(\n10\n):\n\n    \nprint\n(\n\"Hello\"\n)\n\n\n\n\n\n\nThe indentation is necessary here. A second line indented would be a part of the loop, and a second line not indented would be outside of the loop. For example:\n\n\nfor\n \ni\n \nin\n \nrange\n(\n2\n):\n\n    \nprint\n(\n\"A\"\n)\n\n    \nprint\n(\n\"B\"\n)\n\n\n\n\n\n\nwould print:\n\n\nA\nB\nA\nB\n\n\n\n\n\nwhereas the following:\n\n\nfor\n \ni\n \nin\n \nrange\n(\n2\n):\n\n    \nprint\n(\n\"A\"\n)\n\n\nprint\n(\n\"B\"\n)\n\n\n\n\n\n\nwould print:\n\n\nA\nA\nB\n\n\n\n\n\nVariables\n\n\nTo save a value to a variable, assign it like so:\n\n\nname\n \n=\n \n\"Bob\"\n\n\nage\n \n=\n \n15\n\n\n\n\n\n\nNote here I did not assign types to these variables, as types are inferred, and can be changed (it's dynamic).\n\n\nage\n \n=\n \n15\n\n\nage\n \n+=\n \n1\n  \n# increment age by 1\n\n\nprint\n(\nage\n)\n\n\n\n\n\n\nThis time I used comments beside the increment command.\n\n\nComments\n\n\nComments are ignored in the program but there for you to leave notes, and are denoted by the hash \n#\n symbol. Multi-line comments use triple quotes like so:\n\n\n\"\"\"\n\n\nThis is a very simple Python program that prints \"Hello\".\n\n\nThat's all it does.\n\n\n\"\"\"\n\n\n\nprint\n(\n\"Hello\"\n)\n\n\n\n\n\n\nLists\n\n\nPython also has lists (called arrays in some languages) which are collections of data of any type:\n\n\nnumbers\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n\n\n\n\nLists are denoted by the use of square brackets \n[]\n and each item is separated by a comma.\n\n\nIteration\n\n\nSome data types are iterable, which means you can loop over the values they contain. For example a list:\n\n\nnumbers\n \n=\n \n[\n1\n,\n \n2\n,\n \n3\n]\n\n\n\nfor\n \nnumber\n \nin\n \nnumbers\n:\n\n    \nprint\n(\nnumber\n)\n\n\n\n\n\n\nThis takes each item in the list \nnumbers\n and prints out the item:\n\n\n1\n2\n3\n\n\n\n\n\nNote I used the word \nnumber\n to denote each item. This is merely the word I chose for this - it's recommended you choose descriptive words for variables - using plurals for lists, and singular for each item makes sense. It makes it easier to understand when reading.\n\n\nOther data types are iterable, for example the string:\n\n\ndog_name\n \n=\n \n\"BINGO\"\n\n\n\nfor\n \nchar\n \nin\n \ndog_name\n:\n\n    \nprint\n(\nchar\n)\n\n\n\n\n\n\nThis loops over each character and prints them out:\n\n\nB\nI\nN\nG\nO\n\n\n\n\n\nRange\n\n\nThe integer data type is not iterable and trying to iterate over it will produce an error. For example:\n\n\nfor\n \ni\n \nin\n \n3\n:\n\n    \nprint\n(\ni\n)\n\n\n\n\n\n\nwill produce:\n\n\nTypeError\n:\n \n'int'\n \nobject\n \nis\n \nnot\n \niterable\n\n\n\n\n\n\n\n\nHowever you can make an iterable object using the \nrange\n function:\n\n\nfor\n \ni\n \nin\n \nrange\n(\n3\n):\n\n    \nprint\n(\ni\n)\n\n\n\n\n\n\nrange(5)\n contains the numbers \n0\n, \n1\n, \n2\n, \n3\n and \n4\n (five numbers in total). To get the numbers \n1\n to \n5\n use \nrange(1, 6)\n.\n\n\nLength\n\n\nYou can use functions like \nlen\n to find the length of a string or a list:\n\n\nname\n \n=\n \n\"Jamie\"\n\n\nprint\n(\nlen\n(\nname\n))\n  \n# 5\n\n\n\nnames\n \n=\n \n[\n\"Bob\"\n,\n \n\"Jane\"\n,\n \n\"James\"\n,\n \n\"Alice\"\n]\n\n\nprint\n(\nlen\n(\nnames\n))\n  \n# 4\n\n\n\n\n\n\nIf statements\n\n\nYou can use \nif\n statements for control flow:\n\n\nname\n \n=\n \n\"Joe\"\n\n\n\nif\n \nlen\n(\nname\n)\n \n>\n \n3\n:\n\n    \nprint\n(\n\"Nice name,\"\n)\n\n    \nprint\n(\nname\n)\n\n\nelse\n:\n\n    \nprint\n(\n\"That's a short name,\"\n)\n\n    \nprint\n(\nname\n)\n\n\n\n\n\n\nPython files in IDLE\n\n\nTo create a Python file in IDLE, click \nFile > New File\n and you'll be given a blank window. This is an empty file, not a Python prompt. You write a Python file in this window, save it, then run it and you'll see the output in the other window.\n\n\nFor example, in the new window, type:\n\n\nn\n \n=\n \n0\n\n\n\nfor\n \ni\n \nin\n \nrange\n(\n1\n,\n \n101\n):\n\n    \nn\n \n+=\n \ni\n\n\n\nprint\n(\n\"The sum of the numbers 1 to 100 is:\"\n)\n\n\nprint\n(\nn\n)\n\n\n\n\n\n\nThen save this file (\nFile > Save\n or \nCtrl + S\n) and run (\nRun > Run Module\n or hit \nF5\n) and you'll see the output in your original Python window.\n\n\nExecuting Python files from the command line\n\n\nYou can write a Python file in a standard \neditor\n like Vim, Nano or LeafPad, and run it as a Python script from the command line. Just navigate to the directory the file is saved (use \ncd\n and \nls\n for guidance) and run with \npython\n, e.g. \npython hello.py\n.\n\n\n\n\nMore\n\n\nSee \nmore advanced\n information covering:\n\n\n\n\nPython 2 vs. Python 3\n\n\nConvention\n\n\nOther ways of using Python\n\n\nInstalling Python libraries\n\n\nGPIO\n\n\n\n\nAlso see the page on running the preinstalled \nPython Games\n\n\nPython Documentation\n\n\nFull documentation for Python is available at \npython.org/doc",
            "title": "Python"
        },
        {
            "location": "/usage/python/README/index.html#python",
            "text": "Python is a wonderful and powerful programming language that's easy to use (easy to read  and  write) and with Raspberry Pi lets you connect your project to the real world.   Python syntax is very clean, with an emphasis on readability and uses standard English keywords. Start by opening IDLE from the desktop.",
            "title": "Python"
        },
        {
            "location": "/usage/python/README/index.html#idle",
            "text": "The easiest introduction to Python is through IDLE, a Python development environment. Open IDLE from the Desktop or applications menu:   IDLE gives you a REPL (Read-Evaluate-Print-Loop) which is a prompt you can enter Python commands in to. As it's a REPL you even get the output of commands printed to the screen without using  print .  Note two versions of Python are available: Python 2 and Python 3. Python 3 is the newest version and is recommended, however Python 2 is available for legacy applications which do not support Python 3 yet. For the examples on this page you can use Python 2 or 3 (see  Python 2 vs. Python 3 ).  You can use variables if you need to but you can even use it like a calculator. For example:  >>>   1   +   2  3  >>>   name   =   \"Sarah\"  >>>   \"Hello \"   +   name  'Hello Sarah'   IDLE also has syntax highlighting built in and some support for autocompletion. You can look back on the history of the commands you've entered in the REPL with  Alt + P  (previous) and  Alt + N  (next).",
            "title": "IDLE"
        },
        {
            "location": "/usage/python/README/index.html#basic-python-usage",
            "text": "Hello world in Python:  print ( \"Hello world\" )   Simple as that!",
            "title": "Basic Python usage"
        },
        {
            "location": "/usage/python/README/index.html#indentation",
            "text": "Some languages use curly braces  {  and  }  to wrap around lines of code which belong together, and leave it to the writer to indent these lines to appear visually nested. However, Python does not use curly braces but instead requires indentation for nesting. For example a  for  loop in Python:  for   i   in   range ( 10 ): \n     print ( \"Hello\" )   The indentation is necessary here. A second line indented would be a part of the loop, and a second line not indented would be outside of the loop. For example:  for   i   in   range ( 2 ): \n     print ( \"A\" ) \n     print ( \"B\" )   would print:  A\nB\nA\nB  whereas the following:  for   i   in   range ( 2 ): \n     print ( \"A\" )  print ( \"B\" )   would print:  A\nA\nB",
            "title": "Indentation"
        },
        {
            "location": "/usage/python/README/index.html#variables",
            "text": "To save a value to a variable, assign it like so:  name   =   \"Bob\"  age   =   15   Note here I did not assign types to these variables, as types are inferred, and can be changed (it's dynamic).  age   =   15  age   +=   1    # increment age by 1  print ( age )   This time I used comments beside the increment command.",
            "title": "Variables"
        },
        {
            "location": "/usage/python/README/index.html#comments",
            "text": "Comments are ignored in the program but there for you to leave notes, and are denoted by the hash  #  symbol. Multi-line comments use triple quotes like so:  \"\"\"  This is a very simple Python program that prints \"Hello\".  That's all it does.  \"\"\"  print ( \"Hello\" )",
            "title": "Comments"
        },
        {
            "location": "/usage/python/README/index.html#lists",
            "text": "Python also has lists (called arrays in some languages) which are collections of data of any type:  numbers   =   [ 1 ,   2 ,   3 ]   Lists are denoted by the use of square brackets  []  and each item is separated by a comma.",
            "title": "Lists"
        },
        {
            "location": "/usage/python/README/index.html#iteration",
            "text": "Some data types are iterable, which means you can loop over the values they contain. For example a list:  numbers   =   [ 1 ,   2 ,   3 ]  for   number   in   numbers : \n     print ( number )   This takes each item in the list  numbers  and prints out the item:  1\n2\n3  Note I used the word  number  to denote each item. This is merely the word I chose for this - it's recommended you choose descriptive words for variables - using plurals for lists, and singular for each item makes sense. It makes it easier to understand when reading.  Other data types are iterable, for example the string:  dog_name   =   \"BINGO\"  for   char   in   dog_name : \n     print ( char )   This loops over each character and prints them out:  B\nI\nN\nG\nO",
            "title": "Iteration"
        },
        {
            "location": "/usage/python/README/index.html#range",
            "text": "The integer data type is not iterable and trying to iterate over it will produce an error. For example:  for   i   in   3 : \n     print ( i )   will produce:  TypeError :   'int'   object   is   not   iterable    However you can make an iterable object using the  range  function:  for   i   in   range ( 3 ): \n     print ( i )   range(5)  contains the numbers  0 ,  1 ,  2 ,  3  and  4  (five numbers in total). To get the numbers  1  to  5  use  range(1, 6) .",
            "title": "Range"
        },
        {
            "location": "/usage/python/README/index.html#length",
            "text": "You can use functions like  len  to find the length of a string or a list:  name   =   \"Jamie\"  print ( len ( name ))    # 5  names   =   [ \"Bob\" ,   \"Jane\" ,   \"James\" ,   \"Alice\" ]  print ( len ( names ))    # 4",
            "title": "Length"
        },
        {
            "location": "/usage/python/README/index.html#if-statements",
            "text": "You can use  if  statements for control flow:  name   =   \"Joe\"  if   len ( name )   >   3 : \n     print ( \"Nice name,\" ) \n     print ( name )  else : \n     print ( \"That's a short name,\" ) \n     print ( name )",
            "title": "If statements"
        },
        {
            "location": "/usage/python/README/index.html#python-files-in-idle",
            "text": "To create a Python file in IDLE, click  File > New File  and you'll be given a blank window. This is an empty file, not a Python prompt. You write a Python file in this window, save it, then run it and you'll see the output in the other window.  For example, in the new window, type:  n   =   0  for   i   in   range ( 1 ,   101 ): \n     n   +=   i  print ( \"The sum of the numbers 1 to 100 is:\" )  print ( n )   Then save this file ( File > Save  or  Ctrl + S ) and run ( Run > Run Module  or hit  F5 ) and you'll see the output in your original Python window.",
            "title": "Python files in IDLE"
        },
        {
            "location": "/usage/python/README/index.html#executing-python-files-from-the-command-line",
            "text": "You can write a Python file in a standard  editor  like Vim, Nano or LeafPad, and run it as a Python script from the command line. Just navigate to the directory the file is saved (use  cd  and  ls  for guidance) and run with  python , e.g.  python hello.py .",
            "title": "Executing Python files from the command line"
        },
        {
            "location": "/usage/python/README/index.html#more",
            "text": "See  more advanced  information covering:   Python 2 vs. Python 3  Convention  Other ways of using Python  Installing Python libraries  GPIO   Also see the page on running the preinstalled  Python Games",
            "title": "More"
        },
        {
            "location": "/usage/python/README/index.html#python-documentation",
            "text": "Full documentation for Python is available at  python.org/doc",
            "title": "Python Documentation"
        },
        {
            "location": "/usage/python/more/index.html",
            "text": "More on Python\n\n\nPython 2 vs. Python 3\n\n\nThe short version: Python 2 is legacy, Python 3 is the present and future of the language.\n\n\nPython 2 was released in 2000, and Python 3 was released in 2008. Python 3 is recommended, but some libraries have not yet been ported to Python 3 which is why Python 2 is still present and widely used.\n\n\nIf you are familiar with Python 2 but not Python 3, here is a summary of the basic key differences:\n\n\n\n\nPrint\n\n\nIn Python 2, \nprint\n is a statement and did not require brackets, e.g. \nprint \"Hello\"\n.\n\n\nIn Python 3, \nprint\n is a function, so you pass in what you want to print as parameters, e.g. \nprint(\"Hello\")\n or \nprint(\"My age is\", age)\n.\n\n\nUsing brackets for \nprint\n in Python 2 works fine, so it's common to see this used for compatibility. However printing multiple objects in the same \nprint\n command works differently.\n\n\nIn Python 3 this prints each one, space separated, and in Python 2 the collection of items is printed as a tuple, e.g. \n(\"My age is\", 15)\n\n\n\n\n\n\nInput / Raw input\n\n\nIn Python 2, the function \nraw_input\n takes input from the user.\n\n\nIn Python 3, the function is called \ninput\n.\n\n\n\n\n\n\nInteger division\n\n\nIn Python 2 \n/\n is used for exact integer division, always returning an integer. This means it returns the value of the number of times one number divides in to another whole, and ignores the remainder, e.g. \n1 / 2\n returns \n0\n, \n2 / 2\n returns \n1\n and \n3 / 2\n returns \n1\n.\n\n\nIn Python 3, \n/\n does 'true' division, returning a floating point number (decimal), e.g. \n1 / 2\n returns \n0.5\n.\n\n\nTo get floating point division in Python 2, convert one or both numbers to a float first, e.g. \n1.0 / 2\n which returns \n0.5\n.\n\n\nTo get exact integer division in Python 3, use \n//\n, e.g. \n1 // 2\n returns \n0\n.\n\n\n\n\n\n\n\n\nPython 2.7.6 was released in 2013. The 2.x branch will have no further major releases.\n\n\nRead more on the differences on the \nPython wiki\n\n\nConvention\n\n\nWhile indentation is essential in Python, there are other aspects which are syntactically correct but considered bad practise. These are given in a style guide called \nPEP 8\n and include conventions such as always using spaces around operators i.e. \na = 1 + 2\n over \na=1+2\n and a maximum line length of 79 characters. It also suggests using four spaces per tab (this is configurable in your editor).\n\n\nThe philosophy of Python is summarised in \nPEP 20\n (The Zen of Python) which encourages good Pythonic writing style. For example:\n\n\n\n\nBeautiful is better than ugly\n\n\nExplicit is better than implicit\n\n\nSimple is better than complex\n\n\nComplex is better than complicated\n\n\nReadability counts\n\n\n\n\nOther ways of using Python\n\n\nCommand Line\n\n\nThe standard built-in Python REPL is accessed by typing \npython\n in the Terminal. Type \npython3\n for Python 3.\n\n\nThis REPL is a prompt ready for Python commands to be entered. You can use this the same as IDLE, but it does not have syntax highlighting or autocompletion. You can look back on the history of the commands you've entered in the REPL by using the Up/Down keys. Use \nCtrl + D\n to exit.\n\n\nIPython\n\n\nAn alternative command line Python prompt is IPython. IPython is an interactive Python shell with syntax highlighting, autocompletion, pretty printing, built-in documentation and more. IPython is not installed by default. Install with:\n\n\nsudo apt-get install ipython\n\n\n\n\n\nor for Python 3:\n\n\nsudo apt-get install ipython3\n\n\n\n\n\nThen run with \nipython\n or \nipython3\n from the command line. It works like the standard \npython\n, but with more features. Try typing \nlen?\n and hitting \nEnter\n. You're shown information including the docstring for the \nlen\n function:\n\n\nType\n:\n       \nbuiltin_function_or_method\n\n\nString\n \nForm\n:\n<\nbuilt\n-\nin\n \nfunction\n \nlen\n>\n\n\nNamespace\n:\n  \nPython\n \nbuiltin\n\n\nDocstring\n:\n\n\nlen\n(\nobject\n)\n \n->\n \ninteger\n\n\n\nReturn\n \nthe\n \nnumber\n \nof\n \nitems\n \nof\n \na\n \nsequence\n \nor\n \nmapping\n.\n\n\n\n\n\n\nTry the following dictionary comprehension:\n\n\n{\ni\n:\n \ni\n \n**\n \n3\n \nfor\n \ni\n \nin\n \nrange\n(\n12\n)}\n\n\n\n\n\n\nwhich will pretty print the following:\n\n\n{\n1\n:\n \n1\n,\n\n \n2\n:\n \n8\n,\n\n \n3\n:\n \n27\n,\n\n \n4\n:\n \n64\n,\n\n \n5\n:\n \n125\n,\n\n \n6\n:\n \n216\n,\n\n \n7\n:\n \n343\n,\n\n \n8\n:\n \n512\n,\n\n \n9\n:\n \n729\n,\n\n \n10\n:\n \n1000\n,\n\n \n11\n:\n \n1331\n}\n\n\n\n\n\n\nIn \npython\n this would have printed on one line:\n\n\n{\n1\n:\n \n1\n,\n \n2\n:\n \n8\n,\n \n3\n:\n \n27\n,\n \n4\n:\n \n64\n,\n \n5\n:\n \n125\n,\n \n6\n:\n \n216\n,\n \n7\n:\n \n343\n,\n \n8\n:\n \n512\n,\n \n9\n:\n \n729\n,\n \n10\n:\n \n1000\n,\n \n11\n:\n \n1331\n}\n\n\n\n\n\n\n\n\nYou can look back on the history of the commands you've entered in the REPL by using the Up/Down keys like in \npython\n but it also persists over sessions, so you can exit \nipython\n and return (or switch between v2/3) and the history remains. Use \nCtrl + D\n to exit.\n\n\nInstalling Python libraries\n\n\nAPT\n\n\nSome Python packages can be found in the Raspbian archives, and can be installed using APT, for example:\n\n\nsudo apt-get update\nsudo apt-get install python-picamera\n\n\n\n\n\nThis is a preferable method of installing things as it means that the modules you install can be kept up to date easily with the usual \nsudo apt-get update\n and \nsudo apt-get upgrade\n commands.\n\n\nPip\n\n\nNot all Python packages are available in the Raspbian archives, and those that are can sometimes be out of date. If you can't find a suitable version in the Raspbian archives you can install packages from the \nPython Package Index\n (also known as PyPI). To do so, use the \npip\n tool (which is installed with the \npython-pip\n package in Raspbian:\n\n\nsudo apt-get install python-pip\nsudo pip install simplejson\n\n\n\n\n\nRead more on \ninstalling software in Python\n\n\nGPIO\n\n\nUsing Python on the Raspberry Pi opens up the opportunity to connect to the real world through the Pi's GPIO pins. This can be done with the RPi GPIO library. It is preinstalled on recent Raspbian images, but if you have an older one you can install it with:\n\n\nsudo apt-get install python-rpi.gpio\n\n\n\n\n\nor\n\n\nsudo apt-get install python3-rpi.gpio\n\n\n\n\n\nIn older versions of Raspbian, you'll need root access to access the GPIO pins, so run \nsudo python\n, \nsudo ipython\n or \nsudo idle &\n, but in newer versions, if the user is in the \ngpio\n group, you can run it normally.\n\n\nIn your Python script (or in the REPL), import the GPIO module, set the board mode to that of your preference, set up the pins you want to use and turn them on:\n\n\nimport\n \nRPi.GPIO\n \nas\n \nGPIO\n\n\n\nGPIO\n.\nsetmode\n(\nGPIO\n.\nBCM\n)\n  \n# set board mode to Broadcom\n\n\n\nGPIO\n.\nsetup\n(\n17\n,\n \nGPIO\n.\nOUT\n)\n  \n# set up pin 17\n\n\nGPIO\n.\nsetup\n(\n18\n,\n \nGPIO\n.\nOUT\n)\n  \n# set up pin 18\n\n\n\nGPIO\n.\noutput\n(\n17\n,\n \n1\n)\n  \n# turn on pin 17\n\n\nGPIO\n.\noutput\n(\n18\n,\n \n1\n)\n  \n# turn on pin 18",
            "title": "More on Python"
        },
        {
            "location": "/usage/python/more/index.html#more-on-python",
            "text": "",
            "title": "More on Python"
        },
        {
            "location": "/usage/python/more/index.html#python-2-vs-python-3",
            "text": "The short version: Python 2 is legacy, Python 3 is the present and future of the language.  Python 2 was released in 2000, and Python 3 was released in 2008. Python 3 is recommended, but some libraries have not yet been ported to Python 3 which is why Python 2 is still present and widely used.  If you are familiar with Python 2 but not Python 3, here is a summary of the basic key differences:   Print  In Python 2,  print  is a statement and did not require brackets, e.g.  print \"Hello\" .  In Python 3,  print  is a function, so you pass in what you want to print as parameters, e.g.  print(\"Hello\")  or  print(\"My age is\", age) .  Using brackets for  print  in Python 2 works fine, so it's common to see this used for compatibility. However printing multiple objects in the same  print  command works differently.  In Python 3 this prints each one, space separated, and in Python 2 the collection of items is printed as a tuple, e.g.  (\"My age is\", 15)    Input / Raw input  In Python 2, the function  raw_input  takes input from the user.  In Python 3, the function is called  input .    Integer division  In Python 2  /  is used for exact integer division, always returning an integer. This means it returns the value of the number of times one number divides in to another whole, and ignores the remainder, e.g.  1 / 2  returns  0 ,  2 / 2  returns  1  and  3 / 2  returns  1 .  In Python 3,  /  does 'true' division, returning a floating point number (decimal), e.g.  1 / 2  returns  0.5 .  To get floating point division in Python 2, convert one or both numbers to a float first, e.g.  1.0 / 2  which returns  0.5 .  To get exact integer division in Python 3, use  // , e.g.  1 // 2  returns  0 .     Python 2.7.6 was released in 2013. The 2.x branch will have no further major releases.  Read more on the differences on the  Python wiki",
            "title": "Python 2 vs. Python 3"
        },
        {
            "location": "/usage/python/more/index.html#convention",
            "text": "While indentation is essential in Python, there are other aspects which are syntactically correct but considered bad practise. These are given in a style guide called  PEP 8  and include conventions such as always using spaces around operators i.e.  a = 1 + 2  over  a=1+2  and a maximum line length of 79 characters. It also suggests using four spaces per tab (this is configurable in your editor).  The philosophy of Python is summarised in  PEP 20  (The Zen of Python) which encourages good Pythonic writing style. For example:   Beautiful is better than ugly  Explicit is better than implicit  Simple is better than complex  Complex is better than complicated  Readability counts",
            "title": "Convention"
        },
        {
            "location": "/usage/python/more/index.html#other-ways-of-using-python",
            "text": "",
            "title": "Other ways of using Python"
        },
        {
            "location": "/usage/python/more/index.html#command-line",
            "text": "The standard built-in Python REPL is accessed by typing  python  in the Terminal. Type  python3  for Python 3.  This REPL is a prompt ready for Python commands to be entered. You can use this the same as IDLE, but it does not have syntax highlighting or autocompletion. You can look back on the history of the commands you've entered in the REPL by using the Up/Down keys. Use  Ctrl + D  to exit.",
            "title": "Command Line"
        },
        {
            "location": "/usage/python/more/index.html#ipython",
            "text": "An alternative command line Python prompt is IPython. IPython is an interactive Python shell with syntax highlighting, autocompletion, pretty printing, built-in documentation and more. IPython is not installed by default. Install with:  sudo apt-get install ipython  or for Python 3:  sudo apt-get install ipython3  Then run with  ipython  or  ipython3  from the command line. It works like the standard  python , but with more features. Try typing  len?  and hitting  Enter . You're shown information including the docstring for the  len  function:  Type :         builtin_function_or_method  String   Form : < built - in   function   len >  Namespace :    Python   builtin  Docstring :  len ( object )   ->   integer  Return   the   number   of   items   of   a   sequence   or   mapping .   Try the following dictionary comprehension:  { i :   i   **   3   for   i   in   range ( 12 )}   which will pretty print the following:  { 1 :   1 , \n  2 :   8 , \n  3 :   27 , \n  4 :   64 , \n  5 :   125 , \n  6 :   216 , \n  7 :   343 , \n  8 :   512 , \n  9 :   729 , \n  10 :   1000 , \n  11 :   1331 }   In  python  this would have printed on one line:  { 1 :   1 ,   2 :   8 ,   3 :   27 ,   4 :   64 ,   5 :   125 ,   6 :   216 ,   7 :   343 ,   8 :   512 ,   9 :   729 ,   10 :   1000 ,   11 :   1331 }    You can look back on the history of the commands you've entered in the REPL by using the Up/Down keys like in  python  but it also persists over sessions, so you can exit  ipython  and return (or switch between v2/3) and the history remains. Use  Ctrl + D  to exit.",
            "title": "IPython"
        },
        {
            "location": "/usage/python/more/index.html#installing-python-libraries",
            "text": "",
            "title": "Installing Python libraries"
        },
        {
            "location": "/usage/python/more/index.html#apt",
            "text": "Some Python packages can be found in the Raspbian archives, and can be installed using APT, for example:  sudo apt-get update\nsudo apt-get install python-picamera  This is a preferable method of installing things as it means that the modules you install can be kept up to date easily with the usual  sudo apt-get update  and  sudo apt-get upgrade  commands.",
            "title": "APT"
        },
        {
            "location": "/usage/python/more/index.html#pip",
            "text": "Not all Python packages are available in the Raspbian archives, and those that are can sometimes be out of date. If you can't find a suitable version in the Raspbian archives you can install packages from the  Python Package Index  (also known as PyPI). To do so, use the  pip  tool (which is installed with the  python-pip  package in Raspbian:  sudo apt-get install python-pip\nsudo pip install simplejson  Read more on  installing software in Python",
            "title": "Pip"
        },
        {
            "location": "/usage/python/more/index.html#gpio",
            "text": "Using Python on the Raspberry Pi opens up the opportunity to connect to the real world through the Pi's GPIO pins. This can be done with the RPi GPIO library. It is preinstalled on recent Raspbian images, but if you have an older one you can install it with:  sudo apt-get install python-rpi.gpio  or  sudo apt-get install python3-rpi.gpio  In older versions of Raspbian, you'll need root access to access the GPIO pins, so run  sudo python ,  sudo ipython  or  sudo idle & , but in newer versions, if the user is in the  gpio  group, you can run it normally.  In your Python script (or in the REPL), import the GPIO module, set the board mode to that of your preference, set up the pins you want to use and turn them on:  import   RPi.GPIO   as   GPIO  GPIO . setmode ( GPIO . BCM )    # set board mode to Broadcom  GPIO . setup ( 17 ,   GPIO . OUT )    # set up pin 17  GPIO . setup ( 18 ,   GPIO . OUT )    # set up pin 18  GPIO . output ( 17 ,   1 )    # turn on pin 17  GPIO . output ( 18 ,   1 )    # turn on pin 18",
            "title": "GPIO"
        },
        {
            "location": "/usage/python-games/README/index.html",
            "text": "Python Games\n\n\nYou'll find Python Games on the Desktop or in the application menu:\n\n\n\n\nDouble click this icon to start. This will prompt you to set your audio configuration to output sound over HDMI or the headphone jack. Make a selection or leave it as it is and click \nOK\n to proceed.\n\n\n\n\nNow you'll be shown a tall window with the list of games available:\n\n\n\n\nPick a game, click it and hit \nOK\n to play.\n\n\nExamples\n\n\nFour in a Row\n\n\n\n\nFlippy\n\n\n\n\nGame source code\n\n\nThe source of each of these games is available on the Pi. Simply navigate to the directory \n/home/pi/python_games\n in a terminal or the file manager and you'll see the assets and source code.\n\n\nThe \npython_games\n directory listing in a terminal window:\n\n\n\n\nThe \npython_games\n folder contents in a the file manager window:\n\n\n\n\nThe Python source code for the \nFour in a Row\n game, open for editing in \nIDLE\n.\n\n\n\n\nHack the game\n\n\nYou can edit the source of these games. Why not make a copy of a Python file, look through the code and change some numbers? See what happens.\n\n\nFor more free games check out \nFree Python Games\n, which are designed for education and fun. They include simplified versions of arcade classics like Tron, Pac-Man, and more.\n\n\nIf you can figure out how the game works, try to hack it to make it better, make it harder (or easier) to win, or add some features to the game! You could add \nGPIO\n interaction so lights flash when you win, or add input buttons.",
            "title": "Python Games"
        },
        {
            "location": "/usage/python-games/README/index.html#python-games",
            "text": "You'll find Python Games on the Desktop or in the application menu:   Double click this icon to start. This will prompt you to set your audio configuration to output sound over HDMI or the headphone jack. Make a selection or leave it as it is and click  OK  to proceed.   Now you'll be shown a tall window with the list of games available:   Pick a game, click it and hit  OK  to play.",
            "title": "Python Games"
        },
        {
            "location": "/usage/python-games/README/index.html#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/usage/python-games/README/index.html#four-in-a-row",
            "text": "",
            "title": "Four in a Row"
        },
        {
            "location": "/usage/python-games/README/index.html#flippy",
            "text": "",
            "title": "Flippy"
        },
        {
            "location": "/usage/python-games/README/index.html#game-source-code",
            "text": "The source of each of these games is available on the Pi. Simply navigate to the directory  /home/pi/python_games  in a terminal or the file manager and you'll see the assets and source code.  The  python_games  directory listing in a terminal window:   The  python_games  folder contents in a the file manager window:   The Python source code for the  Four in a Row  game, open for editing in  IDLE .",
            "title": "Game source code"
        },
        {
            "location": "/usage/python-games/README/index.html#hack-the-game",
            "text": "You can edit the source of these games. Why not make a copy of a Python file, look through the code and change some numbers? See what happens.  For more free games check out  Free Python Games , which are designed for education and fun. They include simplified versions of arcade classics like Tron, Pac-Man, and more.  If you can figure out how the game works, try to hack it to make it better, make it harder (or easier) to win, or add some features to the game! You could add  GPIO  interaction so lights flash when you win, or add input buttons.",
            "title": "Hack the game"
        },
        {
            "location": "/usage/scratch/README/index.html",
            "text": "Scratch\n\n\nScratch is a visual programming tool which allows the user to create animations and games with a drag-and-drop interface. It allows you to create your own computer games, interactive stories, and animations using some programming techniques without actually having to write code. It\u2019s a great way to get started programming on the Raspberry Pi with young people. To find out more about Scratch, visit the website at \nscratch.mit.edu\n or see the \nComputing At School Raspberry Pi Education Manual\n.\n\n\n\n\nSee the \nGetting Started with Scratch\n learning resource for instructions on using Scratch.\n\n\nSee the \nScratch GPIO Usage Guide",
            "title": "Scratch"
        },
        {
            "location": "/usage/scratch/README/index.html#scratch",
            "text": "Scratch is a visual programming tool which allows the user to create animations and games with a drag-and-drop interface. It allows you to create your own computer games, interactive stories, and animations using some programming techniques without actually having to write code. It\u2019s a great way to get started programming on the Raspberry Pi with young people. To find out more about Scratch, visit the website at  scratch.mit.edu  or see the  Computing At School Raspberry Pi Education Manual .   See the  Getting Started with Scratch  learning resource for instructions on using Scratch.  See the  Scratch GPIO Usage Guide",
            "title": "Scratch"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html",
            "text": "Scratch GPIO\n\n\nWith the September 2015 release of Scratch for the Raspberry Pi, included in the Raspbian Jessie release, we introduced a new GPIO server to make driving LEDs, buzzers, HATS, and other devices and components easier.\n\n\nUsage and basic capabilities\n\n\nStarting the server\n\n\nBefore you can use the GPIO pins, you must start the GPIO server. There are several ways to do this:\n\n\n\n\nChoose \nStart GPIO server\n from the \nEdit\n menu to turn it on. If the server is already running, then \nStop GPIO server\n will turn it off.\n\n\nA Scratch broadcast of \ngpioserveron\n or \ngpioserveroff\n will have the same effects.\n\n\nProjects saved when the GPIO server is running will have that status recorded and, on loading, will try to start the server if it is enabled.\n\n\nYou can also set an option in the scratch INI file. See the Appendix below.\n\n\n\n\nBasic GPIO usage\n\n\nWithout any further setup, you now have access to the basics of the GPIO system. This currently uses the broadcast blocks to send commands to the GPIO server just like the original mesh network-based broadcast messages.\n\n\nFor instance, to configure GPIO pin 4 as an output and turn it on, you create the two following broadcasts:\n\n\n\n\nAs always, you can assemble this text with normal join, pick, or list-handling blocks. For example, if \nfoo\n = 17, then\n\n\n   \n\n\nwould broadcast \ngpio17on\n and thus set the GPIO pin number 17 (under the BCM numbering - not the physical or wiringPi numbers!) to \non\n.\n\n\nThe pins need configuring before you can use them to do anything. We can set the direction of the pin (in or out) and, for input pins, the pull-up mode (up, down, none).\n\n\n\n\nFor input pins we can use 'in' or 'input'. Both of these are treated the same as 'inpullup' or 'inputpullup' and default to setting the pull-up resistor to pull up the signal.\n\n\nTo set the pull-up resistor to pull the signal down, we use 'inpulldown' or 'inputpulldown'\n\n\nWe can set the pull-up resistor to float with 'inpullnone' or 'inputpullnone'\n\n\n\n\n\n\nOutput pins are configured simply by 'out' or 'output'\n\n\nOutput with PWM, which is useful to make LEDs glow part-bright or to make motors run with variable speed etc., is configured with 'outputpwm'\n\n\n\n\nFor example:   \n\n\n  \n\n\nPins set to be inputs are connected to the Scratch sensor variable system, and so they appear in the list of possible values in the sensor blocks:  \n\n\n  \n\n\nand can be used in the same manner:  \n\n\n\nYou won't find your input pin in the list until after running your config broadcast. Until then, the GPIO server can't know that you want it to be an input. When you save your project, the input will still be hooked up.\n\n\nWith these very simple commands, you can build fairly complex GPIO-handling scripts to read buttons and operate LEDs, motors, and so on. We also have commands to return the time, return the machine IP address, read various temperatures, read an ultrasonic distance sensor, fetch a weather report, and even take a photo with an attached Raspberry Pi Camera Module and set it as the current costume.\n\n\nThis script (provided in the Sensors and Motors folder as \nSensors and Motors/gpio-demo\n) illustrates most of the above :  \n\n\n  \n\n\nAlong with a suitably configured breadboard, it provides the ability to turn LEDs on and off with the press of a button, to take a photo with a countdown provided by a progressively brightening LED, ways to check the time, and so on. \n\n\n\n\nNote that we can have a single broadcast that includes several messages, such as \ngpio24on gpio18pwm400\n in the script above.\n\n\nBasic GPIO commands\n\n\nIn the command listings below, we use \n\n\n[comm] + pin number + [ on | off]\n\nto indicate a command of the form \ncomm17off\n or \ncomm7on\n.\n\nFor a variable\n\n\nled + light number (1..5) =  ( 0 .. 100)\n\nindicates a variable named \nled5\n may have a value from 0 to 100. Likewise,\n\n\nfoo = ( 1 | 4 | 7 )\n\nindicates the variable \nfoo\n may be set to 1, 4 or 7.\n\n\nSimple GPIO control\n\n\nThe basic GPIO command list of things you can do without any HATs plugged into your Pi is as follows:\n\n\n\n\nconfig + pin number +\n\n\nin\n, \ninput\n, \ninpullup\n or \ninputpullup\n to set as input with pull-up\n\n\ninpulldown\n or \ninputpulldown\n\n\ninpullnone\n or \ninputpullnone\n\n\nout\n or \noutput\n to set as digital output\n\n\noutputpwm\n to set as a PWM pin  \n\n\n\n\n\n\n\n\nFor example, \nconfig12in\n to set pin 12 as an input with the default pull-up and add a sensor variable \ngpio12\n.  \n\n\n\n\n\n\ngpio + pin number + [ on | high | off | low ]\n to turn an output on or off\nFor example, \ngpio17on\n to turn on pin 17.\n\n\n\n\n\n\ngpio + pin number + pwm + [ 0..1024 ]\n to use the PWM output\n\n\n\n\n\n\nFor example, \ngpio22pwm522\n to set the PWM duty cycle to 522 out of 1024, or roughly half power. Note that many LEDs don't appear to change their brightness in a simple linear manner, so 522 might be barely glowing or nearly full brightness.\n\n\nServo driving\n\n\n\n\nservo + pin number + [percent | %] + [-100...100]\n to move a connected servo to position. \n\n\n\n\nFor example \nservo15%0\n to position a servo in the centre of its range.\n- \nservo stop\n to turn off the servo driver.\n\n\nIn the \nServos and Motors/gpio-servoDemo\n script, you can see how to move a servo or connect it to a variable like the position of a sprite. You will need to wire your servo up like this: \n\n\n\n\nUltrasonic sensor\n\n\n\n\nultrasonic + trigger + trigger pin + echo  + echo pin\n to connect a typical SR04 ultrasonic sensor\n\n\nultrasonic stop\n to turn off the sensor support at the end of your script\n\n\n\n\nHere is an example wiring layout using pin 16 as the trigger and 26 as the echo: \n\n\n\n\nIf you use this wiring setup with the script in \nSensors and Motors/gpio-ultrasonicDemo\n, you will see how to read the distance and move a sprite accordingly. The other ultrasonic demo in \nSensor and Motors/gpio-ultrasonicIntruderAlarm\n requires a Camera Module, and will take a snapshot when anyone gets too close.\n\n\nWeather reports\n\n\n\n\ngetweather + city name + , + country two-letter code + , + your user key from [OpenWeatherMaps](http://www.openweathermaps.org)\n will create sensor variables for the named city's temperature, wind speed and direction, rainfall, and cloud cover. You must sign up to get a key from them (free accounts are available). See \nOpenWeatherMaps\n for details.\n\n\n\n\nFor example \n\n\ngetweather Rio de Janeiro, BR, 1234EF65B42DEAD\n  \n\n\nwould make the sensor variables  \n\n\nRain in Rio de Janeiro\n\n\nTemp in Rio de Janeir0\n  \n\n\n...and so on. The commas between the city name and country code and your key are vital to let the GPIO server know where to split things. Some cities have simple names like 'Ee' or 'Manchester' whilst others get a bit more involved like 'Sault Ste Marie' or 'Llanfair\u00adpwllgwyngyll\u00adgogery\u00adchwyrn\u00addrobwll\u00adllan\u00adtysilio\u00adgogo\u00adgoch'. Note that the OpenWeatherMaps server doesn't know every city in every country, nor does it have every kind of weather data for all those it does know, so sometimes you will get no useful information.\n\n\nThe script \nSensors and Motors/gpio-citytemperaturegraph\n shows how to get the weather data for London and plot the temperature. Since weather data doesn't normally change rapidly we only fetch the data every 15 minutes in order to not overload the website.\n\n\nReading temperatures\n\n\n\n\n\n\ngettemp\n connects to a couple of possible temperature sensors.\n\n\n\n\ngettemp + cpu\n reads the cpu temperature and creates a sensor variable \ncputtemp\n. For example: \ngettempcpu\n. \nAn example project that plots a graph of the CPU temperature can be found in the \nSensors and Motors/gpio-cputtemperaturegraph\n project.\n\n\ngettemp\n on its own will try to find an attached 1-wire DS18B20 thermal sensor and creates a sensor variable named \ntemp + [the twelve-digit sensor ID]\n.\n\n\ngettemp + [a previously discovered twelve-digit 1-wire id]\n will directly connect to that identified DS18B20 sensor if possible.\n\n\n\n\nNote that 1-wire sensors take about half a second to read, so reading the sensor frequently may make Scratch appear to get very slow.\n\n\n\n\n\n\nPhotos\n\n\n\n\nphoto\n uses the camera to take a photo and insert it as the current costume of the sprite (or stage if that is selected).\n\n\nphoto + [big/large]\n: a 'big' photo is the same size as the stage. For example: \nphotobig\n or \nphoto large\n.\n\n\nphoto + [width @ height]\n takes a photo size width by height pixels, up to the limits of the camera. You can try almost any reasonable number for the width and height but remember that very small numbers (under 32 or so) don't necessarily produce a proper image and very large numbers can make an image so big it seems to crash Scratch. For example, \nphoto800@600\n will normally be acceptable but \nphoto2000@1600\n may cause problems.\n\n\n\n\nMiscellaneous\n\n\n\n\ngettime\n adds some time values to the sensor variables, specifically the \nhours\n value, the \nminutes\n value, and the full date and time as \nYYMMDDhhmmss\n. \n\n\ngetip\n adds a sensor variable for the machine's local host address IP number.\n\n\n\n\nAdd-on hardware\n\n\nWe can also control Pi add-on boards such as the PiGlow, Pibrella, Explorer HAT, etc. To set up a board, we first need to inform the GPIO server what board it is; this is done by creating and setting a variable \nAddOn\n, like this:  \n\n\n\n\nEach board has its own set of commands layered on top of the basic GPIO facilities described above.\nMany boards can also make use of the Scratch variable broadcasts, whereby a suitably named variable is created and its value is broadcast when it changes.\n\nFor example, for a PiGlow board it makes sense to have variables named for each LED or ring of LEDs, and to set each value as a way of controlling the brightness. It's possible to cause confusion by using both forms of control at the same time; broadcasting \nmyCommand400\n in the same script as setting \nmyValue\n to 200 might result in flickering, apparent non-function or even hardware failure in extreme cases.\n\nAll you need to do is create a variable of the appropriate name and set its value with the normal script blocks.\n\n\nSome boards provide inputs that can be accessed via the sensor variables, as shown above in the example usage of pin 11.\n\n\nPiGlow\n\n\nThe PiGlow board has several rings of brightly coloured LEDs that can be controlled as rings, legs, individually or all together. Be careful: it can be a bit bright to look at so a diffuser made from some tracing paper or tinted perspex is a good idea. To use the board, set \nAddOn\n to \nPiGlow\n.\n\n\nPiGlow has quite a few commands, and many of these are demonstrated in the \nSensors and Motors/gpio-PiGlow\n project.\n\n\nCommands supported\n\n\n\n\nleg + leg number [ 1 | 2 | 3 ] + [ on | high | off | low ]\n e.g. \nleg2off\n\n\narm\n - as leg\n\n\nall +  [ on | high | off | low ]\n\n\n[ led | light ] + led number +  [ on | high | off | low ]\n e.g. \nlight12high\n\n\nbright + [ 0 .. 255 ]\n (sets the brightness multiplier for any subsequent LED on command)\n\n\n[ red | orange | yellow | green | blue | white ] +  [ on | high | off | low ]\n e.g. \nredlow\n\n\n\n\nVariables\n\n\n\n\nbright = ( 0 .. 255)\n\n\n[ leg | arm ] + [ 1 | 2 | 3 ] = (0 .. 255)\n\n\n[ led | light ] + led number (1..18) = (0 .. 255)\n\n\n[ red | orange | yellow | green | blue | white ] = ( 0 .. 255)\n\n\nledpattern\n = (an 18-character string treated as a binary number such as \u2018011111101010101010\u2019, where anything not 0 is considered a 1)\n\n\n\n\nPiFace\n\n\nThe PiFace Digital board provides eight digital inputs and eight digital outputs, with the first four inputs having parallel switches and the first two outputs having 20V/5A relays. Set \nAddOn\n to \nPiFace\n to activate this board.\n\n\nCommands supported\n\n\n\n\nall + [ on | off]\n\n\noutput + output number + [ on | high | off | low ]\n e.g. \noutput6on\n\n\n\n\nVariables\n\n\n\n\noutput + [ 0 .. 7 ] = (0 |1 )\n - the value is rounded and subjected to max/min limiting, so -1 rounds up to 0 and 400000000 rounds down to 1.\n\n\n\n\nThere are also eight input sensor variables, named \nInput1\n to \nInput8\n, which have possible values (0/1). The \nSensors and Motors/gpio-PiFace\n project illustrates how to make it work.\n\n\nPibrella\n\n\nThis provides a nice big red button, three large LEDs, four digital inputs, four digital outputs, and a loud buzzer. To use this board, set \nAddOn\n to \nPibrella\n.\n\n\nCommands supported\n\n\n\n\n[ red | yellow | green ] + [ on | high | off | low ]\n e.g. \nyellowhigh\n\n\nBuzzer + (0 .. 4000)\n e.g. \nbuzzer2100\n\n\nOutput + [ E | F | G | H ] + [ on | high | off | low ]\n\n\n\n\nVariables\n\n\n\n\nBuzzer = (0..10000)\n\n\n[ red | green | yellow ]  = (0 |1 )\n\n\nOutput + [ E | F | G | H ]  = (0 |1 )\n\n\n\n\nThe inputs A, B, C, D, and the big red button are provided as sensor variables, all having possible values (0/1). There is a demo in \nMotors and Sensors/gpio-pibrella\n. \n\n\nExplorer HAT Pro\n\n\nThis board is a bit more of a challenge to drive, since it has parts that are GPIO connected and parts that are I2C connected:\n\n\n\n\nFour LEDs\n\n\nFour 5V output connectors\n\n\nFour buffered input connectors\n\n\nTwo H-bridge motor drivers\n\n\nFour analogue inputs\n\n\nFour capacitive input pads\n\n\n\n\nTo use this board, set \nAddOn\n to \nExplorerHAT\n.\n\n\nCommands supported\n\n\n\n\nled + led number ( 1 .. 3) +  [ on | high | off | low ]\n\n\noutput + input number ( 1 .. 3) +  [ on | high | off | low ]\n\n\nmotor + motor number (1|2) + speed + (0..100)\n - motor speed is set as a percentage e.g. \nmotor1 speed 42\n\n\n\n\nThey have matching variable forms:\n\n\n\n\nled + led number  = (0 |1 )\n\n\noutput + led number  = (0 |1 )\n\n\nmotor + motor number (0|1) = (0..100)\n\n\n\n\nVariables\n\n\nThere are also sensor variables \nInput1\n to \nInput4\n with values (0|1), and the four ADC pins (1 .. 4) with values +-6.1V. If the signal is derived from a potentiometer connected to the Explorer HAT's 5V/GND, then the range is (0 .. ~5).\n\n\nThe demo script in \nSensors and Motors/gpio-ExplorerHAT\n requires that you wire up a motor, led, rotary potentiometer etc. as shown in \nthis diagram\n\n\nNote that the capacitive input pads are not yet operational, requiring some library level support.\n\n\nSense HAT (as used in the Astro Pi)\n\n\nThis Foundation-built board provides a range of unusual sensors and a big 8 x 8 array of RGB LEDs.\n\n\nThe sensors measure:\n\n\n\n\ntemperature\n\n\nhumidity\n\n\npressure\n\n\naccelerometer/gyro\n\n\nmagnetometer/compass\n\n\nmini-joystick actions left/right/up/down/return\n\n\n\n\nTo use this board, set \nAddOn\n to \nSenseHAT\n.\n\n\nCommands supported\n\n\n\n\nclearleds\n: set all LEDs to background colour\n\n\nledbackground + colour\n or \nledforeground + colour\n: set the background and foreground colours for the string and graph commands to use. Colour is specified with one of the following:\n\n\na name from the list red cyan blue gray black white green brown orange yellow magenta palered paletan lightred paleblue palebuff darkgray lightblue... e.g. \nledforegroundcyan\n\n\nan HTML-style six-digit hex number starting with a hash sign such as \n#34F2A0\n\n\nor an RGB triplet of numbers between 0 and 255, such as \n42, 234, 17\n\n\n\n\n\n\nledscrollspeed + [number of milliseconds delay per step of scrolling]\n: a string\n\n\nledscrollstring + [string]\n: scroll the following string with the previously set foreground and background colours e.g. \nledscrollstring HelloWorld\n\n\nledshowchar + [character]\n: show just a single character with the previously set foreground and background colours\n\n\nledbargraph + [8 digits 0..8]\n: make a simple bar graph of up to eight digits with the previously set foreground and background colours e.g. \nledbargraph20614590\n\n\nledshowsprite + [name of sprite]\n: display the named sprite on the LEDs e.g. \nledshowsprite Sprite1\n. The sprite is centred over the 8 x 8 array and so you may see very little of a large sprite.\n\n\nledpixel + [ x | at] + [0..7] + [y | @] + [0..7] + [colour | color] + [colour name or code as ledbackground]\n. For example: \nledpixelx4y3colourwhite\n or \nledpixelat2@7color42,231,97\n or \nledpixelx3@1colour#4A76A0\n\n\n\n\nVariables\n\n\n\n\ngyroX\n\n\ngyroY\n\n\ngyroZ\n\n\naccelX\n\n\naccelY\n\n\naccelZ\n\n\ncompassX\n\n\ncompassY\n\n\ncompassZ\n\n\ntemp\n\n\npressure\n\n\nhumidity\n\n\n\n\nPi-LITE\n\n\nThe Pi-LITE board provides a simple array of white LEDs that can be addressed individually or treated as a scrolling text display, a bar graph, or a VU meter. It works via the GPIO serial port and presents some interesting challenges, especially setting up the serial connection as detailed in [RaspberryPi-Spy's Pi-LITE instructions] (http://www.raspberrypi-spy.co.uk/2013/09/how-to-setup-the-pi-lite-led-matrix-board/).\n\n\nTo use this board, set \nAddOn\n to \nPiLite\n.\n\n\nCommands supported\n\n\n\n\nallon\n\n\nalloff\n\n\nscrollstringABCDEF\n to display ABCDEF.\n\n\nbargraph[1..14],[1-100]\n sets the bar shown on one of the 14 columns of LEDs to represent the percentage.\n\n\nvumeter[1|2],[1\u2026100]\n displays a two-column bar graph in the style of 1980's boom-box graphic equalisers. \n\n\n\n\nRyanTeck, Pololu and CamJam EduKit 3 motor controller\n\n\nThese boards can drive two DC motors. \n\n\nTo use them, set \nAddOn\n to:\n\n\n\n\nRyanTek001\n for the RyanTeck board\n\n\nPololu8835\n for the Pololu board\n\n\nEdukitMotorBoard\n for the CamJam board\n\n\n\n\nCommands supported\n\n\nAlthough they work quite differently, they share the same commands:\n\n\n\n\nmotor + motor number (1|2) + speed + value (-100..100)\n\n\n\n\nVariables\n\n\n\n\nmotor + motor number (0|1) = (-100..100)\n\n\n\n\nAppendix: enabling and disabling the GPIO server\n\n\nIn normal use you shouldn't need to enable the GPIO server, as by default it is enabled but stopped. We can change this by adding a line to the init file. In the Home directory we can have a file named \n.scratch.ini\n - the initial dot is important to make it a hidden Unix file. Simply add the line \ngpioserver=X\n to the file, where X is:\n\n\n\n\n0\n - to disable the GPIO server, preventing users or loaded projects from using it\n\n\n1\n - to enable the GPIO server but leave it turned off, which is the default when there is no \n.scratch.ini\n file\n\n\n2\n - to both enable and start the server, which might perhaps be useful in a classroom when the lesson will be about GPIO use\n\n\n\n\nNote that the older mesh/network server setup is currently semi-hidden under the \nShare menu\n: you have to hold down the shift key whilst opening that menu. It works exactly as before and still connects to external socket-based servers.",
            "title": "Scratch GPIO"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#scratch-gpio",
            "text": "With the September 2015 release of Scratch for the Raspberry Pi, included in the Raspbian Jessie release, we introduced a new GPIO server to make driving LEDs, buzzers, HATS, and other devices and components easier.",
            "title": "Scratch GPIO"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#usage-and-basic-capabilities",
            "text": "",
            "title": "Usage and basic capabilities"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#starting-the-server",
            "text": "Before you can use the GPIO pins, you must start the GPIO server. There are several ways to do this:   Choose  Start GPIO server  from the  Edit  menu to turn it on. If the server is already running, then  Stop GPIO server  will turn it off.  A Scratch broadcast of  gpioserveron  or  gpioserveroff  will have the same effects.  Projects saved when the GPIO server is running will have that status recorded and, on loading, will try to start the server if it is enabled.  You can also set an option in the scratch INI file. See the Appendix below.",
            "title": "Starting the server"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#basic-gpio-usage",
            "text": "Without any further setup, you now have access to the basics of the GPIO system. This currently uses the broadcast blocks to send commands to the GPIO server just like the original mesh network-based broadcast messages.  For instance, to configure GPIO pin 4 as an output and turn it on, you create the two following broadcasts:   As always, you can assemble this text with normal join, pick, or list-handling blocks. For example, if  foo  = 17, then       would broadcast  gpio17on  and thus set the GPIO pin number 17 (under the BCM numbering - not the physical or wiringPi numbers!) to  on .  The pins need configuring before you can use them to do anything. We can set the direction of the pin (in or out) and, for input pins, the pull-up mode (up, down, none).   For input pins we can use 'in' or 'input'. Both of these are treated the same as 'inpullup' or 'inputpullup' and default to setting the pull-up resistor to pull up the signal.  To set the pull-up resistor to pull the signal down, we use 'inpulldown' or 'inputpulldown'  We can set the pull-up resistor to float with 'inpullnone' or 'inputpullnone'    Output pins are configured simply by 'out' or 'output'  Output with PWM, which is useful to make LEDs glow part-bright or to make motors run with variable speed etc., is configured with 'outputpwm'   For example:         Pins set to be inputs are connected to the Scratch sensor variable system, and so they appear in the list of possible values in the sensor blocks:        and can be used in the same manner:    \nYou won't find your input pin in the list until after running your config broadcast. Until then, the GPIO server can't know that you want it to be an input. When you save your project, the input will still be hooked up.  With these very simple commands, you can build fairly complex GPIO-handling scripts to read buttons and operate LEDs, motors, and so on. We also have commands to return the time, return the machine IP address, read various temperatures, read an ultrasonic distance sensor, fetch a weather report, and even take a photo with an attached Raspberry Pi Camera Module and set it as the current costume.  This script (provided in the Sensors and Motors folder as  Sensors and Motors/gpio-demo ) illustrates most of the above :        Along with a suitably configured breadboard, it provides the ability to turn LEDs on and off with the press of a button, to take a photo with a countdown provided by a progressively brightening LED, ways to check the time, and so on.    Note that we can have a single broadcast that includes several messages, such as  gpio24on gpio18pwm400  in the script above.",
            "title": "Basic GPIO usage"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#basic-gpio-commands",
            "text": "In the command listings below, we use   [comm] + pin number + [ on | off] \nto indicate a command of the form  comm17off  or  comm7on . \nFor a variable  led + light number (1..5) =  ( 0 .. 100) \nindicates a variable named  led5  may have a value from 0 to 100. Likewise,  foo = ( 1 | 4 | 7 ) \nindicates the variable  foo  may be set to 1, 4 or 7.",
            "title": "Basic GPIO commands"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#simple-gpio-control",
            "text": "The basic GPIO command list of things you can do without any HATs plugged into your Pi is as follows:   config + pin number +  in ,  input ,  inpullup  or  inputpullup  to set as input with pull-up  inpulldown  or  inputpulldown  inpullnone  or  inputpullnone  out  or  output  to set as digital output  outputpwm  to set as a PWM pin       For example,  config12in  to set pin 12 as an input with the default pull-up and add a sensor variable  gpio12 .      gpio + pin number + [ on | high | off | low ]  to turn an output on or off\nFor example,  gpio17on  to turn on pin 17.    gpio + pin number + pwm + [ 0..1024 ]  to use the PWM output    For example,  gpio22pwm522  to set the PWM duty cycle to 522 out of 1024, or roughly half power. Note that many LEDs don't appear to change their brightness in a simple linear manner, so 522 might be barely glowing or nearly full brightness.",
            "title": "Simple GPIO control"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#servo-driving",
            "text": "servo + pin number + [percent | %] + [-100...100]  to move a connected servo to position.    For example  servo15%0  to position a servo in the centre of its range.\n-  servo stop  to turn off the servo driver.  In the  Servos and Motors/gpio-servoDemo  script, you can see how to move a servo or connect it to a variable like the position of a sprite. You will need to wire your servo up like this:",
            "title": "Servo driving"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#ultrasonic-sensor",
            "text": "ultrasonic + trigger + trigger pin + echo  + echo pin  to connect a typical SR04 ultrasonic sensor  ultrasonic stop  to turn off the sensor support at the end of your script   Here is an example wiring layout using pin 16 as the trigger and 26 as the echo:    If you use this wiring setup with the script in  Sensors and Motors/gpio-ultrasonicDemo , you will see how to read the distance and move a sprite accordingly. The other ultrasonic demo in  Sensor and Motors/gpio-ultrasonicIntruderAlarm  requires a Camera Module, and will take a snapshot when anyone gets too close.",
            "title": "Ultrasonic sensor"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#weather-reports",
            "text": "getweather + city name + , + country two-letter code + , + your user key from [OpenWeatherMaps](http://www.openweathermaps.org)  will create sensor variables for the named city's temperature, wind speed and direction, rainfall, and cloud cover. You must sign up to get a key from them (free accounts are available). See  OpenWeatherMaps  for details.   For example   getweather Rio de Janeiro, BR, 1234EF65B42DEAD     would make the sensor variables    Rain in Rio de Janeiro  Temp in Rio de Janeir0     ...and so on. The commas between the city name and country code and your key are vital to let the GPIO server know where to split things. Some cities have simple names like 'Ee' or 'Manchester' whilst others get a bit more involved like 'Sault Ste Marie' or 'Llanfair\u00adpwllgwyngyll\u00adgogery\u00adchwyrn\u00addrobwll\u00adllan\u00adtysilio\u00adgogo\u00adgoch'. Note that the OpenWeatherMaps server doesn't know every city in every country, nor does it have every kind of weather data for all those it does know, so sometimes you will get no useful information.  The script  Sensors and Motors/gpio-citytemperaturegraph  shows how to get the weather data for London and plot the temperature. Since weather data doesn't normally change rapidly we only fetch the data every 15 minutes in order to not overload the website.",
            "title": "Weather reports"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#reading-temperatures",
            "text": "gettemp  connects to a couple of possible temperature sensors.   gettemp + cpu  reads the cpu temperature and creates a sensor variable  cputtemp . For example:  gettempcpu . \nAn example project that plots a graph of the CPU temperature can be found in the  Sensors and Motors/gpio-cputtemperaturegraph  project.  gettemp  on its own will try to find an attached 1-wire DS18B20 thermal sensor and creates a sensor variable named  temp + [the twelve-digit sensor ID] .  gettemp + [a previously discovered twelve-digit 1-wire id]  will directly connect to that identified DS18B20 sensor if possible.   Note that 1-wire sensors take about half a second to read, so reading the sensor frequently may make Scratch appear to get very slow.",
            "title": "Reading temperatures"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#photos",
            "text": "photo  uses the camera to take a photo and insert it as the current costume of the sprite (or stage if that is selected).  photo + [big/large] : a 'big' photo is the same size as the stage. For example:  photobig  or  photo large .  photo + [width @ height]  takes a photo size width by height pixels, up to the limits of the camera. You can try almost any reasonable number for the width and height but remember that very small numbers (under 32 or so) don't necessarily produce a proper image and very large numbers can make an image so big it seems to crash Scratch. For example,  photo800@600  will normally be acceptable but  photo2000@1600  may cause problems.",
            "title": "Photos"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#miscellaneous",
            "text": "gettime  adds some time values to the sensor variables, specifically the  hours  value, the  minutes  value, and the full date and time as  YYMMDDhhmmss .   getip  adds a sensor variable for the machine's local host address IP number.",
            "title": "Miscellaneous"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#add-on-hardware",
            "text": "We can also control Pi add-on boards such as the PiGlow, Pibrella, Explorer HAT, etc. To set up a board, we first need to inform the GPIO server what board it is; this is done by creating and setting a variable  AddOn , like this:     Each board has its own set of commands layered on top of the basic GPIO facilities described above.\nMany boards can also make use of the Scratch variable broadcasts, whereby a suitably named variable is created and its value is broadcast when it changes. \nFor example, for a PiGlow board it makes sense to have variables named for each LED or ring of LEDs, and to set each value as a way of controlling the brightness. It's possible to cause confusion by using both forms of control at the same time; broadcasting  myCommand400  in the same script as setting  myValue  to 200 might result in flickering, apparent non-function or even hardware failure in extreme cases. \nAll you need to do is create a variable of the appropriate name and set its value with the normal script blocks.  Some boards provide inputs that can be accessed via the sensor variables, as shown above in the example usage of pin 11.",
            "title": "Add-on hardware"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#piglow",
            "text": "The PiGlow board has several rings of brightly coloured LEDs that can be controlled as rings, legs, individually or all together. Be careful: it can be a bit bright to look at so a diffuser made from some tracing paper or tinted perspex is a good idea. To use the board, set  AddOn  to  PiGlow .  PiGlow has quite a few commands, and many of these are demonstrated in the  Sensors and Motors/gpio-PiGlow  project.",
            "title": "PiGlow"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported",
            "text": "leg + leg number [ 1 | 2 | 3 ] + [ on | high | off | low ]  e.g.  leg2off  arm  - as leg  all +  [ on | high | off | low ]  [ led | light ] + led number +  [ on | high | off | low ]  e.g.  light12high  bright + [ 0 .. 255 ]  (sets the brightness multiplier for any subsequent LED on command)  [ red | orange | yellow | green | blue | white ] +  [ on | high | off | low ]  e.g.  redlow",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables",
            "text": "bright = ( 0 .. 255)  [ leg | arm ] + [ 1 | 2 | 3 ] = (0 .. 255)  [ led | light ] + led number (1..18) = (0 .. 255)  [ red | orange | yellow | green | blue | white ] = ( 0 .. 255)  ledpattern  = (an 18-character string treated as a binary number such as \u2018011111101010101010\u2019, where anything not 0 is considered a 1)",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#piface",
            "text": "The PiFace Digital board provides eight digital inputs and eight digital outputs, with the first four inputs having parallel switches and the first two outputs having 20V/5A relays. Set  AddOn  to  PiFace  to activate this board.",
            "title": "PiFace"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_1",
            "text": "all + [ on | off]  output + output number + [ on | high | off | low ]  e.g.  output6on",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables_1",
            "text": "output + [ 0 .. 7 ] = (0 |1 )  - the value is rounded and subjected to max/min limiting, so -1 rounds up to 0 and 400000000 rounds down to 1.   There are also eight input sensor variables, named  Input1  to  Input8 , which have possible values (0/1). The  Sensors and Motors/gpio-PiFace  project illustrates how to make it work.",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#pibrella",
            "text": "This provides a nice big red button, three large LEDs, four digital inputs, four digital outputs, and a loud buzzer. To use this board, set  AddOn  to  Pibrella .",
            "title": "Pibrella"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_2",
            "text": "[ red | yellow | green ] + [ on | high | off | low ]  e.g.  yellowhigh  Buzzer + (0 .. 4000)  e.g.  buzzer2100  Output + [ E | F | G | H ] + [ on | high | off | low ]",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables_2",
            "text": "Buzzer = (0..10000)  [ red | green | yellow ]  = (0 |1 )  Output + [ E | F | G | H ]  = (0 |1 )   The inputs A, B, C, D, and the big red button are provided as sensor variables, all having possible values (0/1). There is a demo in  Motors and Sensors/gpio-pibrella .",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#explorer-hat-pro",
            "text": "This board is a bit more of a challenge to drive, since it has parts that are GPIO connected and parts that are I2C connected:   Four LEDs  Four 5V output connectors  Four buffered input connectors  Two H-bridge motor drivers  Four analogue inputs  Four capacitive input pads   To use this board, set  AddOn  to  ExplorerHAT .",
            "title": "Explorer HAT Pro"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_3",
            "text": "led + led number ( 1 .. 3) +  [ on | high | off | low ]  output + input number ( 1 .. 3) +  [ on | high | off | low ]  motor + motor number (1|2) + speed + (0..100)  - motor speed is set as a percentage e.g.  motor1 speed 42   They have matching variable forms:   led + led number  = (0 |1 )  output + led number  = (0 |1 )  motor + motor number (0|1) = (0..100)",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables_3",
            "text": "There are also sensor variables  Input1  to  Input4  with values (0|1), and the four ADC pins (1 .. 4) with values +-6.1V. If the signal is derived from a potentiometer connected to the Explorer HAT's 5V/GND, then the range is (0 .. ~5).  The demo script in  Sensors and Motors/gpio-ExplorerHAT  requires that you wire up a motor, led, rotary potentiometer etc. as shown in  this diagram  Note that the capacitive input pads are not yet operational, requiring some library level support.",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#sense-hat-as-used-in-the-astro-pi",
            "text": "This Foundation-built board provides a range of unusual sensors and a big 8 x 8 array of RGB LEDs.  The sensors measure:   temperature  humidity  pressure  accelerometer/gyro  magnetometer/compass  mini-joystick actions left/right/up/down/return   To use this board, set  AddOn  to  SenseHAT .",
            "title": "Sense HAT (as used in the Astro Pi)"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_4",
            "text": "clearleds : set all LEDs to background colour  ledbackground + colour  or  ledforeground + colour : set the background and foreground colours for the string and graph commands to use. Colour is specified with one of the following:  a name from the list red cyan blue gray black white green brown orange yellow magenta palered paletan lightred paleblue palebuff darkgray lightblue... e.g.  ledforegroundcyan  an HTML-style six-digit hex number starting with a hash sign such as  #34F2A0  or an RGB triplet of numbers between 0 and 255, such as  42, 234, 17    ledscrollspeed + [number of milliseconds delay per step of scrolling] : a string  ledscrollstring + [string] : scroll the following string with the previously set foreground and background colours e.g.  ledscrollstring HelloWorld  ledshowchar + [character] : show just a single character with the previously set foreground and background colours  ledbargraph + [8 digits 0..8] : make a simple bar graph of up to eight digits with the previously set foreground and background colours e.g.  ledbargraph20614590  ledshowsprite + [name of sprite] : display the named sprite on the LEDs e.g.  ledshowsprite Sprite1 . The sprite is centred over the 8 x 8 array and so you may see very little of a large sprite.  ledpixel + [ x | at] + [0..7] + [y | @] + [0..7] + [colour | color] + [colour name or code as ledbackground] . For example:  ledpixelx4y3colourwhite  or  ledpixelat2@7color42,231,97  or  ledpixelx3@1colour#4A76A0",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables_4",
            "text": "gyroX  gyroY  gyroZ  accelX  accelY  accelZ  compassX  compassY  compassZ  temp  pressure  humidity",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#pi-lite",
            "text": "The Pi-LITE board provides a simple array of white LEDs that can be addressed individually or treated as a scrolling text display, a bar graph, or a VU meter. It works via the GPIO serial port and presents some interesting challenges, especially setting up the serial connection as detailed in [RaspberryPi-Spy's Pi-LITE instructions] (http://www.raspberrypi-spy.co.uk/2013/09/how-to-setup-the-pi-lite-led-matrix-board/).  To use this board, set  AddOn  to  PiLite .",
            "title": "Pi-LITE"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_5",
            "text": "allon  alloff  scrollstringABCDEF  to display ABCDEF.  bargraph[1..14],[1-100]  sets the bar shown on one of the 14 columns of LEDs to represent the percentage.  vumeter[1|2],[1\u2026100]  displays a two-column bar graph in the style of 1980's boom-box graphic equalisers.",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#ryanteck-pololu-and-camjam-edukit-3-motor-controller",
            "text": "These boards can drive two DC motors.   To use them, set  AddOn  to:   RyanTek001  for the RyanTeck board  Pololu8835  for the Pololu board  EdukitMotorBoard  for the CamJam board",
            "title": "RyanTeck, Pololu and CamJam EduKit 3 motor controller"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#commands-supported_6",
            "text": "Although they work quite differently, they share the same commands:   motor + motor number (1|2) + speed + value (-100..100)",
            "title": "Commands supported"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#variables_5",
            "text": "motor + motor number (0|1) = (-100..100)",
            "title": "Variables"
        },
        {
            "location": "/usage/scratch/gpio/README/index.html#appendix-enabling-and-disabling-the-gpio-server",
            "text": "In normal use you shouldn't need to enable the GPIO server, as by default it is enabled but stopped. We can change this by adding a line to the init file. In the Home directory we can have a file named  .scratch.ini  - the initial dot is important to make it a hidden Unix file. Simply add the line  gpioserver=X  to the file, where X is:   0  - to disable the GPIO server, preventing users or loaded projects from using it  1  - to enable the GPIO server but leave it turned off, which is the default when there is no  .scratch.ini  file  2  - to both enable and start the server, which might perhaps be useful in a classroom when the lesson will be about GPIO use   Note that the older mesh/network server setup is currently semi-hidden under the  Share menu : you have to hold down the shift key whilst opening that menu. It works exactly as before and still connects to external socket-based servers.",
            "title": "Appendix: enabling and disabling the GPIO server"
        },
        {
            "location": "/usage/sonic-pi/README/index.html",
            "text": "Getting started with Sonic Pi\n\n\nSonic Pi is an open-source programming environment, designed for creating new sounds with code in a live coding environment; it was developed by Dr Sam Aaron at the University of Cambridge. He uses the software to perform live with his band. This resource will help get you started with the basics of Sonic Pi so that you can code your own music.\n\n\nSee the \nGetting Started with Sonic Pi\n learning resource for instructions on using Sonic Pi.",
            "title": "Getting started with Sonic Pi"
        },
        {
            "location": "/usage/sonic-pi/README/index.html#getting-started-with-sonic-pi",
            "text": "Sonic Pi is an open-source programming environment, designed for creating new sounds with code in a live coding environment; it was developed by Dr Sam Aaron at the University of Cambridge. He uses the software to perform live with his band. This resource will help get you started with the basics of Sonic Pi so that you can code your own music.  See the  Getting Started with Sonic Pi  learning resource for instructions on using Sonic Pi.",
            "title": "Getting started with Sonic Pi"
        },
        {
            "location": "/usage/terminal/README/index.html",
            "text": "Terminal\n\n\nThe terminal (or 'command-line') on a computer allows a user a great deal of control over their system (or in this case, Pi!). Users of Windows may already have come across \nCommand Prompt\n or \nPowershell\n and Mac OS users may be familiar with \nTerminal\n. All of these tools allow a user to directly manipulate their system through the use of commands. These commands can be chained together and/or combined together into complex scripts (see the \nlinux usage page on scripting\n) that can potentially complete tasks more efficiently than much larger traditional software packages.\n\n\nOpening a Terminal window\n\n\nOn the Raspberry Pi (running Raspbian), the default terminal application is \nLXTerminal\n. This is known as a 'terminal emulator', this means that it emulates the old style video terminals (from before graphical user interfaces were developed) in a graphical environment. The application can be found on the Raspberry Pi desktop and when started will look something like this:\n\n\n\n\nYou should be able to see the following prompt:\n\n\npi@raspberrypi ~ $\n\n\n\n\n\nThis shows your username and the hostname of the Pi. Here the username is \npi\n and the hostname is \nraspberrypi\n.\n\n\nNow, let's try running a command. Type \npwd\n (present working directory) followed by the \nEnter\n key. This should display something like \n/home/pi\n.\n\n\nNavigating and browsing your Pi\n\n\nOne of the key aspects of using a terminal is being able to navigate your file system. Firstly, run the following command: \nls -la\n. You should see something similar to:\n\n\n\n\nThe \nls\n command lists the contents of the directory that you are currently in (your present working directory). The \n-la\n component of the command is what's known as a 'flag'. Flags modify the command that's being run. In this case the \nl\n displays the contents of the directory in a list, showing data such as their sizes and when they were last edited, and the \na\n displays all files, including those beginning with a \n.\n, known as 'dotfiles'. Dotfiles usually act as configuration files for software and as they are written in text, they can be modified by simply editing them.\n\n\nIn order to navigate to other directories the change directory command, \ncd\n, can be used. You can specify the directory that you want to go to by either the 'absolute' or the 'relative' path. So if you wanted to navigate to the \npython_games\n directory, you could either do \ncd /home/pi/python_games\n or just \ncd python_games\n (if you are currently in \n/home/pi\n). There are some special cases that may be useful: \n~\n acts as an alias for your home directory, so \n~/python_games\n is the same as \n/home/pi/python_games\n; \n.\n and \n..\n are aliases for the current directory and the parent directory respectively, e.g. if you were in \n/home/pi/python_games\n, \ncd ..\n would take you to \n/home/pi\n.\n\n\nHistory and auto-complete\n\n\nRather than type every command, the terminal allows you to scroll through previous commands that you've run by pressing the \nup\n or \ndown\n keys on your keyboard. If you are writing the name of a file or directory as part of a command then pressing \ntab\n will attempt to auto-complete the name of what you are typing. For example, if you have a file in a directory called \naLongFileName\n then pressing tab after typing \na\n will allow you to choose from all file and directory names beginning with \na\n in the current directory, allowing you to choose \naLongFileName\n.\n\n\nSudo\n\n\nSome commands that make permanent changes to the state of your system require you to have root privileges to run. The command \nsudo\n temporarily gives your account (if you're not already logged in as root) the ability to run these commands, provided your user name is in a list of users ('sudoers'). When you append \nsudo\n to the start of a command and press \nenter\n you will be asked for your password, if that is entered correctly then the command you want to run will be run using root privileges. Be careful though, some commands that require \nsudo\n to run can irreparably damage your system so be careful!\n\n\nFurther information on \nsudo\n and the root user can be found on the \nlinux root page\n.\n\n\nInstalling software through apt-get\n\n\nRather than using the Pi Store to download new software you can use the command \napt-get\n, this is the 'package manager' that is included with any Debian based Linux distributions (including Raspbian). It allows you to install and manage new software packages on your Pi. In order to install a new package you would type \nsudo apt-get install <package-name>\n (where \n<package-name>\n is the package that you want to install). Running \nsudo apt-get update\n updates a list of software packages that are available on your system. If a new version of a package is available then \nsudo apt-get upgrade\n will update any old packages to the new version. Finally, \nsudo apt-get remove <package-name>\n removes or uninstalls a package from your system.\n\n\nMore information about this can be found in the \nlinux usage section on apt\n.\n\n\nOther useful commands\n\n\nThere are a few other commands that you may find useful, these are listed below:\n\n\n\n\ncp\n makes a copy of a file and places it at the specified location (essentially doing a 'copy-paste'), for example - \ncp file_a /home/other_user/\n would copy the file \nfile_a\n from your home directory to that of the user \nother_user\n (assuming you have permission to copy it there). Note that if the target is a folder, the filename will remain the same, but if the target is a filename, it will give the file the new name.\n\n\nmv\n moves a file and places it at the specified location (so where \ncp\n performs a 'copy-paste', \nmv\n performs a 'cut-paste'). The usage is similar to \ncp\n, so \nmv file_a /home/other_user/\n would move the file \nfile_a\n from your home directory to that of the specified user. \nmv\n is also used to rename a file, i.e. move it to a new location, e.g. \nmv hello.txt story.txt\n.\n\n\nrm\n removes the specified file (or directory when used with \n-r\n). \nWarning:\n Files deleted in this way are generally not restorable.\n\n\nmkdir\n: This makes a new directory, e.g. \nmkdir new_dir\n would create the directory \nnew_dir\n in the present working directory.\n\n\ncat\n lists the contents of files, e.g. \ncat some_file\n will display the contents of \nsome_file\n.\n\n\n\n\nOther commands you may find useful can be found in the \ncommands page\n.\n\n\nFinding out about a command\n\n\nTo find out more information about a particular command then you can run the \nman\n followed by the command you want to know more about (e.g. \nman ls\n). The man-page (or manual page) for that command will be displayed, including information about the flags for that program and what effect they have. Some man-pages will give example usage.",
            "title": "Terminal"
        },
        {
            "location": "/usage/terminal/README/index.html#terminal",
            "text": "The terminal (or 'command-line') on a computer allows a user a great deal of control over their system (or in this case, Pi!). Users of Windows may already have come across  Command Prompt  or  Powershell  and Mac OS users may be familiar with  Terminal . All of these tools allow a user to directly manipulate their system through the use of commands. These commands can be chained together and/or combined together into complex scripts (see the  linux usage page on scripting ) that can potentially complete tasks more efficiently than much larger traditional software packages.",
            "title": "Terminal"
        },
        {
            "location": "/usage/terminal/README/index.html#opening-a-terminal-window",
            "text": "On the Raspberry Pi (running Raspbian), the default terminal application is  LXTerminal . This is known as a 'terminal emulator', this means that it emulates the old style video terminals (from before graphical user interfaces were developed) in a graphical environment. The application can be found on the Raspberry Pi desktop and when started will look something like this:   You should be able to see the following prompt:  pi@raspberrypi ~ $  This shows your username and the hostname of the Pi. Here the username is  pi  and the hostname is  raspberrypi .  Now, let's try running a command. Type  pwd  (present working directory) followed by the  Enter  key. This should display something like  /home/pi .",
            "title": "Opening a Terminal window"
        },
        {
            "location": "/usage/terminal/README/index.html#navigating-and-browsing-your-pi",
            "text": "One of the key aspects of using a terminal is being able to navigate your file system. Firstly, run the following command:  ls -la . You should see something similar to:   The  ls  command lists the contents of the directory that you are currently in (your present working directory). The  -la  component of the command is what's known as a 'flag'. Flags modify the command that's being run. In this case the  l  displays the contents of the directory in a list, showing data such as their sizes and when they were last edited, and the  a  displays all files, including those beginning with a  . , known as 'dotfiles'. Dotfiles usually act as configuration files for software and as they are written in text, they can be modified by simply editing them.  In order to navigate to other directories the change directory command,  cd , can be used. You can specify the directory that you want to go to by either the 'absolute' or the 'relative' path. So if you wanted to navigate to the  python_games  directory, you could either do  cd /home/pi/python_games  or just  cd python_games  (if you are currently in  /home/pi ). There are some special cases that may be useful:  ~  acts as an alias for your home directory, so  ~/python_games  is the same as  /home/pi/python_games ;  .  and  ..  are aliases for the current directory and the parent directory respectively, e.g. if you were in  /home/pi/python_games ,  cd ..  would take you to  /home/pi .",
            "title": "Navigating and browsing your Pi"
        },
        {
            "location": "/usage/terminal/README/index.html#history-and-auto-complete",
            "text": "Rather than type every command, the terminal allows you to scroll through previous commands that you've run by pressing the  up  or  down  keys on your keyboard. If you are writing the name of a file or directory as part of a command then pressing  tab  will attempt to auto-complete the name of what you are typing. For example, if you have a file in a directory called  aLongFileName  then pressing tab after typing  a  will allow you to choose from all file and directory names beginning with  a  in the current directory, allowing you to choose  aLongFileName .",
            "title": "History and auto-complete"
        },
        {
            "location": "/usage/terminal/README/index.html#sudo",
            "text": "Some commands that make permanent changes to the state of your system require you to have root privileges to run. The command  sudo  temporarily gives your account (if you're not already logged in as root) the ability to run these commands, provided your user name is in a list of users ('sudoers'). When you append  sudo  to the start of a command and press  enter  you will be asked for your password, if that is entered correctly then the command you want to run will be run using root privileges. Be careful though, some commands that require  sudo  to run can irreparably damage your system so be careful!  Further information on  sudo  and the root user can be found on the  linux root page .",
            "title": "Sudo"
        },
        {
            "location": "/usage/terminal/README/index.html#installing-software-through-apt-get",
            "text": "Rather than using the Pi Store to download new software you can use the command  apt-get , this is the 'package manager' that is included with any Debian based Linux distributions (including Raspbian). It allows you to install and manage new software packages on your Pi. In order to install a new package you would type  sudo apt-get install <package-name>  (where  <package-name>  is the package that you want to install). Running  sudo apt-get update  updates a list of software packages that are available on your system. If a new version of a package is available then  sudo apt-get upgrade  will update any old packages to the new version. Finally,  sudo apt-get remove <package-name>  removes or uninstalls a package from your system.  More information about this can be found in the  linux usage section on apt .",
            "title": "Installing software through apt-get"
        },
        {
            "location": "/usage/terminal/README/index.html#other-useful-commands",
            "text": "There are a few other commands that you may find useful, these are listed below:   cp  makes a copy of a file and places it at the specified location (essentially doing a 'copy-paste'), for example -  cp file_a /home/other_user/  would copy the file  file_a  from your home directory to that of the user  other_user  (assuming you have permission to copy it there). Note that if the target is a folder, the filename will remain the same, but if the target is a filename, it will give the file the new name.  mv  moves a file and places it at the specified location (so where  cp  performs a 'copy-paste',  mv  performs a 'cut-paste'). The usage is similar to  cp , so  mv file_a /home/other_user/  would move the file  file_a  from your home directory to that of the specified user.  mv  is also used to rename a file, i.e. move it to a new location, e.g.  mv hello.txt story.txt .  rm  removes the specified file (or directory when used with  -r ).  Warning:  Files deleted in this way are generally not restorable.  mkdir : This makes a new directory, e.g.  mkdir new_dir  would create the directory  new_dir  in the present working directory.  cat  lists the contents of files, e.g.  cat some_file  will display the contents of  some_file .   Other commands you may find useful can be found in the  commands page .",
            "title": "Other useful commands"
        },
        {
            "location": "/usage/terminal/README/index.html#finding-out-about-a-command",
            "text": "To find out more information about a particular command then you can run the  man  followed by the command you want to know more about (e.g.  man ls ). The man-page (or manual page) for that command will be displayed, including information about the flags for that program and what effect they have. Some man-pages will give example usage.",
            "title": "Finding out about a command"
        },
        {
            "location": "/usage/video/README/index.html",
            "text": "Playing video on the Raspberry Pi\n\n\nTo play a video, navigate to the location of your video file in the terminal using \ncd\n, then type the following command:\n\n\nomxplayer example.mp4\n\n\n\n\n\nThis will play the \nexample.mp4\n in full screen. Hit \nCtrl + C\n to exit.\n\n\nExample video sample: Big Buck Bunny\n\n\nThere is a video sample of the animated film \nBig Buck Bunny\n available on the Pi. To play, it enter the following command into the terminal:\n\n\nomxplayer /opt/vc/src/hello_pi/hello_video/test.h264",
            "title": "Playing video on the Raspberry Pi"
        },
        {
            "location": "/usage/video/README/index.html#playing-video-on-the-raspberry-pi",
            "text": "To play a video, navigate to the location of your video file in the terminal using  cd , then type the following command:  omxplayer example.mp4  This will play the  example.mp4  in full screen. Hit  Ctrl + C  to exit.",
            "title": "Playing video on the Raspberry Pi"
        },
        {
            "location": "/usage/video/README/index.html#example-video-sample-big-buck-bunny",
            "text": "There is a video sample of the animated film  Big Buck Bunny  available on the Pi. To play, it enter the following command into the terminal:  omxplayer /opt/vc/src/hello_pi/hello_video/test.h264",
            "title": "Example video sample: Big Buck Bunny"
        },
        {
            "location": "/usage/webcams/README/index.html",
            "text": "Using a standard USB webcam\n\n\nRather than using the Raspberry Pi \ncamera module\n, you can use a standard USB webcam to take pictures and video on the Raspberry Pi.\n\n\nNote that the quality and configurability of the camera module is highly superior to a standard USB webcam.\n\n\nInstall fswebcam\n\n\nFirst, install the \nfswebcam\n package:\n\n\nsudo apt-get install fswebcam\n\n\n\n\n\nBasic usage\n\n\nEnter the command \nfswebcam\n followed by a filename and a picture will be taken using the webcam, and saved to the filename specified:\n\n\nfswebcam image.jpg\n\n\n\n\n\nThis command will show the following information:\n\n\n--- Opening /dev/video0...\n\nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first.\nAdjusting resolution from 384x288 to 352x288.\n\n--- Capturing frame...\n\nCorrupt JPEG data: 2 extraneous bytes before marker 0xd4\nCaptured frame in 0.00 seconds.\n\n--- Processing captured image...\n\nWriting JPEG image to 'image.jpg'.\n\n\n\n\n\n\n\nNote the small default resolution used, and the presence of a banner showing the timestamp.\n\n\nSpecify resolution\n\n\nThe webcam used in this example has a resolution of \n1280 x 720\n so to specify the resolution I want the image to be taken at, use the \n-r\n flag:\n\n\nfswebcam -r 1280x720 image2.jpg\n\n\n\n\n\nThis command will show the following information:\n\n\n--- Opening /dev/video0...\n\nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first.\n\n--- Capturing frame...\n\nCorrupt JPEG data: 1 extraneous bytes before marker 0xd5\nCaptured frame in 0.00 seconds.\n\n--- Processing captured image...\n\nWriting JPEG image to 'image2.jpg'.\n\n\n\n\n\n\n\nPicture now taken at the full resolution of the webcam, with the banner present.\n\n\nSpecify no banner\n\n\nNow add the \n--no-banner\n flag:\n\n\nfswebcam -r 1280x720 --no-banner image3.jpg\n\n\n\n\n\nwhich shows the following information:\n\n\n--- Opening /dev/video0...\n\nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first.\n\n--- Capturing frame...\n\nCorrupt JPEG data: 2 extraneous bytes before marker 0xd6\nCaptured frame in 0.00 seconds.\n\n--- Processing captured image...\n\nDisabling banner.\nWriting JPEG image to 'image3.jpg'.\n\n\n\n\n\n\n\nNow the picture is taken at full resolution with no banner.\n\n\nBad Pictures\n\n\nYou may experience poor quality pictures with a USB webcam, such as this accidentally artistic piece:\n\n\n\n\nSome webcams are more reliable than others, but this sort of issue may occur with poor quality webcams. If the problem persists, ensure your system is \nup to date\n. Also try other webcams, but you'll get the best performance from the Raspberry Pi \ncamera module\n.\n\n\nBash script\n\n\nYou can write a Bash script which takes a picture with the webcam. The script below saves the images in the \n/home/pi/webcam\n directory, so create the \nwebcam\n subdirectory first with:\n\n\nmkdir webcam\n\n\n\n\n\nTo create a script, open up your editor of choice and write the following example code:\n\n\n#!/bin/bash\n\n\n\nDATE\n=\n$(\ndate +\n\"%Y-%m-%d_%H%M\"\n)\n\n\nfswebcam -r 1280x720 --no-banner /home/pi/webcam/\n$DATE\n.jpg\n\n\n\n\n\nThis script will take a picture and name the file with a timestamp. Say we saved it as \nwebcam.sh\n, we would first make the file executable:\n\n\nchmod +x webcam.sh\n\n\n\n\n\nThen run with:\n\n\n./webcam.sh\n\n\n\n\n\nWhich would run the commands in the file and give the usual output:\n\n\n--- Opening /dev/video0...\n\nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first.\n\n--- Capturing frame...\n\nCorrupt JPEG data: 2 extraneous bytes before marker 0xd6\nCaptured frame in 0.00 seconds.\n\n--- Processing captured image...\n\nDisabling banner.\nWriting JPEG image to '/home/pi/webcam/2013-06-07_2338.jpg'.\n\n\n\n\n\nTime-lapse using cron\n\n\nYou can use \ncron\n to schedule taking a picture at a given interval, such as every minute to capture a time-lapse.\n\n\nFirst open the cron table for editing:\n\n\ncrontab -e\n\n\n\n\n\nThis will either ask which editor you would like to use, or open in your default editor. Once you have the file open in an editor, add the following line to schedule taking a picture every minute (referring to the Bash script from above):\n\n\n* * * * * /home/pi/webcam.sh \n2\n>\n&\n1\n\n\n\n\n\n\nSave and exit and you should see the message:\n\n\ncrontab: installing new crontab\n\n\n\n\n\nEnsure your script does not save each picture taken with the same filename. This will overwrite the picture each time.\n\n\nOther Useful tools\n\n\nOther tools are available that may come in handy when using the camera or a webcam:\n\n\n\n\nSSH\n\n\nUse SSH to remotely access the Raspberry Pi over your local network\n\n\n\n\n\n\nSCP\n\n\nCopy files over SSH to get copies of pictures taken on the Pi on your main computer\n\n\n\n\n\n\nrsync\n\n\nUse \nrsync\n to synchronise the folder of pictures taken in a folder between your Pi to your computer\n\n\n\n\n\n\ncron\n\n\nUse \ncron\n to schedule taking a picture at a given interval, such as every minute to capture a time-lapse",
            "title": "Using a standard USB webcam"
        },
        {
            "location": "/usage/webcams/README/index.html#using-a-standard-usb-webcam",
            "text": "Rather than using the Raspberry Pi  camera module , you can use a standard USB webcam to take pictures and video on the Raspberry Pi.  Note that the quality and configurability of the camera module is highly superior to a standard USB webcam.",
            "title": "Using a standard USB webcam"
        },
        {
            "location": "/usage/webcams/README/index.html#install-fswebcam",
            "text": "First, install the  fswebcam  package:  sudo apt-get install fswebcam",
            "title": "Install fswebcam"
        },
        {
            "location": "/usage/webcams/README/index.html#basic-usage",
            "text": "Enter the command  fswebcam  followed by a filename and a picture will be taken using the webcam, and saved to the filename specified:  fswebcam image.jpg  This command will show the following information:  --- Opening /dev/video0... \nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first.\nAdjusting resolution from 384x288 to 352x288. --- Capturing frame... \nCorrupt JPEG data: 2 extraneous bytes before marker 0xd4\nCaptured frame in 0.00 seconds. --- Processing captured image... \nWriting JPEG image to 'image.jpg'.   Note the small default resolution used, and the presence of a banner showing the timestamp.",
            "title": "Basic usage"
        },
        {
            "location": "/usage/webcams/README/index.html#specify-resolution",
            "text": "The webcam used in this example has a resolution of  1280 x 720  so to specify the resolution I want the image to be taken at, use the  -r  flag:  fswebcam -r 1280x720 image2.jpg  This command will show the following information:  --- Opening /dev/video0... \nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first. --- Capturing frame... \nCorrupt JPEG data: 1 extraneous bytes before marker 0xd5\nCaptured frame in 0.00 seconds. --- Processing captured image... \nWriting JPEG image to 'image2.jpg'.   Picture now taken at the full resolution of the webcam, with the banner present.",
            "title": "Specify resolution"
        },
        {
            "location": "/usage/webcams/README/index.html#specify-no-banner",
            "text": "Now add the  --no-banner  flag:  fswebcam -r 1280x720 --no-banner image3.jpg  which shows the following information:  --- Opening /dev/video0... \nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first. --- Capturing frame... \nCorrupt JPEG data: 2 extraneous bytes before marker 0xd6\nCaptured frame in 0.00 seconds. --- Processing captured image... \nDisabling banner.\nWriting JPEG image to 'image3.jpg'.   Now the picture is taken at full resolution with no banner.",
            "title": "Specify no banner"
        },
        {
            "location": "/usage/webcams/README/index.html#bad-pictures",
            "text": "You may experience poor quality pictures with a USB webcam, such as this accidentally artistic piece:   Some webcams are more reliable than others, but this sort of issue may occur with poor quality webcams. If the problem persists, ensure your system is  up to date . Also try other webcams, but you'll get the best performance from the Raspberry Pi  camera module .",
            "title": "Bad Pictures"
        },
        {
            "location": "/usage/webcams/README/index.html#bash-script",
            "text": "You can write a Bash script which takes a picture with the webcam. The script below saves the images in the  /home/pi/webcam  directory, so create the  webcam  subdirectory first with:  mkdir webcam  To create a script, open up your editor of choice and write the following example code:  #!/bin/bash  DATE = $( date + \"%Y-%m-%d_%H%M\" ) \n\nfswebcam -r 1280x720 --no-banner /home/pi/webcam/ $DATE .jpg  This script will take a picture and name the file with a timestamp. Say we saved it as  webcam.sh , we would first make the file executable:  chmod +x webcam.sh  Then run with:  ./webcam.sh  Which would run the commands in the file and give the usual output:  --- Opening /dev/video0... \nTrying source module v4l2...\n/dev/video0 opened.\nNo input was specified, using the first. --- Capturing frame... \nCorrupt JPEG data: 2 extraneous bytes before marker 0xd6\nCaptured frame in 0.00 seconds. --- Processing captured image... \nDisabling banner.\nWriting JPEG image to '/home/pi/webcam/2013-06-07_2338.jpg'.",
            "title": "Bash script"
        },
        {
            "location": "/usage/webcams/README/index.html#time-lapse-using-cron",
            "text": "You can use  cron  to schedule taking a picture at a given interval, such as every minute to capture a time-lapse.  First open the cron table for editing:  crontab -e  This will either ask which editor you would like to use, or open in your default editor. Once you have the file open in an editor, add the following line to schedule taking a picture every minute (referring to the Bash script from above):  * * * * * /home/pi/webcam.sh  2 > & 1   Save and exit and you should see the message:  crontab: installing new crontab  Ensure your script does not save each picture taken with the same filename. This will overwrite the picture each time.",
            "title": "Time-lapse using cron"
        },
        {
            "location": "/usage/webcams/README/index.html#other-useful-tools",
            "text": "Other tools are available that may come in handy when using the camera or a webcam:   SSH  Use SSH to remotely access the Raspberry Pi over your local network    SCP  Copy files over SSH to get copies of pictures taken on the Pi on your main computer    rsync  Use  rsync  to synchronise the folder of pictures taken in a folder between your Pi to your computer    cron  Use  cron  to schedule taking a picture at a given interval, such as every minute to capture a time-lapse",
            "title": "Other Useful tools"
        },
        {
            "location": "/usage/wordpress/README/index.html",
            "text": "WordPress\n\n\nHere we'll show you how to set up an instance of a WordPress site to run on your Raspberry Pi using the Apache Web Server.\n\n\nSee the \nWeb Server WordPress\n learning resource for instructions on setting up WordPress on a Raspberry Pi.",
            "title": "WordPress"
        },
        {
            "location": "/usage/wordpress/README/index.html#wordpress",
            "text": "Here we'll show you how to set up an instance of a WordPress site to run on your Raspberry Pi using the Apache Web Server.  See the  Web Server WordPress  learning resource for instructions on setting up WordPress on a Raspberry Pi.",
            "title": "WordPress"
        },
        {
            "location": "/usage/xbmc/README/index.html",
            "text": "Following the rename of the XBMC project to Kodi, this page has been moved \nhere\n.",
            "title": "README"
        }
    ]
}